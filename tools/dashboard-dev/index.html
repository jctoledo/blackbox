<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><title>Blackbox</title>
<style>
:root{
    --bg:#f2f2f7;
    --surface:#ffffff;
    --text:#1c1c1e;
    --text-secondary:#48484a;
    --text-tertiary:#8e8e93;
    --divider:rgba(0,0,0,.08);
    --ok:#34c759;
    --amber:#ff9500;
    --red:#ff3b30;
    --mode-idle:#8e8e93;
    --mode-accel:#1c1c1e;
    --mode-brake:#ff3b30;
}
.dark{
    --bg:#000000;
    --surface:#1c1c1e;
    --text:#ffffff;
    --text-secondary:#aeaeb2;
    --text-tertiary:#636366;
    --divider:rgba(255,255,255,.08);
    --mode-idle:#636366;
    --mode-accel:#ffffff;
    --mode-brake:#ff3b30;
}
*{margin:0;padding:0;box-sizing:border-box}
body{
    font-family:-apple-system,BlinkMacSystemFont,'SF Pro Text','SF Pro Display',system-ui,sans-serif;
    background:var(--bg);
    color:var(--text);
    height:100vh;
    height:100dvh;
    display:flex;
    flex-direction:column;
    -webkit-user-select:none;
    user-select:none;
    overflow:hidden;
    transition:background 0.3s,color 0.3s;
}

.bbNum{
    font-variant-numeric:tabular-nums;
    font-feature-settings:"tnum" 1,"lnum" 1;
}

/* HEADER */
.bbTopbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:14px 16px;
    background:transparent;
    flex-shrink:0;
}
.bbBrandToggle{
    background:none;
    border:0;
    padding:0;
    display:flex;
    align-items:baseline;
    gap:8px;
    cursor:pointer;
    color:inherit;
    font-family:inherit;
}
.bbBrand{font-size:11px;font-weight:600;opacity:.55;letter-spacing:.03em}
.bbModeLabel{font-size:11px;font-weight:400;opacity:.40;letter-spacing:.03em}
.bbModeIcon{font-size:10px;opacity:.40}
.bbTopRight{
    display:flex;
    align-items:center;
    gap:10px;
}
.bbStatusCluster{
    display:flex;
    align-items:center;
    gap:12px;
    opacity:.55;
    font-size:10px;
    letter-spacing:.03em;
}
.bbStatusItem{display:flex;align-items:center;gap:4px}
.bbStatusItem .bbHigh{margin-right:2px}
.bbDot{width:6px;height:6px;border-radius:50%;background:var(--ok);display:inline-block;opacity:.9;margin-right:2px}
.bbHigh{color:var(--ok);font-weight:600}
.bbKebab{background:none;border:0;padding:4px;font-size:24px;line-height:1;opacity:.6;cursor:pointer;color:inherit}

/* APP CONTAINER */
.bbApp{
    flex:1;
    display:flex;
    flex-direction:column;
    padding:0 12px 8px;
    min-height:0;
}

/* CARD */
.bbCard{
    background:var(--surface);
    border-radius:16px;
    overflow:hidden;
}
.bbGCard{
    flex:1;
    display:flex;
    flex-direction:column;
    margin-bottom:4px;
}

/* TOP ROW */
.bbGTop{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    padding:12px 18px 6px;
    flex-shrink:0;
}
.bbGTopLeft{}
.bbSpeedLine{display:flex;align-items:baseline;gap:4px}
.bbSpeed{font-size:22px;font-weight:600;opacity:.75;transition:color 0.3s,opacity 0.3s}
.bbSpeed.peak{color:var(--amber);opacity:1}
.bbUnit{font-size:12px;opacity:.45}
.bbManeuver{font-size:14px;font-weight:600;margin-top:4px;min-width:7ch;transition:color 0.15s}
.bbGTopRight{font-size:11px;opacity:.50}

/* PLOT AREA */
.bbGPlotWrap{
    display:flex;
    justify-content:center;
    padding:2px 18px 0;
}
.bbGPlotFrame{
    position:relative;
    width:min(560px, 100%);
    aspect-ratio:1/1;
}
.bbGPlot{
    display:block;
    width:100%;
    height:100%;
}

/* AXIS LABELS */
.bbAxis{
    position:absolute;
    font-size:10px;
    font-weight:500;
    letter-spacing:.02em;
    text-transform:uppercase;
    opacity:.50;
    color:var(--text-tertiary);
    pointer-events:none;
}
.bbAxis--top{top:4px;left:50%;transform:translateX(-50%)}
.bbAxis--bottom{bottom:4px;left:50%;transform:translateX(-50%)}
.bbAxis--left{left:6px;top:50%;transform:translateY(-50%)}
.bbAxis--right{right:6px;top:50%;transform:translateY(-50%)}

.bbPlotMeta{
    position:absolute;
    top:6px;
    right:8px;
    font-size:10px;
    color:var(--text-tertiary);
    opacity:.50;
}

/* READOUT ROW */
.bbGReadoutRow{
    display:flex;
    justify-content:center;
    align-items:center;
    gap:0;
    padding:16px 18px;
    flex-shrink:0;
    margin:auto 0;
}
.bbGReadoutCol{
    flex:1;
    display:flex;
    flex-direction:column;
    align-items:center;
    text-align:center;
}
.bbGReadoutLbl{
    font-size:11px;
    letter-spacing:.02em;
    text-transform:uppercase;
    opacity:.55;
    color:var(--text-tertiary);
}
.bbGReadoutVal{
    margin-top:8px;
    font-size:34px;
    font-weight:600;
    line-height:1.0;
    min-width:8ch;
    display:inline-flex;
    align-items:baseline;
    justify-content:center;
    gap:2px;
}
.bbSign{display:inline-block;width:1.2ch;text-align:right;opacity:.9;margin-right:2px}
.bbGUnit{font-size:.5em;opacity:.55;margin-left:2px}
.bbGDivider{
    width:1px;
    height:48px;
    background:var(--divider);
    margin:0 12px;
    flex-shrink:0;
}

/* MAX STRIP */
.bbGMax{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px 16px;
    padding:16px 24px 20px;
    border-top:1px solid var(--divider);
    flex-shrink:0;
}
.bbMini{
    display:grid;
    grid-template-columns:auto 7ch;
    column-gap:10px;
    align-items:baseline;
}
.bbMiniLbl{font-size:11px;color:var(--text-tertiary);opacity:.75;white-space:nowrap}
.bbMiniVal{font-size:13px;font-weight:600;color:var(--text-secondary);text-align:left;justify-self:start}

/* CSV PROGRESS BAR */
.bbCsvRow{
    display:none;
    align-items:center;
    gap:10px;
    padding:10px 24px;
    border-top:1px solid var(--divider);
}
.bbCsvRow.visible{display:flex}
.bbCsvName{font-size:10px;color:var(--text-tertiary);max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.bbCsvProgress{
    flex:1;
    height:6px;
    background:var(--divider);
    border-radius:3px;
    cursor:pointer;
    position:relative;
}
.bbCsvBar{
    height:100%;
    background:var(--ok);
    width:0%;
    border-radius:3px;
    transition:width 0.1s linear;
}
.bbCsvTime{font-size:10px;color:var(--text-tertiary);font-variant-numeric:tabular-nums;min-width:70px;text-align:right}

/* TELEMETRY STRIP */
.bbTelemetryStrip{
    display:flex;
    gap:14px;
    justify-content:center;
    padding:14px 0 10px;
    font-size:11px;
    color:var(--text-tertiary);
    flex-shrink:0;
}
.bbTItem{display:flex;align-items:baseline;gap:3px}
.bbTItem .bbNum{color:var(--text-secondary);font-weight:500;display:inline-block;text-align:right}
.bbNum--hz{min-width:2.5ch}
.bbNum--gps{min-width:2ch}
.bbNum--drops{min-width:2ch}
.bbNum--yaw{min-width:3ch}

/* MENU */
.bbMenuOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.25);
    opacity:0;
    visibility:hidden;
    transition:opacity 0.15s ease;
    z-index:100;
}
.dark .bbMenuOverlay{background:rgba(0,0,0,0.5)}
.bbMenuOverlay.open{opacity:1;visibility:visible}
.bbMenuPanel{
    position:fixed;
    top:44px;
    right:12px;
    background:var(--surface);
    border-radius:12px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    min-width:180px;
    transform:scale(0.95);
    opacity:0;
    transition:transform 0.15s ease,opacity 0.15s ease;
    z-index:101;
    overflow:hidden;
}
.dark .bbMenuPanel{box-shadow:0 4px 20px rgba(0,0,0,0.4)}
.bbMenuOverlay.open .bbMenuPanel{transform:scale(1);opacity:1}
.bbMenuItem{
    display:block;
    width:100%;
    padding:14px 18px;
    font-size:15px;
    text-align:left;
    border:none;
    background:none;
    color:var(--text);
    cursor:pointer;
    border-bottom:0.5px solid var(--divider);
    font-family:inherit;
}
.bbMenuItem:last-child{border-bottom:none}
.bbMenuItem:active{background:var(--bg)}
.bbMenuItem.destructive{color:var(--red)}
</style></head>
<body>

<header class="bbTopbar">
    <button class="bbBrandToggle" id="brandToggle" aria-label="Toggle theme">
        <span class="bbBrand">Blackbox</span>
        <span class="bbModeLabel" id="modeLabel">Bright</span>
        <span class="bbModeIcon" aria-hidden="true">◐</span>
    </button>
    <div class="bbTopRight">
        <div class="bbStatusCluster">
            <span class="bbStatusItem" id="sourceLabel"><span class="bbHigh">SIM</span></span>
            <span class="bbStatusItem"><span class="bbDot"></span>GPS</span>
            <span class="bbStatusItem"><span class="bbDot"></span>IMU</span>
        </div>
        <button class="bbKebab" id="menu-btn" aria-label="Menu">⋮</button>
    </div>
</header>

<main class="bbApp">
    <section class="bbCard bbGCard">
        <div class="bbGTop">
            <div class="bbGTopLeft">
                <div class="bbSpeedLine"><span class="bbSpeed bbNum" id="speed">0</span><span class="bbUnit">km/h</span></div>
                <div class="bbManeuver" id="maneuver">IDLE</div>
            </div>
            <div class="bbGTopRight"><span class="bbNum" id="session-time">0:00</span></div>
        </div>

        <div class="bbGPlotWrap">
            <div class="bbGPlotFrame">
                <div class="bbAxis bbAxis--top">Accel</div>
                <div class="bbAxis bbAxis--bottom">Brake</div>
                <div class="bbAxis bbAxis--left">Left</div>
                <div class="bbAxis bbAxis--right">Right</div>
                <div class="bbPlotMeta" id="range-val">Range ±0.5g</div>
                <canvas class="bbGPlot" id="gcanvas"></canvas>
            </div>
        </div>

        <div class="bbGReadoutRow">
            <div class="bbGReadoutCol">
                <div class="bbGReadoutLbl">Lat</div>
                <div class="bbGReadoutVal bbNum" id="lat-g"><span class="bbSign">+</span><span class="bbVal">0.00</span><span class="bbGUnit">g</span></div>
            </div>
            <div class="bbGDivider"></div>
            <div class="bbGReadoutCol">
                <div class="bbGReadoutLbl">Long</div>
                <div class="bbGReadoutVal bbNum" id="lon-g"><span class="bbSign">+</span><span class="bbVal">0.00</span><span class="bbGUnit">g</span></div>
            </div>
        </div>

        <div class="bbGMax">
            <div class="bbMini"><span class="bbMiniLbl">Max Lat L</span><span class="bbMiniVal bbNum" id="max-l">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Lat R</span><span class="bbMiniVal bbNum" id="max-r">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Acc</span><span class="bbMiniVal bbNum" id="max-a">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Brk</span><span class="bbMiniVal bbNum" id="max-b">0.00g</span></div>
        </div>

        <!-- CSV Progress Bar -->
        <div class="bbCsvRow" id="csv-row">
            <span class="bbCsvName" id="csv-name"></span>
            <div class="bbCsvProgress" id="csv-progress">
                <div class="bbCsvBar" id="csv-bar"></div>
            </div>
            <span class="bbCsvTime" id="csv-time">0:00 / 0:00</span>
        </div>
    </section>

    <div class="bbTelemetryStrip">
        <span class="bbTItem"><span class="bbNum bbNum--hz" id="hz">30</span> Hz</span>
        <span class="bbTItem">GPS <span class="bbNum bbNum--gps" id="gps-acc">2</span>m</span>
        <span class="bbTItem">Drops <span class="bbNum bbNum--drops" id="drops">0</span></span>
        <span class="bbTItem">Yaw <span class="bbNum bbNum--yaw" id="yaw">0</span>°</span>
    </div>
</main>

<div class="bbMenuOverlay" id="menu-overlay">
    <div class="bbMenuPanel">
        <button class="bbMenuItem" id="menu-load">Load CSV</button>
        <button class="bbMenuItem" id="menu-sim">Back to Sim</button>
        <button class="bbMenuItem" id="menu-rec">Start Recording</button>
        <button class="bbMenuItem" id="menu-export">Export CSV</button>
        <button class="bbMenuItem destructive" id="menu-clear">Clear Session</button>
    </div>
</div>

<input type="file" id="csv-input" accept=".csv" style="display:none">

<script>
const CANYON_KEYFRAMES = [
    [0,      55,    0.15,  0.05,  3],
    [2000,   70,    0.30,  0.02,  1],
    [3500,   75,    0.10,  0.05,  5],
    [4500,   68,   -0.35,  0.10,  8],
    [5500,   55,   -0.20,  0.35,  25],
    [7000,   52,    0.05,  0.45,  32],
    [8500,   58,    0.25,  0.30,  20],
    [10000,  70,    0.30,  0.10,  6],
    [11500,  78,    0.15,  0.02,  0],
    [13000,  72,   -0.40,  -0.05, -3],
    [14500,  55,   -0.25,  -0.40, -30],
    [16500,  45,    0.05,  -0.55, -40],
    [18500,  50,    0.30,  -0.40, -28],
    [20000,  62,    0.25,  -0.15, -10],
    [21500,  65,    0.10,  0.25,  18],
    [22500,  60,    0.05,  -0.20, -15],
    [23500,  62,    0.15,  0.20,  14],
    [25000,  72,    0.30,  0.05,  2],
    [26500,  78,   -0.25,  -0.10, -8],
    [28000,  65,    0.05,  -0.42, -32],
    [30000,  55,    0.15,  0.05,  3],
];
const LOOP_DURATION = 30000;

const $ = id => document.getElementById(id);
const MODES = {0:'IDLE', 1:'ACCEL', 2:'BRAKE', 4:'CORNER', 5:'ACCEL', 6:'BRAKE'};
const MODE_COLORS = {
    0: 'var(--mode-idle)',
    1: 'var(--mode-accel)',
    2: 'var(--mode-brake)',
    4: 'var(--mode-idle)',
    5: 'var(--mode-accel)',
    6: 'var(--mode-brake)'
};

function getModeColorsHex() {
    return {
        0: isDark ? '#636366' : '#8e8e93',
        1: isDark ? '#ffffff' : '#1c1c1e',
        2: '#ff3b30',
        4: isDark ? '#636366' : '#8e8e93',
        5: isDark ? '#ffffff' : '#1c1c1e',
        6: '#ff3b30'
    };
}

let currentModeColor = '#8e8e93';

function catmullRom(p0, p1, p2, p3, t) {
    const t2 = t * t, t3 = t2 * t;
    return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3);
}

function getKeyframeInterp(timeMs) {
    const loopTime = timeMs % LOOP_DURATION;
    let i1 = 0;
    for (let i = 0; i < CANYON_KEYFRAMES.length - 1; i++) {
        if (loopTime >= CANYON_KEYFRAMES[i][0] && loopTime < CANYON_KEYFRAMES[i + 1][0]) { i1 = i; break; }
    }
    const kf0 = CANYON_KEYFRAMES[(i1 - 1 + CANYON_KEYFRAMES.length) % CANYON_KEYFRAMES.length];
    const kf1 = CANYON_KEYFRAMES[i1];
    const kf2 = CANYON_KEYFRAMES[(i1 + 1) % CANYON_KEYFRAMES.length];
    const kf3 = CANYON_KEYFRAMES[(i1 + 2) % CANYON_KEYFRAMES.length];
    const segDur = (kf2[0] - kf1[0] + LOOP_DURATION) % LOOP_DURATION || LOOP_DURATION;
    const t = Math.max(0, Math.min(1, (loopTime - kf1[0]) / segDur));
    return { kf0, kf1, kf2, kf3, t };
}

function getAutoValues(timeMs) {
    const { kf0, kf1, kf2, kf3, t } = getKeyframeInterp(timeMs);
    return {
        speed: catmullRom(kf0[1], kf1[1], kf2[1], kf3[1], t),
        lonG: catmullRom(kf0[2], kf1[2], kf2[2], kf3[2], t),
        latG: catmullRom(kf0[3], kf1[3], kf2[3], kf3[3], t),
        yawDeg: catmullRom(kf0[4], kf1[4], kf2[4], kf3[4], t)
    };
}

function addNoise(val, amount) { return val + (Math.random() - 0.5) * amount * 0.15; }

// === CSV REPLAY ===
let dataSource = 'loop';
let csvData = null;
let csvFileName = '';
let csvPlaybackIndex = 0;
let csvStartTime = 0;
let csvDuration = 0;

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        if (values.length < 8) continue;
        data.push({
            t: parseFloat(values[0]),
            speed: parseFloat(values[1]),
            latG: parseFloat(values[6]),
            lonG: parseFloat(values[7]),
            yawRad: parseFloat(values[4]),
            mode: parseInt(values[5]) || 0
        });
    }
    if (data.length > 0) {
        const startT = data[0].t;
        data.forEach(d => d.relativeT = d.t - startT);
    }
    return data;
}

function loadCSVData(text, filename) {
    csvData = parseCSV(text);
    if (csvData.length === 0) { alert('No valid data in CSV'); return; }
    csvFileName = filename;
    csvDuration = csvData[csvData.length - 1].relativeT;
    csvPlaybackIndex = 0;
    csvStartTime = Date.now();
    dataSource = 'csv';
    resetState();
    updateSourceUI();
}

function switchToLoop() {
    dataSource = 'loop';
    loopStartTime = Date.now();
    resetState();
    updateSourceUI();
}

function updateSourceUI() {
    const csvRow = $('csv-row');
    const sourceLabel = $('sourceLabel');
    if (dataSource === 'csv') {
        csvRow.classList.add('visible');
        $('csv-name').textContent = csvFileName.length > 12 ? csvFileName.substring(0, 9) + '...' : csvFileName;
        sourceLabel.innerHTML = '<span class="bbHigh">CSV</span>';
    } else {
        csvRow.classList.remove('visible');
        sourceLabel.innerHTML = '<span class="bbHigh">SIM</span>';
    }
}

function formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function getCSVValues() {
    if (!csvData || csvData.length === 0) return null;
    const elapsed = Date.now() - csvStartTime;
    while (csvPlaybackIndex < csvData.length - 1 && csvData[csvPlaybackIndex + 1].relativeT <= elapsed) {
        csvPlaybackIndex++;
    }
    if (csvPlaybackIndex >= csvData.length - 1 && elapsed > csvDuration) {
        csvPlaybackIndex = 0;
        csvStartTime = Date.now();
    }
    const frame = csvData[csvPlaybackIndex];
    const progress = Math.min(1, elapsed / csvDuration);
    $('csv-bar').style.width = (progress * 100) + '%';
    $('csv-time').textContent = formatDuration(elapsed) + ' / ' + formatDuration(csvDuration);
    return {
        speed: frame.speed,
        lonG: frame.lonG,
        latG: frame.latG,
        yawDeg: frame.yawRad * 180 / Math.PI,
        mode: frame.mode
    };
}

function seekCSV(pct) {
    if (!csvData || csvDuration === 0) return;
    const seekTime = pct * csvDuration;
    csvPlaybackIndex = 0;
    for (let i = 0; i < csvData.length; i++) {
        if (csvData[i].relativeT <= seekTime) csvPlaybackIndex = i;
        else break;
    }
    csvStartTime = Date.now() - seekTime;
}

// IndexedDB Recording (matches production)
const DB_NAME = 'blackbox-rec', DB_VERSION = 1, CHUNK_INTERVAL = 60000;
let db = null, sessionId = null, chunkBuffer = [], chunkIndex = 0, lastSaveTime = 0, recSessionStart = 0;

function openDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains('chunks')) {
                d.createObjectStore('chunks', { keyPath: ['sessionId', 'chunkIndex'] });
            }
            if (!d.objectStoreNames.contains('sessions')) {
                d.createObjectStore('sessions', { keyPath: 'sessionId' });
            }
        };
    });
}

async function saveChunk() {
    if (!db || chunkBuffer.length === 0) return;
    const data = [...chunkBuffer];
    try {
        const tx = db.transaction('chunks', 'readwrite');
        await new Promise((resolve, reject) => {
            const req = tx.objectStore('chunks').put({ sessionId, chunkIndex, data, timestamp: Date.now() });
            req.onsuccess = resolve; req.onerror = () => reject(req.error);
        });
        chunkIndex++; chunkBuffer = []; lastSaveTime = Date.now();
    } catch (e) { console.error('Chunk save failed:', e); }
}

async function startRecording() {
    if (!db) await openDB();
    sessionId = Date.now(); recSessionStart = sessionId; chunkBuffer = []; chunkIndex = 0; lastSaveTime = Date.now(); rec = true;
    const tx = db.transaction('sessions', 'readwrite');
    tx.objectStore('sessions').put({ sessionId, startTime: sessionId, status: 'active' });
    $('menu-rec').textContent = 'Stop Recording';
}

async function stopRecording() {
    if (chunkBuffer.length > 0) await saveChunk();
    if (db && sessionId) {
        const tx = db.transaction('sessions', 'readwrite');
        tx.objectStore('sessions').put({ sessionId, startTime: recSessionStart, status: 'complete', chunks: chunkIndex });
    }
    rec = false;
    $('menu-rec').textContent = 'Start Recording';
}

async function exportCSV() {
    if (!db) { alert('No data'); return; }
    if (rec && chunkBuffer.length > 0) await saveChunk();
    const tx = db.transaction(['sessions', 'chunks'], 'readonly');
    const sessions = await new Promise(r => { const req = tx.objectStore('sessions').getAll(); req.onsuccess = () => r(req.result); });
    if (!sessions.length) { alert('No recordings found'); return; }
    const latest = sessions.sort((a, b) => b.sessionId - a.sessionId)[0];
    const chunks = await new Promise(r => { const req = tx.objectStore('chunks').getAll(); req.onsuccess = () => r(req.result); });
    const sessionChunks = chunks.filter(c => c.sessionId === latest.sessionId).sort((a, b) => a.chunkIndex - b.chunkIndex);
    if (!sessionChunks.length) { alert('No data in recording'); return; }
    let allData = [];
    sessionChunks.forEach(c => allData = allData.concat(c.data));
    let csv = 'time,speed,ax,ay,wz,mode,lat_g,lon_g,gps_lat,gps_lon,gps_valid\n';
    allData.forEach(r => { csv += [r.t, r.sp, r.ax, r.ay, r.wz, r.mo, r.latg, r.lng, r.lat || 0, r.lon || 0, r.gpsOk || 0].join(',') + '\n'; });
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = 'blackbox_' + new Date(latest.sessionId).toISOString().slice(0, 19).replace(/[T:]/g, '-') + '.csv'; a.click();
}

// State
let loopStartTime = Date.now();
let sessionStart = Date.now();
let rec = false, cnt = 0, drops = 0;
let trail = [], maxL = 0, maxR = 0, maxA = 0, maxB = 0, peak = 0;
let emaGx = 0, emaGy = 0, lastT = 0, speed_ema = 0;
const EMA_TAU = 0.10;
const TRAIL_DURATION_MS = 2500;
const TRAIL_MAX_POINTS = 60;
const TRAIL_JITTER_THRESHOLD = 0.008;

const SCALE_STEPS = [0.3, 0.5, 0.8, 1.0, 1.5, 2.0];
let currentScale = 0.5;

let config = { acc_thr: 0.22, acc_exit: 0.11, brake_thr: 0.35, brake_exit: 0.17, lat_thr: 0.28, lat_exit: 0.14, yaw_thr: 0.10, min_speed: 3.0, alpha: 0.35 };
let emaLat = 0, emaYaw = 0, inAccel = false, inBrake = false, inCorner = false;

function classifyMode(lonG, latG, yawRad, speedMs) {
    emaLat = config.alpha * Math.abs(latG) + (1 - config.alpha) * emaLat;
    emaYaw = config.alpha * Math.abs(yawRad) + (1 - config.alpha) * emaYaw;
    if (speedMs < config.min_speed) { inAccel = inBrake = inCorner = false; return 0; }
    if (lonG > config.acc_thr) inAccel = true; else if (lonG < config.acc_exit) inAccel = false;
    if (lonG < -config.brake_thr) inBrake = true; else if (lonG > -config.brake_exit) inBrake = false;
    const signConsistent = (latG * yawRad) > 0;
    if (emaLat > config.lat_thr && emaYaw > config.yaw_thr && signConsistent) inCorner = true;
    else if (emaLat < config.lat_exit || emaYaw < config.yaw_thr * 0.5) inCorner = false;
    let mode = 0;
    if (inAccel) mode |= 1; if (inBrake) mode |= 2; if (inCorner) mode |= 4;
    if ((mode & 3) === 3) mode &= ~2;
    return mode;
}

let isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
function applyTheme() {
    document.body.classList.toggle('dark', isDark);
    $('modeLabel').textContent = isDark ? 'Dark' : 'Bright';
}
applyTheme();

$('brandToggle').onclick = () => { isDark = !isDark; applyTheme(); };

const cv = $('gcanvas');
const ctx = cv.getContext('2d');

function resize() {
    const frame = cv.parentElement;
    const rect = frame.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    cv.width = size * devicePixelRatio;
    cv.height = size * devicePixelRatio;
    cv.style.width = size + 'px';
    cv.style.height = size + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
}
resize();
window.addEventListener('resize', resize);

let magHist = [];
function updateScale(gx, gy) {
    const now = Date.now();
    const mag = Math.sqrt(gx * gx + gy * gy);
    magHist.push({ t: now, m: mag });
    magHist = magHist.filter(h => now - h.t < 1000);
    const peakMag = Math.max(...magHist.map(h => h.m), 0.1);
    const needed = peakMag * 1.4;
    let targetScale = SCALE_STEPS[0];
    for (const step of SCALE_STEPS) {
        if (step >= needed) { targetScale = step; break; }
        targetScale = step;
    }
    if (targetScale > currentScale) currentScale += (targetScale - currentScale) * 0.15;
    else if (targetScale < currentScale) currentScale += (targetScale - currentScale) * 0.03;
    for (const step of SCALE_STEPS) {
        if (Math.abs(currentScale - step) < 0.02) { currentScale = step; break; }
    }
    $('range-val').textContent = 'Range ±' + currentScale.toFixed(1) + 'g';
}

function hexToRgba(hex, a) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${a})`;
}

function downsampleTrail(points, maxPoints) {
    if (points.length <= maxPoints) return points;
    const recentCount = Math.min(25, Math.floor(maxPoints * 0.4));
    const recent = points.slice(-recentCount);
    const older = points.slice(0, -recentCount);
    const olderTarget = maxPoints - recentCount;
    const step = Math.ceil(older.length / olderTarget);
    const sampled = older.filter((_, i) => i % step === 0);
    return [...sampled, ...recent];
}

function drawG() {
    const size = cv.width / devicePixelRatio;
    const cx = size / 2, cy = size / 2;
    const r = size * 0.38;

    ctx.clearRect(0, 0, size, size);

    const ringColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
    const axisColor = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.18)';

    ctx.lineWidth = 1;
    ctx.strokeStyle = ringColor;
    [0.2, 0.4, 0.6, 0.8].forEach((f) => {
        ctx.beginPath();
        ctx.arc(cx, cy, r * f, 0, Math.PI * 2);
        ctx.stroke();
    });

    ctx.strokeStyle = axisColor;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
    ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
    ctx.stroke();

    ctx.fillStyle = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fill();

    const now = Date.now();
    const recentTrail = trail.filter(p => now - p.t < TRAIL_DURATION_MS);
    const displayTrail = downsampleTrail(recentTrail, TRAIL_MAX_POINTS);

    if (displayTrail.length > 1) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        for (let i = 1; i < displayTrail.length; i++) {
            const p0 = displayTrail[i - 1];
            const p1 = displayTrail[i];
            const age = (now - p1.t) / TRAIL_DURATION_MS;
            const alpha = Math.max(0.05, 0.35 * (1 - age * 0.85));
            ctx.strokeStyle = hexToRgba(currentModeColor, alpha);
            ctx.lineWidth = 1.5 - age * 0.6;
            ctx.beginPath();
            const x0 = cx + (p0.x / currentScale) * r;
            const y0 = cy - (p0.y / currentScale) * r;
            const x1 = cx + (p1.x / currentScale) * r;
            const y1 = cy - (p1.y / currentScale) * r;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }
    }

    if (trail.length > 0) {
        const cur = trail[trail.length - 1];
        const x = cx + (cur.x / currentScale) * r;
        const y = cy - (cur.y / currentScale) * r;
        const crossSize = 8;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x - crossSize, y);
        ctx.lineTo(x + crossSize, y);
        ctx.moveTo(x, y - crossSize);
        ctx.lineTo(x, y + crossSize);
        ctx.stroke();
    }
}

function fmtGSigned(v) {
    const sign = v >= 0 ? '+' : '−';
    return { sign, num: Math.abs(v).toFixed(2) };
}

function fmtTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function updateModeDisplay(mo) {
    const name = MODES[mo] || 'IDLE';
    const color = MODE_COLORS[mo] || MODE_COLORS[0];
    const hexColors = getModeColorsHex();
    currentModeColor = hexColors[mo] || hexColors[0];
    const el = $('maneuver');
    el.textContent = name;
    el.style.color = color;
}

function updateReadouts(lat, lon) {
    const latFmt = fmtGSigned(lat);
    const lonFmt = fmtGSigned(lon);
    $('lat-g').innerHTML = `<span class="bbSign">${latFmt.sign}</span><span class="bbVal">${latFmt.num}</span><span class="bbGUnit">g</span>`;
    $('lon-g').innerHTML = `<span class="bbSign">${lonFmt.sign}</span><span class="bbVal">${lonFmt.num}</span><span class="bbGUnit">g</span>`;
}

function resetState() {
    maxL = maxR = maxA = maxB = peak = drops = 0;
    $('max-l').textContent = $('max-r').textContent = $('max-a').textContent = $('max-b').textContent = '0.00g';
    $('speed').classList.remove('peak');
    trail = []; magHist = []; currentScale = SCALE_STEPS[0];
    $('range-val').textContent = 'Range ±' + currentScale.toFixed(1) + 'g';
    emaGx = emaGy = 0; sessionStart = Date.now();
}

let peakHighlightTimeout = null;

function simulate() {
    let sp, longRaw, latRaw, yawDeg, yawRad, speedMs, mo;

    if (dataSource === 'csv' && csvData) {
        const values = getCSVValues();
        if (!values) return;
        sp = values.speed;
        longRaw = values.lonG;
        latRaw = values.latG;
        yawDeg = Math.abs(values.yawDeg);
        yawRad = values.yawDeg * Math.PI / 180;
        speedMs = sp / 3.6;
        mo = values.mode;
    } else {
        const elapsed = Date.now() - loopStartTime;
        const auto = getAutoValues(elapsed);
        sp = addNoise(auto.speed, 2);
        longRaw = addNoise(auto.lonG, 0.02);
        latRaw = addNoise(auto.latG, 0.02);
        yawDeg = Math.abs(addNoise(auto.yawDeg, 1));
        yawRad = auto.yawDeg * Math.PI / 180;
        speedMs = sp / 3.6;
        mo = classifyMode(longRaw, latRaw, yawRad, speedMs);
    }

    speed_ema = 0.7 * sp + 0.3 * speed_ema;
    const dspd = speed_ema < 1 ? 0 : Math.round(speed_ema);

    const now = Date.now();
    const dt = lastT ? Math.min((now - lastT) / 1000, 0.2) : 0.033;
    lastT = now;
    const alpha = 1 - Math.exp(-dt / EMA_TAU);

    emaGx = alpha * latRaw + (1 - alpha) * emaGx;
    emaGy = alpha * longRaw + (1 - alpha) * emaGy;

    const mag = Math.sqrt(emaGx * emaGx + emaGy * emaGy);
    const noise = speed_ema < 5 ? 0.04 : 0.015;
    const lat = mag < noise ? 0 : emaGx;
    const lon = mag < noise ? 0 : emaGy;

    const speedEl = $('speed');
    if (dspd > peak) {
        peak = dspd;
        speedEl.classList.add('peak');
        if (peakHighlightTimeout) clearTimeout(peakHighlightTimeout);
        peakHighlightTimeout = setTimeout(() => speedEl.classList.remove('peak'), 900);
    }
    speedEl.textContent = dspd;

    updateModeDisplay(mo);
    updateReadouts(lat, lon);
    $('yaw').textContent = Math.round(yawDeg);

    if (latRaw < 0 && Math.abs(latRaw) > maxL) { maxL = Math.abs(latRaw); $('max-l').textContent = maxL.toFixed(2) + 'g'; }
    if (latRaw > 0 && latRaw > maxR) { maxR = latRaw; $('max-r').textContent = maxR.toFixed(2) + 'g'; }
    if (longRaw > 0 && longRaw > maxA) { maxA = longRaw; $('max-a').textContent = maxA.toFixed(2) + 'g'; }
    if (longRaw < 0 && Math.abs(longRaw) > maxB) { maxB = Math.abs(longRaw); $('max-b').textContent = maxB.toFixed(2) + 'g'; }

    if (speed_ema >= 2) {
        updateScale(lat, lon);
    } else {
        magHist = [];
        currentScale = SCALE_STEPS[0];
        $('range-val').textContent = 'Range ±' + currentScale.toFixed(1) + 'g';
    }

    const lastPt = trail.length > 0 ? trail[trail.length - 1] : null;
    const dx = lastPt ? Math.abs(lat - lastPt.x) : 1;
    const dy = lastPt ? Math.abs(lon - lastPt.y) : 1;
    if (!lastPt || dx > TRAIL_JITTER_THRESHOLD || dy > TRAIL_JITTER_THRESHOLD) {
        trail.push({ x: lat, y: lon, t: now });
    }
    trail = trail.filter(p => now - p.t < TRAIL_DURATION_MS + 200);
    drawG();

    cnt++;
    if (rec) {
        chunkBuffer.push({ t: now, sp, ax: -longRaw * 9.81, ay: latRaw * 9.81, wz: yawRad, mo, latg: latRaw, lng: longRaw, lat: 37.82, lon: -122.48, gpsOk: 1 });
        if (now - lastSaveTime >= CHUNK_INTERVAL) saveChunk();
    }
}

setInterval(simulate, 33);

setInterval(() => {
    $('hz').textContent = cnt;
    cnt = 0;
    $('session-time').textContent = fmtTime(Date.now() - sessionStart);
    $('gps-acc').textContent = '2';
    $('drops').textContent = drops;
}, 1000);

$('menu-btn').onclick = () => $('menu-overlay').classList.add('open');
$('menu-overlay').onclick = e => { if (e.target === $('menu-overlay')) $('menu-overlay').classList.remove('open'); };

$('menu-load').onclick = () => {
    $('menu-overlay').classList.remove('open');
    $('csv-input').click();
};

$('csv-input').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => loadCSVData(evt.target.result, file.name);
    reader.readAsText(file);
};

$('menu-sim').onclick = () => {
    $('menu-overlay').classList.remove('open');
    switchToLoop();
};

$('csv-progress').onclick = (e) => {
    const rect = e.target.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    seekCSV(pct);
};

$('menu-rec').onclick = async () => {
    $('menu-overlay').classList.remove('open');
    if (rec) await stopRecording();
    else { sessionStart = Date.now(); await startRecording(); }
};

$('menu-export').onclick = () => {
    $('menu-overlay').classList.remove('open');
    exportCSV();
};

$('menu-clear').onclick = () => {
    $('menu-overlay').classList.remove('open');
    loopStartTime = Date.now();
    resetState();
};

setTimeout(() => { resize(); drawG(); }, 50);
openDB().catch(e => console.log('IndexedDB error:', e));
</script>
</body></html>
