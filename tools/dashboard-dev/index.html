<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"><title>Blackbox</title>
<style>
:root {
    --bg: #e8ecef;
    --surface: #e8ecef;
    --shadow-dark: #c5c9cc;
    --shadow-light: #ffffff;
    --text-primary: #2c3e50;
    --text-secondary: #7f8c8d;
    --text-muted: #a0aab0;
    --accent: #3498db;
    --accent-soft: rgba(52, 152, 219, 0.15);
    --radius: 24px;
    --radius-sm: 16px;
    --radius-pill: 50px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    height: 100vh;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    -webkit-user-select: none;
    user-select: none;
    overflow: hidden;
    padding: 24px;
    gap: 24px;
}

/* Neumorphic shadow mixins */
.neu-raised {
    background: var(--surface);
    border-radius: var(--radius);
    box-shadow:
        8px 8px 16px var(--shadow-dark),
        -8px -8px 16px var(--shadow-light);
}

.neu-inset {
    background: var(--surface);
    border-radius: var(--radius);
    box-shadow:
        inset 6px 6px 12px var(--shadow-dark),
        inset -6px -6px 12px var(--shadow-light);
}

.neu-flat {
    background: linear-gradient(145deg, #f0f4f7, #dce0e3);
    border-radius: var(--radius);
    box-shadow:
        6px 6px 12px var(--shadow-dark),
        -6px -6px 12px var(--shadow-light);
}

.neu-btn {
    background: linear-gradient(145deg, #f0f4f7, #dce0e3);
    border-radius: var(--radius-pill);
    box-shadow:
        4px 4px 8px var(--shadow-dark),
        -4px -4px 8px var(--shadow-light);
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
}

.neu-btn:active {
    box-shadow:
        inset 4px 4px 8px var(--shadow-dark),
        inset -4px -4px 8px var(--shadow-light);
}

/* Header - minimal */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 8px;
    flex-shrink: 0;
}

.logo {
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 3px;
    color: var(--text-muted);
    text-transform: uppercase;
}

.status-row {
    display: flex;
    align-items: center;
    gap: 16px;
}

.status-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    background: linear-gradient(145deg, #f0f4f7, #dce0e3);
    border-radius: var(--radius-pill);
    box-shadow:
        3px 3px 6px var(--shadow-dark),
        -3px -3px 6px var(--shadow-light);
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
}

.timer {
    font-variant-numeric: tabular-nums;
    letter-spacing: 1px;
}

/* Main content area */
.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 24px;
    overflow: hidden;
}

/* Speed Card - Hero element */
.speed-card {
    flex: 0 0 auto;
    padding: 48px 32px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.speed-value {
    font-size: clamp(96px, 25vw, 140px);
    font-weight: 200;
    letter-spacing: -4px;
    line-height: 0.9;
    color: var(--text-primary);
    font-variant-numeric: tabular-nums;
}

.speed-unit {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-muted);
    letter-spacing: 4px;
    text-transform: uppercase;
}

.maneuver {
    margin-top: 16px;
    font-size: 16px;
    font-weight: 600;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--accent);
    opacity: 0.8;
}

/* G-Force Card */
.gforce-card {
    flex: 1;
    min-height: 200px;
    position: relative;
    overflow: hidden;
}

.gforce-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.gforce-label {
    position: absolute;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    letter-spacing: 2px;
    z-index: 5;
}

.gforce-label.top { top: 20px; left: 50%; transform: translateX(-50%); }
.gforce-label.bottom { bottom: 20px; left: 50%; transform: translateX(-50%); }
.gforce-label.left { left: 20px; top: 50%; transform: translateY(-50%); }
.gforce-label.right { right: 20px; top: 50%; transform: translateY(-50%); }

.gforce-value {
    position: absolute;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-secondary);
    font-variant-numeric: tabular-nums;
    z-index: 5;
}

.gforce-value.top { top: 36px; left: 50%; transform: translateX(-50%); }
.gforce-value.bottom { bottom: 36px; left: 50%; transform: translateX(-50%); }
.gforce-value.left { left: 20px; top: calc(50% + 18px); transform: translateY(-50%); }
.gforce-value.right { right: 20px; top: calc(50% + 18px); transform: translateY(-50%); }

.clear-btn {
    position: absolute;
    top: 16px;
    left: 16px;
    padding: 10px 20px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 2px;
    color: var(--text-muted);
    z-index: 10;
    font-family: inherit;
}

/* Metrics Row */
.metrics-row {
    display: flex;
    gap: 16px;
    flex-shrink: 0;
}

.metric-card {
    flex: 1;
    padding: 20px 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.metric-value {
    font-size: 22px;
    font-weight: 300;
    color: var(--text-primary);
    font-variant-numeric: tabular-nums;
}

.metric-label {
    font-size: 10px;
    font-weight: 600;
    color: var(--text-muted);
    letter-spacing: 2px;
    text-transform: uppercase;
}

/* Controls Row */
.controls-row {
    display: flex;
    gap: 16px;
    flex-shrink: 0;
}

.control-btn {
    flex: 1;
    padding: 18px 24px;
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 2px;
    color: var(--text-secondary);
    font-family: inherit;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.control-btn.recording {
    color: #e74c3c;
}

.control-btn .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: currentColor;
}

/* Peak display */
.peak-row {
    display: flex;
    align-items: baseline;
    gap: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.peak-row.visible {
    opacity: 1;
}

.peak-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    letter-spacing: 2px;
}

.peak-value {
    font-size: 24px;
    font-weight: 300;
    color: var(--text-secondary);
    font-variant-numeric: tabular-nums;
}

/* CSV Replay Controls */
.csv-row {
    display: none;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    margin-top: -8px;
}

.csv-row.visible {
    display: flex;
}

.csv-name {
    font-size: 11px;
    font-weight: 500;
    color: var(--text-secondary);
    letter-spacing: 1px;
    max-width: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.csv-progress {
    flex: 1;
    height: 8px;
    background: var(--shadow-dark);
    border-radius: 4px;
    cursor: pointer;
    position: relative;
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.1);
}

.csv-bar {
    height: 100%;
    background: var(--accent);
    width: 0%;
    border-radius: 4px;
    transition: width 0.1s linear;
}

.csv-time {
    font-size: 11px;
    font-weight: 500;
    color: var(--text-muted);
    font-variant-numeric: tabular-nums;
    min-width: 80px;
    text-align: right;
}

/* Hidden elements */
.hidden { display: none !important; }
</style></head>
<body>

<!-- Header -->
<div class="header">
    <div class="logo">Blackbox</div>
    <div class="status-row">
        <div class="status-pill">
            <span class="status-dot"></span>
            <span id="stxt">SIM</span>
            <span class="timer" id="timer">00:00</span>
        </div>
    </div>
</div>

<!-- Main Content -->
<div class="main-content">

    <!-- Speed Card -->
    <div class="speed-card neu-raised">
        <div class="peak-row" id="peak-row">
            <span class="peak-label">PEAK</span>
            <span class="peak-value" id="peak-val">0</span>
        </div>
        <div class="speed-value" id="speed">0</div>
        <div class="speed-unit">km/h</div>
        <div class="maneuver" id="maneuver">Idle</div>
    </div>

    <!-- G-Force Card -->
    <div class="gforce-card neu-inset">
        <button class="clear-btn neu-btn" id="clear-btn">CLEAR</button>
        <span class="gforce-label top">BRAKE</span>
        <span class="gforce-label bottom">ACCEL</span>
        <span class="gforce-label left">L</span>
        <span class="gforce-label right">R</span>
        <span class="gforce-value top" id="maxB">0.00</span>
        <span class="gforce-value bottom" id="maxA">0.00</span>
        <span class="gforce-value left" id="maxL">0.00</span>
        <span class="gforce-value right" id="maxR">0.00</span>
        <canvas class="gforce-canvas" id="canvas"></canvas>
    </div>

    <!-- CSV Playback Progress -->
    <div class="csv-row neu-flat" id="csv-row">
        <span class="csv-name" id="csv-name"></span>
        <div class="csv-progress" id="csv-progress">
            <div class="csv-bar" id="csv-bar"></div>
        </div>
        <span class="csv-time" id="csv-time">0:00 / 0:00</span>
    </div>

    <!-- Metrics -->
    <div class="metrics-row">
        <div class="metric-card neu-flat">
            <div class="metric-value" id="latg">0.00</div>
            <div class="metric-label">Lat G</div>
        </div>
        <div class="metric-card neu-flat">
            <div class="metric-value" id="lng">0.00</div>
            <div class="metric-label">Lon G</div>
        </div>
        <div class="metric-card neu-flat">
            <div class="metric-value" id="yaw">0</div>
            <div class="metric-label">Yaw</div>
        </div>
        <div class="metric-card neu-flat">
            <div class="metric-value" id="hz">0</div>
            <div class="metric-label">Hz</div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls-row">
        <button class="control-btn neu-btn" id="rec">
            <span class="dot"></span>
            REC
        </button>
        <button class="control-btn neu-btn" id="exp">
            EXPORT
        </button>
        <button class="control-btn neu-btn" id="load-csv">
            LOAD
        </button>
        <button class="control-btn neu-btn hidden" id="sim-btn">
            SIM
        </button>
    </div>

</div>

<!-- Hidden file input -->
<input type="file" id="csv-input" accept=".csv" style="display:none">

<script>
// === CANYON DRIVE SIMULATION ===
const CANYON_KEYFRAMES = [
    [0,      55,    0.15,  0.05,  3],
    [2000,   70,    0.30,  0.02,  1],
    [3500,   75,    0.10,  0.05,  5],
    [4500,   68,   -0.35,  0.10,  8],
    [5500,   55,   -0.20,  0.35,  25],
    [7000,   52,    0.05,  0.45,  32],
    [8500,   58,    0.25,  0.30,  20],
    [10000,  70,    0.30,  0.10,  6],
    [11500,  78,    0.15,  0.02,  0],
    [13000,  72,   -0.40,  -0.05, -3],
    [14500,  55,   -0.25,  -0.40, -30],
    [16500,  45,    0.05,  -0.55, -40],
    [18500,  50,    0.30,  -0.40, -28],
    [20000,  62,    0.25,  -0.15, -10],
    [21500,  65,    0.10,  0.25,  18],
    [22500,  60,    0.05,  -0.20, -15],
    [23500,  62,    0.15,  0.20,  14],
    [25000,  72,    0.30,  0.05,  2],
    [26500,  78,   -0.25,  -0.10, -8],
    [28000,  65,    0.05,  -0.42, -32],
    [30000,  55,    0.15,  0.05,  3],
];

const LOOP_DURATION = 30000;
const $ = id => document.getElementById(id);

function catmullRom(p0, p1, p2, p3, t) {
    const t2 = t * t, t3 = t2 * t;
    return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3);
}

function getKeyframeInterp(timeMs) {
    const loopTime = timeMs % LOOP_DURATION;
    let i1 = 0;
    for (let i = 0; i < CANYON_KEYFRAMES.length - 1; i++) {
        if (loopTime >= CANYON_KEYFRAMES[i][0] && loopTime < CANYON_KEYFRAMES[i + 1][0]) { i1 = i; break; }
    }
    const kf0 = CANYON_KEYFRAMES[(i1 - 1 + CANYON_KEYFRAMES.length) % CANYON_KEYFRAMES.length];
    const kf1 = CANYON_KEYFRAMES[i1];
    const kf2 = CANYON_KEYFRAMES[(i1 + 1) % CANYON_KEYFRAMES.length];
    const kf3 = CANYON_KEYFRAMES[(i1 + 2) % CANYON_KEYFRAMES.length];
    const segDur = (kf2[0] - kf1[0] + LOOP_DURATION) % LOOP_DURATION || LOOP_DURATION;
    const t = Math.max(0, Math.min(1, (loopTime - kf1[0]) / segDur));
    return { kf0, kf1, kf2, kf3, t };
}

function getAutoValues(timeMs) {
    const { kf0, kf1, kf2, kf3, t } = getKeyframeInterp(timeMs);
    return {
        speed: catmullRom(kf0[1], kf1[1], kf2[1], kf3[1], t),
        lonG: catmullRom(kf0[2], kf1[2], kf2[2], kf3[2], t),
        latG: catmullRom(kf0[3], kf1[3], kf2[3], kf3[3], t),
        yawDeg: catmullRom(kf0[4], kf1[4], kf2[4], kf3[4], t)
    };
}

function addNoise(val, amount) { return val + (Math.random() - 0.5) * amount * 0.2; }

// State
let loopStartTime = Date.now();
let sessionStart = Date.now();
let rec = false, data = [], cnt = 0;
let trail = [], maxL = 0, maxR = 0, maxA = 0, maxB = 0;
let speed_ema = 0, displayedPeak = 0, sessionPeak = 0;
let emaGx = 0, emaGy = 0, lastProcessTime = 0;
const EMA_TAU = 0.10;

// Mode detection
const MANEUVERS = {0:'Idle', 1:'Accelerating', 2:'Braking', 4:'Cornering', 5:'Corner Exit', 6:'Trail Braking'};
let config = { acc_thr: 0.22, acc_exit: 0.11, brake_thr: 0.35, brake_exit: 0.17, lat_thr: 0.28, lat_exit: 0.14, yaw_thr: 0.10, min_speed: 3.0, alpha: 0.35 };
let emaLat = 0, emaYaw = 0, inAccel = false, inBrake = false, inCorner = false;

function classifyMode(lonG, latG, yawRad, speedMs) {
    emaLat = config.alpha * Math.abs(latG) + (1 - config.alpha) * emaLat;
    emaYaw = config.alpha * Math.abs(yawRad) + (1 - config.alpha) * emaYaw;
    if (speedMs < config.min_speed) { inAccel = inBrake = inCorner = false; return 0; }
    if (lonG > config.acc_thr) inAccel = true; else if (lonG < config.acc_exit) inAccel = false;
    if (lonG < -config.brake_thr) inBrake = true; else if (lonG > -config.brake_exit) inBrake = false;
    const signConsistent = (latG * yawRad) > 0;
    if (emaLat > config.lat_thr && emaYaw > config.yaw_thr && signConsistent) inCorner = true;
    else if (emaLat < config.lat_exit || emaYaw < config.yaw_thr * 0.5) inCorner = false;
    let mode = 0;
    if (inAccel) mode |= 1; if (inBrake) mode |= 2; if (inCorner) mode |= 4;
    if ((mode & 3) === 3) mode &= ~2;
    return mode;
}

// === CSV REPLAY ===
let dataSource = 'loop'; // 'loop' or 'csv'
let csvData = null;
let csvFileName = '';
let csvPlaybackIndex = 0;
let csvStartTime = 0;
let csvDuration = 0;

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const data = [];
    // Skip header, parse data rows
    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        if (values.length < 8) continue;
        data.push({
            t: parseFloat(values[0]),
            speed: parseFloat(values[1]),
            latG: parseFloat(values[6]),  // lat_g column
            lonG: parseFloat(values[7]),  // lon_g column
            yawRad: parseFloat(values[4]), // wz column
            mode: parseInt(values[5]) || 0
        });
    }
    // Convert to relative timestamps
    if (data.length > 0) {
        const startT = data[0].t;
        data.forEach(d => d.relativeT = d.t - startT);
    }
    return data;
}

function loadCSVData(text, filename) {
    csvData = parseCSV(text);
    if (csvData.length === 0) {
        alert('No valid data in CSV');
        return;
    }
    csvFileName = filename;
    csvDuration = csvData[csvData.length - 1].relativeT;
    csvPlaybackIndex = 0;
    csvStartTime = Date.now();
    dataSource = 'csv';
    resetGMax();
    updateSourceUI();
}

function switchToLoop() {
    dataSource = 'loop';
    loopStartTime = Date.now();
    resetGMax();
    updateSourceUI();
}

function updateSourceUI() {
    const loadBtn = $('load-csv');
    const simBtn = $('sim-btn');
    const csvRow = $('csv-row');
    const stxt = $('stxt');

    if (dataSource === 'csv') {
        loadBtn.classList.add('hidden');
        simBtn.classList.remove('hidden');
        csvRow.classList.add('visible');
        $('csv-name').textContent = csvFileName.length > 15 ?
            csvFileName.substring(0, 12) + '...' : csvFileName;
        stxt.textContent = 'CSV';
    } else {
        loadBtn.classList.remove('hidden');
        simBtn.classList.add('hidden');
        csvRow.classList.remove('visible');
        stxt.textContent = 'SIM';
    }
}

function formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function getCSVValues() {
    if (!csvData || csvData.length === 0) return null;

    const elapsed = Date.now() - csvStartTime;

    // Find current frame
    while (csvPlaybackIndex < csvData.length - 1 &&
           csvData[csvPlaybackIndex + 1].relativeT <= elapsed) {
        csvPlaybackIndex++;
    }

    // Loop if finished
    if (csvPlaybackIndex >= csvData.length - 1 && elapsed > csvDuration) {
        csvPlaybackIndex = 0;
        csvStartTime = Date.now();
    }

    const frame = csvData[csvPlaybackIndex];

    // Update progress bar
    const progress = Math.min(1, elapsed / csvDuration);
    $('csv-bar').style.width = (progress * 100) + '%';
    $('csv-time').textContent = formatDuration(elapsed) + ' / ' + formatDuration(csvDuration);

    return {
        speed: frame.speed,
        lonG: frame.lonG,
        latG: frame.latG,
        yawDeg: frame.yawRad * 180 / Math.PI,
        mode: frame.mode
    };
}

function seekCSV(pct) {
    if (!csvData || csvDuration === 0) return;
    const seekTime = pct * csvDuration;
    csvPlaybackIndex = 0;
    for (let i = 0; i < csvData.length; i++) {
        if (csvData[i].relativeT <= seekTime) csvPlaybackIndex = i;
        else break;
    }
    csvStartTime = Date.now() - seekTime;
}

// Canvas
const cv = $('canvas');
const ctx = cv.getContext('2d');

function resizeCanvas() {
    const card = cv.parentElement;
    const rect = card.getBoundingClientRect();
    cv.width = rect.width * window.devicePixelRatio;
    cv.height = rect.height * window.devicePixelRatio;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Auto-zoom
let magnitudeHistory = [], currentMaxG = 0.5;
const PEAK_WINDOW_MS = 800, MIN_MAX_G = 0.2, MAX_MAX_G = 2.0;

function updateAutoZoom(gx, gy) {
    const now = Date.now();
    const magnitude = Math.sqrt(gx * gx + gy * gy);
    magnitudeHistory.push({ time: now, mag: magnitude });
    magnitudeHistory = magnitudeHistory.filter(h => now - h.time < PEAK_WINDOW_MS);
    const m_peak = Math.max(...magnitudeHistory.map(h => h.mag), 0.05);
    const targetMaxG = Math.max(m_peak / (2/3), MIN_MAX_G);
    const ratio = targetMaxG / currentMaxG;
    if (ratio > 1.04) currentMaxG += (targetMaxG - currentMaxG) * 0.12;
    else if (ratio < 0.96) currentMaxG += (targetMaxG - currentMaxG) * 0.025;
    currentMaxG = Math.max(MIN_MAX_G, Math.min(MAX_MAX_G, currentMaxG));
}

// Draw G-meter - clean, minimal
function drawG() {
    const w = cv.width / window.devicePixelRatio;
    const h = cv.height / window.devicePixelRatio;
    const cx = w / 2, cy = h / 2;
    const radius = Math.min(w, h) * 0.35;

    ctx.clearRect(0, 0, w, h);

    // Subtle grid circles - neumorphic style
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.04)';
    ctx.lineWidth = 1;
    for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius * i / 3, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Cross lines
    ctx.beginPath();
    ctx.moveTo(cx - radius, cy);
    ctx.lineTo(cx + radius, cy);
    ctx.moveTo(cx, cy - radius);
    ctx.lineTo(cx, cy + radius);
    ctx.stroke();

    // Trail
    if (trail.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(52, 152, 219, 0.3)';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (let i = 0; i < trail.length; i++) {
            const p = trail[i];
            const x = cx + (p.x / currentMaxG) * radius;
            const y = cy - (p.y / currentMaxG) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // Current position dot
    if (trail.length > 0) {
        const current = trail[trail.length - 1];
        const x = cx + (current.x / currentMaxG) * radius;
        const y = cy - (current.y / currentMaxG) * radius;

        // Soft shadow
        ctx.beginPath();
        ctx.arc(x, y, 14, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
        ctx.fill();

        // Main dot
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fillStyle = '#3498db';
        ctx.fill();

        // Inner highlight
        ctx.beginPath();
        ctx.arc(x - 2, y - 2, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();
    }
}

// Format helpers
function fmtG(v) { return Math.abs(v) < 0.005 ? '0.00' : v.toFixed(2); }
function fmtTime(ms) { const s = Math.floor(ms / 1000), m = Math.floor(s / 60); return String(m).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0'); }

function resetGMax() {
    maxL = maxR = maxA = maxB = 0;
    $('maxL').textContent = $('maxR').textContent = $('maxA').textContent = $('maxB').textContent = '0.00';
    trail = [];
    magnitudeHistory = [];
    currentMaxG = 0.5;
    emaGx = emaGy = 0;
    displayedPeak = sessionPeak = 0;
    $('peak-val').textContent = '0';
    $('peak-row').classList.remove('visible');
    sessionStart = Date.now();
}

// Main loop
function simulate() {
    let sp, latg, lng, yawDeg, mo;

    if (dataSource === 'csv' && csvData) {
        const values = getCSVValues();
        if (values) {
            sp = values.speed;
            latg = values.latG;
            lng = values.lonG;
            yawDeg = Math.abs(values.yawDeg);
            mo = values.mode;
        } else {
            return;
        }
    } else {
        const elapsed = Date.now() - loopStartTime;
        const auto = getAutoValues(elapsed);
        sp = addNoise(auto.speed, 2);
        lng = addNoise(auto.lonG, 0.02);
        latg = addNoise(auto.latG, 0.02);
        const simYawDeg = addNoise(auto.yawDeg, 1);
        yawDeg = Math.abs(simYawDeg);
        const yawRad = simYawDeg * Math.PI / 180;
        const speedMs = sp / 3.6;
        mo = classifyMode(lng, latg, yawRad, speedMs);
    }

    speed_ema = 0.7 * sp + 0.3 * speed_ema;
    const dspd = speed_ema < 1 ? 0 : Math.round(speed_ema);

    // Time-based EMA
    const now = Date.now();
    const dt = lastProcessTime ? Math.min((now - lastProcessTime) / 1000, 0.2) : 0.033;
    lastProcessTime = now;
    const alpha = 1 - Math.exp(-dt / EMA_TAU);
    emaGx = alpha * latg + (1 - alpha) * emaGx;
    emaGy = alpha * lng + (1 - alpha) * emaGy;

    // Peak tracking
    if (dspd > sessionPeak) sessionPeak = dspd;
    if (lng < -0.1 && sessionPeak > displayedPeak) displayedPeak = sessionPeak;

    // Update UI
    $('speed').textContent = dspd;
    $('maneuver').textContent = MANEUVERS[mo] || 'Idle';

    // Peak display
    const peakRow = $('peak-row');
    if (displayedPeak > 0 && dspd < displayedPeak) {
        peakRow.classList.add('visible');
        $('peak-val').textContent = displayedPeak;
    } else {
        peakRow.classList.remove('visible');
    }

    // Metrics
    $('latg').textContent = fmtG(latg);
    $('lng').textContent = fmtG(lng);
    $('yaw').textContent = yawDeg.toFixed(0);

    // G-force
    const gx = emaGx, gy = emaGy;
    updateAutoZoom(gx, gy);
    trail.push({x: gx, y: gy});
    if (trail.length > 50) trail.shift();

    // Max values
    if (latg < 0 && Math.abs(latg) > maxL) { maxL = Math.abs(latg); $('maxL').textContent = maxL.toFixed(2); }
    if (latg > 0 && latg > maxR) { maxR = latg; $('maxR').textContent = maxR.toFixed(2); }
    if (lng > 0 && lng > maxA) { maxA = lng; $('maxA').textContent = maxA.toFixed(2); }
    if (lng < 0 && Math.abs(lng) > maxB) { maxB = Math.abs(lng); $('maxB').textContent = maxB.toFixed(2); }

    drawG();
    cnt++;

    if (rec) data.push({t: now, sp, ax: -lng * 9.81, ay: latg * 9.81, wz: yawDeg * Math.PI / 180, mo, latg, lng, lat: 37.8199, lon: -122.4783, gpsOk: 1});
}

setInterval(simulate, 33);
setInterval(() => {
    $('hz').textContent = cnt;
    cnt = 0;
    $('timer').textContent = fmtTime(Date.now() - sessionStart);
}, 1000);

// Clear button
$('clear-btn').onclick = resetGMax;

// Record button
$('rec').onclick = () => {
    rec = !rec;
    const btn = $('rec');
    if (rec) {
        data = [];
        btn.classList.add('recording');
        btn.innerHTML = '<span class="dot"></span> STOP';
    } else {
        btn.classList.remove('recording');
        btn.innerHTML = '<span class="dot"></span> REC';
        if (data.length) {
            const s = JSON.parse(localStorage.getItem('bb') || '[]');
            s.unshift({id: Date.now(), n: data.length, d: data});
            localStorage.setItem('bb', JSON.stringify(s.slice(0, 10)));
            alert('Saved ' + data.length + ' points');
        }
    }
};

// Export button
$('exp').onclick = () => {
    const s = JSON.parse(localStorage.getItem('bb') || '[]');
    if (!s.length) return alert('No data');
    let c = 'time,speed,ax,ay,wz,mode,lat_g,lon_g,gps_lat,gps_lon,gps_valid\n';
    s[0].d.forEach(r => { c += r.t + ',' + r.sp + ',' + r.ax + ',' + r.ay + ',' + r.wz + ',' + r.mo + ',' + r.latg + ',' + r.lng + ',' + (r.lat || 0) + ',' + (r.lon || 0) + ',' + (r.gpsOk || 0) + '\n'; });
    const b = new Blob([c], {type: 'text/csv'}), u = URL.createObjectURL(b), a = document.createElement('a');
    a.href = u; a.download = 'blackbox.csv'; a.click();
};

// CSV replay handlers
$('load-csv').onclick = () => $('csv-input').click();
$('csv-input').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => loadCSVData(evt.target.result, file.name);
    reader.readAsText(file);
};
$('sim-btn').onclick = switchToLoop;
$('csv-progress').onclick = (e) => {
    const rect = e.target.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    seekCSV(pct);
};
</script>
</body></html>
