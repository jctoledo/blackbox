<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><title>Blackbox</title>
<style>
:root{
    --bg:#f2f2f7;
    --surface:#ffffff;
    --text:#1c1c1e;
    --text-secondary:#48484a;
    --text-tertiary:#8e8e93;
    --divider:rgba(0,0,0,.08);
    --ok:#34c759;
    --amber:#ff9500;
    --red:#ff3b30;
    --mode-idle:#8e8e93;
    --mode-accel:#1c1c1e;
    --mode-brake:#ff3b30;
}
.dark{
    --bg:#000000;
    --surface:#1c1c1e;
    --text:#ffffff;
    --text-secondary:#aeaeb2;
    --text-tertiary:#636366;
    --divider:rgba(255,255,255,.08);
    --mode-idle:#636366;
    --mode-accel:#ffffff;
    --mode-brake:#ff3b30;
}
*{margin:0;padding:0;box-sizing:border-box}
body{
    font-family:-apple-system,BlinkMacSystemFont,'SF Pro Text','SF Pro Display',system-ui,sans-serif;
    background:var(--bg);
    color:var(--text);
    height:100vh;
    height:100dvh;
    display:flex;
    flex-direction:column;
    -webkit-user-select:none;
    user-select:none;
    overflow:hidden;
    transition:background 0.3s,color 0.3s;
}

.bbNum{
    font-variant-numeric:tabular-nums;
    font-feature-settings:"tnum" 1,"lnum" 1;
}

/* HEADER */
.bbTopbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:14px 16px;
    background:transparent;
    flex-shrink:0;
}
.bbBrandToggle{
    background:none;
    border:0;
    padding:0;
    display:flex;
    align-items:baseline;
    gap:8px;
    cursor:pointer;
    color:inherit;
    font-family:inherit;
}
.bbBrand{font-size:11px;font-weight:600;opacity:.55;letter-spacing:.03em}
.bbModeLabel{font-size:11px;font-weight:400;opacity:.40;letter-spacing:.03em}
.bbModeIcon{font-size:10px;opacity:.40}
.bbTopRight{
    display:flex;
    align-items:center;
    gap:10px;
}
.bbStatusCluster{
    display:flex;
    align-items:center;
    gap:12px;
    opacity:.55;
    font-size:10px;
    letter-spacing:.03em;
}
.bbStatusItem{display:flex;align-items:center;gap:4px}
.bbStatusItem .bbHigh{margin-right:2px}
.bbDot{width:6px;height:6px;border-radius:50%;background:var(--ok);display:inline-block;opacity:.9;margin-right:2px}
.bbHigh{color:var(--ok);font-weight:600}
.bbKebab{background:none;border:0;padding:4px;font-size:24px;line-height:1;opacity:.6;cursor:pointer;color:inherit}

/* APP CONTAINER */
.bbApp{
    flex:1;
    display:flex;
    flex-direction:column;
    padding:0 12px 8px;
    min-height:0;
}

/* CARD */
.bbCard{
    background:var(--surface);
    border-radius:16px;
    overflow:hidden;
}
.bbGCard{
    flex:1;
    display:flex;
    flex-direction:column;
    margin-bottom:4px;
}

/* TOP ROW */
.bbGTop{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    padding:12px 18px 6px;
    flex-shrink:0;
}
.bbGTopLeft{}
.bbSpeedLine{display:flex;align-items:baseline;gap:4px}
.bbSpeed{font-size:22px;font-weight:600;opacity:.75;transition:color 0.3s,opacity 0.3s}
.bbSpeed.peak{color:var(--amber);opacity:1}
.bbUnit{font-size:12px;opacity:.45}
.bbManeuver{font-size:14px;font-weight:600;margin-top:4px;min-width:7ch;transition:color 0.15s}
.bbGTopRight{font-size:11px;opacity:.50}

/* PLOT AREA */
.bbGPlotWrap{
    display:flex;
    justify-content:center;
    padding:2px 18px 0;
}
.bbGPlotFrame{
    position:relative;
    width:min(560px, 100%);
    aspect-ratio:1/1;
}
.bbGPlot{
    display:block;
    width:100%;
    height:100%;
}

/* AXIS LABELS */
.bbAxis{
    position:absolute;
    font-size:10px;
    font-weight:500;
    letter-spacing:.02em;
    text-transform:uppercase;
    opacity:.50;
    color:var(--text-tertiary);
    pointer-events:none;
}
.bbAxis--top{top:4px;left:50%;transform:translateX(-50%)}
.bbAxis--bottom{bottom:4px;left:50%;transform:translateX(-50%)}
.bbAxis--left{left:6px;top:50%;transform:translateY(-50%)}
.bbAxis--right{right:6px;top:50%;transform:translateY(-50%)}

.bbPlotMeta{
    position:absolute;
    top:6px;
    right:8px;
    font-size:10px;
    color:var(--text-tertiary);
    opacity:.50;
}

/* READOUT ROW */
.bbGReadoutRow{
    display:flex;
    justify-content:center;
    align-items:center;
    gap:0;
    padding:16px 18px;
    flex-shrink:0;
    margin:auto 0;
}
.bbGReadoutCol{
    flex:1;
    display:flex;
    flex-direction:column;
    align-items:center;
    text-align:center;
}
.bbGReadoutLbl{
    font-size:11px;
    letter-spacing:.02em;
    text-transform:uppercase;
    opacity:.55;
    color:var(--text-tertiary);
}
.bbGReadoutVal{
    margin-top:8px;
    font-size:34px;
    font-weight:600;
    line-height:1.0;
    min-width:8ch;
    display:inline-flex;
    align-items:baseline;
    justify-content:center;
    gap:2px;
}
.bbSign{display:inline-block;width:1.2ch;text-align:right;opacity:.9;margin-right:2px}
.bbGUnit{font-size:.5em;opacity:.55;margin-left:2px}
.bbGDivider{
    width:1px;
    height:48px;
    background:var(--divider);
    margin:0 12px;
    flex-shrink:0;
}

/* MAX STRIP */
.bbGMax{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px 16px;
    padding:16px 24px 20px;
    border-top:1px solid var(--divider);
    flex-shrink:0;
}
.bbMini{
    display:grid;
    grid-template-columns:auto 7ch;
    column-gap:10px;
    align-items:baseline;
}
.bbMiniLbl{font-size:11px;color:var(--text-tertiary);opacity:.75;white-space:nowrap}
.bbMiniVal{font-size:13px;font-weight:600;color:var(--text-secondary);text-align:left;justify-self:start}

/* CSV PROGRESS BAR */
.bbCsvRow{
    display:none;
    align-items:center;
    gap:10px;
    padding:10px 24px;
    border-top:1px solid var(--divider);
}
.bbCsvRow.visible{display:flex}
.bbCsvName{font-size:10px;color:var(--text-tertiary);max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.bbCsvProgress{
    flex:1;
    height:6px;
    background:var(--divider);
    border-radius:3px;
    cursor:pointer;
    position:relative;
}
.bbCsvBar{
    height:100%;
    background:var(--ok);
    width:0%;
    border-radius:3px;
    transition:width 0.1s linear;
}
.bbCsvTime{font-size:10px;color:var(--text-tertiary);font-variant-numeric:tabular-nums;min-width:70px;text-align:right}

/* TELEMETRY STRIP */
.bbTelemetryStrip{
    display:flex;
    gap:14px;
    justify-content:center;
    padding:14px 0 10px;
    font-size:11px;
    color:var(--text-tertiary);
    flex-shrink:0;
}
.bbTItem{display:flex;align-items:baseline;gap:3px}
.bbTItem .bbNum{color:var(--text-secondary);font-weight:500;display:inline-block;text-align:right}
.bbNum--hz{min-width:2.5ch}
.bbNum--gps{min-width:2ch}
.bbNum--drops{min-width:2ch}
.bbNum--yaw{min-width:3ch}

/* MENU */
.bbMenuOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.25);
    opacity:0;
    visibility:hidden;
    transition:opacity 0.15s ease;
    z-index:100;
}
.dark .bbMenuOverlay{background:rgba(0,0,0,0.5)}
.bbMenuOverlay.open{opacity:1;visibility:visible}
.bbMenuPanel{
    position:fixed;
    top:44px;
    right:12px;
    background:var(--surface);
    border-radius:12px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    min-width:180px;
    transform:scale(0.95);
    opacity:0;
    transition:transform 0.15s ease,opacity 0.15s ease;
    z-index:101;
    overflow:hidden;
}
.dark .bbMenuPanel{box-shadow:0 4px 20px rgba(0,0,0,0.4)}
.bbMenuOverlay.open .bbMenuPanel{transform:scale(1);opacity:1}
.bbMenuItem{
    display:block;
    width:100%;
    padding:14px 18px;
    font-size:15px;
    text-align:left;
    border:none;
    background:none;
    color:var(--text);
    cursor:pointer;
    border-bottom:0.5px solid var(--divider);
    font-family:inherit;
}
.bbMenuItem:last-child{border-bottom:none}
.bbMenuItem:active{background:var(--bg)}
.bbMenuItem.destructive{color:var(--red)}

/* LAP TIMER SECTION */
.bbLapCard{
    background:var(--surface);
    border-radius:16px;
    margin-bottom:8px;
    overflow:hidden;
}
.bbLapCard.inactive{
    padding:14px 18px;
}
.bbLapCard.active{
    padding:0;
}
.bbLapSetup{
    display:flex;
    justify-content:space-between;
    align-items:center;
}
.bbLapSetupText{
    font-size:13px;
    color:var(--text-tertiary);
}
.bbLapSetupBtn{
    background:var(--bg);
    border:none;
    border-radius:8px;
    padding:8px 16px;
    font-size:13px;
    font-weight:600;
    color:var(--text);
    cursor:pointer;
    font-family:inherit;
}
.bbLapSetupBtn:active{opacity:0.7}

.bbLapActive{display:none;cursor:pointer;position:relative}
.bbLapCard.active .bbLapActive{display:block}
.bbLapCard.active .bbLapSetup{display:none}

/* Lap timer stop button */
.bbLapStop{
    position:absolute;
    top:8px;
    right:8px;
    width:28px;
    height:28px;
    border-radius:50%;
    border:none;
    background:rgba(128,128,128,0.1);
    color:var(--text-tertiary);
    font-size:18px;
    font-weight:300;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:10;
    transition:all 0.15s;
}
.bbLapStop:hover{
    background:rgba(255,59,48,0.12);
    color:#ff3b30;
}
.bbLapStop:active{
    transform:scale(0.95);
    background:rgba(255,59,48,0.2);
}

.bbLapMain{
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:16px 18px 12px;
}
.bbLapTime{
    font-size:44px;
    font-weight:600;
    line-height:1;
}
.bbLapTrackName{
    font-size:12px;
    font-weight:500;
    opacity:0.45;
    margin-top:4px;
    letter-spacing:0.02em;
    max-width:200px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
}
.bbLapMeta{
    display:flex;
    align-items:center;
    gap:12px;
    margin-top:6px;
}
.bbLapCount{
    font-size:17px;
    font-weight:600;
    color:var(--text);
    opacity:0.6;
}
.bbLapState{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:0.04em;
    color:var(--text-tertiary);
    opacity:0.5;
}
.bbLapState.timing{color:var(--ok);opacity:0.9}
.bbLapState.finished{color:var(--ok);opacity:1;animation:finishedPulse 0.5s ease-in-out 2}
@keyframes finishedPulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}

/* ==========================================================================
   RACING-GAME INSPIRED DELTA BAR
   Layout: Text ABOVE, Bar BELOW (like GT/Forza/iRacing)
   Bar extends left (ahead/green) or right (behind/red) from center
   EXAGGERATED for dashboard-dev testing to feel the deltas during 20s laps
   ========================================================================== */

.bbDeltaBar{
    display:none;
    position:relative;
    width:100%;
    margin:6px 0 8px;
    /* Flexbox column: text on top, bar below */
    flex-direction:column;
    align-items:center;
    gap:4px;
}
/* Only show delta bar when timing AND we have a reference to compare against */
.bbLapCard.timing.has-ref .bbDeltaBar{display:flex}

/* Delta text - ABOVE the bar, large and prominent */
.bbDeltaText{
    font-size:28px;
    font-weight:800;
    font-variant-numeric:tabular-nums;
    letter-spacing:-0.02em;
    color:var(--text);
    text-shadow:0 2px 6px rgba(0,0,0,0.25);
    transition:color 0.12s ease;
    line-height:1;
}
.bbDeltaText.ahead{
    color:var(--ok);
    text-shadow:0 0 16px rgba(52,199,89,0.5), 0 2px 6px rgba(0,0,0,0.2);
}
.bbDeltaText.behind{
    color:var(--red);
    text-shadow:0 0 16px rgba(255,59,48,0.5), 0 2px 6px rgba(0,0,0,0.2);
}

/* Bar track - the background groove BELOW the text */
.bbDeltaTrack{
    position:relative;
    width:84%;
    height:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.04) 0%, rgba(0,0,0,0.12) 100%);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:5px;
    overflow:hidden;
}

/* Center marker - zero point (prominent vertical line) */
.bbDeltaCenter{
    position:absolute;
    left:50%;
    top:-1px;
    bottom:-1px;
    width:2px;
    background:rgba(255,255,255,0.3);
    transform:translateX(-50%);
    border-radius:1px;
    z-index:1;
}

/* The fill bar that extends from center */
.bbDeltaFill{
    position:absolute;
    top:0;
    height:100%;
    width:0%;
    left:50%;
    background:var(--ok);
    transition:width 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94),
               left 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94),
               background 0.12s ease,
               box-shadow 0.15s ease;
    border-radius:5px;
}

/* Ahead - GREEN (extending LEFT from center) */
.bbDeltaFill.ahead{
    background:linear-gradient(90deg, var(--ok) 0%, rgba(52,199,89,0.8) 100%);
}

/* Behind - RED (extending RIGHT from center) */
.bbDeltaFill.behind{
    background:linear-gradient(270deg, var(--red) 0%, rgba(255,59,48,0.8) 100%);
}

/* No reference state - subtle, waiting for first lap */
.bbDeltaBar.no-ref .bbDeltaTrack{opacity:0.2}
.bbDeltaBar.no-ref .bbDeltaCenter{opacity:0.2}
.bbDeltaBar.no-ref .bbDeltaText{
    font-size:14px;
    font-weight:500;
    color:var(--text-tertiary);
    opacity:0.5;
    text-shadow:none;
}
.bbDeltaBar.no-ref .bbDeltaFill{display:none}

/* Glow effects for dramatic deltas */
.bbDeltaFill.glow-ahead{
    box-shadow:0 0 16px rgba(52,199,89,0.7),
               0 0 32px rgba(52,199,89,0.3);
}
.bbDeltaFill.glow-behind{
    box-shadow:0 0 16px rgba(255,59,48,0.7),
               0 0 32px rgba(255,59,48,0.3);
}

/* Pulse animation for extreme deltas */
@keyframes deltaBarPulse{
    0%,100%{opacity:1}
    50%{opacity:0.85}
}
.bbDeltaFill.glow-ahead,
.bbDeltaFill.glow-behind{
    animation:deltaBarPulse 0.4s ease-in-out infinite;
}

/* First run badge */
.bbLapCard.first-run .bbLapMeta::after{
    content:'NEW';
    display:inline-block;
    margin-left:8px;
    padding:2px 6px;
    background:var(--amber);
    color:#fff;
    font-size:9px;
    font-weight:700;
    border-radius:4px;
    letter-spacing:0.05em;
}

/* P2P track styling - change "Lap" terminology to "Run" */
/* Note: History shows Best/Last/Delta which works for both - no changes needed */

.bbLapHistory{
    display:flex;
    justify-content:center;
    gap:0;
    padding:12px 18px;
    border-top:1px solid var(--divider);
}
.bbLapHistItem{
    flex:1;
    display:flex;
    flex-direction:column;
    align-items:center;
}
.bbLapHistDivider{
    width:1px;
    height:36px;
    background:var(--divider);
}
.bbLapHistLabel{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:0.02em;
    color:var(--text-tertiary);
    opacity:0.55;
}
.bbLapHistValue{
    font-size:20px;
    font-weight:600;
    margin-top:4px;
}
.bbLapHistValue.best{color:var(--ok)}
.bbLapHistValue.delta{font-size:18px}
.bbLapHistValue.delta.faster{color:var(--ok)}
.bbLapHistValue.delta.slower{color:var(--red)}

.bbLapFlash{
    animation:lapFlash 0.8s ease-out;
}
@keyframes lapFlash{
    0%{background:rgba(52,199,89,0.35);transform:scale(1.01)}
    15%{background:rgba(52,199,89,0.45);transform:scale(1.02)}
    100%{background:var(--surface);transform:scale(1)}
}
.bbLapBestFlash{
    animation:bestFlash 0.8s ease-out;
}
@keyframes bestFlash{
    0%,30%{transform:scale(1.05)}
    100%{transform:scale(1)}
}

/* START LINE APPROACH INDICATOR */
.bbStartLineIndicator{
    display:none;
    padding:10px 16px;
    border-top:1px solid var(--divider);
    text-align:center;
}
.bbLapCard.active .bbStartLineIndicator{display:block}
.bbLapCard.active.timing .bbStartLineIndicator{display:none}
.bbStartLineText{
    font-size:14px;
    color:var(--text-secondary);
    font-weight:500;
}
.bbStartLineText.approaching{color:var(--amber)}
.bbStartLineText.close{color:var(--ok)}
.bbStartLineText.at-line{
    color:var(--ok);
    font-weight:600;
}
/* Finish line indicator (P2P only, shown while running) */
.bbFinishLineIndicator{
    display:none;
    padding:10px 16px;
    border-top:1px solid var(--divider);
    text-align:center;
}
.bbLapCard.active.timing.p2p .bbFinishLineIndicator{display:block}
.bbFinishLineText{
    font-size:14px;
    color:var(--text-secondary);
    font-weight:500;
}
.bbFinishLineText.approaching{color:var(--amber)}
.bbFinishLineText.close{color:var(--ok)}
.bbFinishLineText.at-line{
    color:var(--ok);
    font-weight:600;
    animation:pulseText 1s ease-in-out infinite;
}
@keyframes pulseText{
    0%,100%{opacity:1}
    50%{opacity:0.5}
}

/* TRACK MANAGER MODAL */
.bbModal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.4);
    display:flex;
    align-items:center;
    justify-content:center;
    opacity:0;
    visibility:hidden;
    transition:opacity 0.2s ease;
    z-index:200;
    padding:16px;
}
.dark .bbModal{background:rgba(0,0,0,0.6)}
.bbModal.open{opacity:1;visibility:visible}
.bbModalContent{
    background:var(--surface);
    border-radius:16px;
    width:100%;
    max-width:400px;
    max-height:calc(100vh - 32px);
    overflow:hidden;
    display:flex;
    flex-direction:column;
    transform:scale(0.95);
    transition:transform 0.2s ease;
}
.bbModal.open .bbModalContent{transform:scale(1)}
.bbModalHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 18px;
    border-bottom:1px solid var(--divider);
}
.bbModalTitle{
    font-size:17px;
    font-weight:600;
}
.bbModalClose{
    background:none;
    border:none;
    font-size:24px;
    color:var(--text-tertiary);
    cursor:pointer;
    padding:0;
    line-height:1;
}
.bbModalClose:active{opacity:0.5}
.bbModalBody{
    padding:16px 18px;
    overflow-y:auto;
    flex:1;
}
.bbModalSection{
    margin-bottom:20px;
}
.bbModalSection:last-child{margin-bottom:0}
.bbSectionTitle{
    font-size:11px;
    font-weight:600;
    color:var(--text-tertiary);
    text-transform:uppercase;
    letter-spacing:0.08em;
    margin-bottom:10px;
}
.bbPosDisplay{
    background:var(--bg);
    border-radius:12px;
    padding:14px 16px;
}
.bbPosRow{
    display:flex;
    justify-content:space-between;
    align-items:baseline;
    padding:4px 0;
}
.bbPosLabel{
    font-size:12px;
    color:var(--text-tertiary);
}
.bbPosValue{
    font-size:14px;
    font-weight:600;
    font-variant-numeric:tabular-nums;
}
.bbPosValue.waiting{
    color:var(--text-tertiary);
    font-weight:400;
}
.bbActionBtn{
    display:block;
    width:100%;
    padding:14px 18px;
    border:none;
    border-radius:12px;
    font-size:15px;
    font-weight:600;
    cursor:pointer;
    font-family:inherit;
    margin-bottom:10px;
    transition:opacity 0.15s;
}
.bbActionBtn:last-child{margin-bottom:0}
.bbActionBtn:active{opacity:0.7}
.bbActionBtn.primary{
    background:var(--ok);
    color:#fff;
}
.bbActionBtn.secondary{
    background:var(--bg);
    color:var(--text);
}
.bbActionBtn:disabled{
    opacity:0.4;
    cursor:not-allowed;
}
/* ACTIVE TRACK DISPLAY (unified) */
.bbActiveTrack{
    display:flex;
    align-items:center;
    gap:12px;
    background:rgba(52,199,89,0.1);
    border:1px solid rgba(52,199,89,0.2);
    border-radius:12px;
    padding:12px 14px;
    margin-bottom:16px;
}
.bbActiveTrackInfo{flex:1;min-width:0}
.bbActiveTrackName{
    font-size:15px;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
}
.bbActiveTrackMeta{
    font-size:12px;
    color:var(--text-secondary);
    margin-top:2px;
}
.bbActiveTrackClear{
    width:28px;
    height:28px;
    border-radius:50%;
    border:none;
    background:rgba(128,128,128,0.12);
    color:var(--text-tertiary);
    font-size:16px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-shrink:0;
    transition:all 0.15s;
}
.bbActiveTrackClear:active{
    background:rgba(255,59,48,0.15);
    color:#ff3b30;
}

/* CREATE NEW TRACK (unified) */
.bbCreateTrackHint{
    font-size:13px;
    color:var(--text-secondary);
    margin:0 0 16px 0;
    line-height:1.5;
    text-align:center;
}
.bbCreateTrackBtns{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:12px;
}
.bbRecordStartBtn{
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:20px 14px 18px;
    border:2px solid var(--divider);
    border-radius:16px;
    background:linear-gradient(180deg, var(--surface) 0%, var(--bg) 100%);
    cursor:pointer;
    transition:all 0.2s ease;
    font-family:inherit;
    position:relative;
    overflow:hidden;
}
.bbRecordStartBtn::before{
    content:'';
    position:absolute;
    top:0;
    left:0;
    right:0;
    height:3px;
    background:linear-gradient(90deg, transparent, #ff3b30, transparent);
    opacity:0;
    transition:opacity 0.2s;
}
.bbRecordStartBtn:hover{
    border-color:rgba(255,59,48,0.35);
    background:linear-gradient(180deg, rgba(255,59,48,0.04) 0%, rgba(255,59,48,0.02) 100%);
}
.bbRecordStartBtn:hover::before{
    opacity:1;
}
.bbRecordStartBtn:active{
    transform:scale(0.97);
    border-color:#ff3b30;
}
.bbRecordStartIconWrap{
    width:48px;
    height:48px;
    border-radius:50%;
    background:rgba(255,59,48,0.1);
    display:flex;
    align-items:center;
    justify-content:center;
    margin-bottom:12px;
    transition:transform 0.2s, background 0.2s;
}
.bbRecordStartBtn:hover .bbRecordStartIconWrap{
    background:rgba(255,59,48,0.15);
    transform:scale(1.05);
}
.bbRecordStartIcon{
    font-size:22px;
    color:#ff3b30;
    line-height:1;
}
.bbRecordStartLabel{
    font-size:14px;
    font-weight:600;
    color:var(--text);
    margin-bottom:4px;
}
.bbRecordStartDesc{
    font-size:11px;
    color:var(--text-tertiary);
    text-align:center;
    line-height:1.35;
}

/* TRACK RECORDING OVERLAY (redesigned) */
.bbRecordOverlay{
    position:fixed;
    bottom:0;
    left:0;
    right:0;
    background:var(--surface);
    padding:24px 20px;
    padding-bottom:calc(24px + env(safe-area-inset-bottom, 0px));
    border-radius:24px 24px 0 0;
    box-shadow:0 -8px 32px rgba(0,0,0,0.18);
    z-index:250;
    transform:translateY(100%);
    transition:transform 0.35s cubic-bezier(0.32, 0.72, 0, 1);
    border-top:3px solid #ff3b30;
}
.bbRecordOverlay.active{transform:translateY(0)}

.bbRecordState{animation:fadeIn 0.25s ease-out}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}

.bbRecordHeader{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    margin-bottom:16px;
}
.bbRecordPulse{
    width:12px;
    height:12px;
    background:#ff3b30;
    border-radius:50%;
    animation:recPulse 1.2s ease-in-out infinite;
}
@keyframes recPulse{
    0%,100%{transform:scale(1);opacity:1;box-shadow:0 0 0 0 rgba(255,59,48,0.5)}
    50%{transform:scale(0.85);opacity:0.7;box-shadow:0 0 0 8px rgba(255,59,48,0)}
}
.bbRecordTitle{
    font-size:14px;
    font-weight:600;
    color:var(--text-secondary);
    letter-spacing:0.02em;
    text-transform:uppercase;
}

.bbRecordHero{
    text-align:center;
    padding:16px 0 20px;
}
.bbRecordHeroValue{
    font-size:72px;
    font-weight:700;
    letter-spacing:-0.04em;
    line-height:1;
    font-variant-numeric:tabular-nums;
    color:var(--text);
    background:linear-gradient(180deg, var(--text) 0%, var(--text-secondary) 100%);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
}
.bbRecordHeroUnit{
    font-size:12px;
    font-weight:600;
    color:var(--text-tertiary);
    margin-top:6px;
    text-transform:uppercase;
    letter-spacing:0.1em;
}

.bbRecordMeta{
    display:flex;
    justify-content:center;
    align-items:stretch;
    gap:0;
    margin-bottom:16px;
    padding:12px 16px;
    background:var(--bg);
    border-radius:12px;
}
.bbRecordMetaItem{
    flex:1;
    text-align:center;
    display:flex;
    flex-direction:column;
    justify-content:center;
}
.bbRecordMetaValue{
    font-size:18px;
    font-weight:700;
    font-variant-numeric:tabular-nums;
    color:var(--text);
    display:block;
    line-height:1.2;
}
.bbRecordMetaLabel{
    font-size:9px;
    color:var(--text-tertiary);
    text-transform:uppercase;
    letter-spacing:0.06em;
    margin-top:3px;
    font-weight:500;
}
.bbRecordMetaDivider{
    width:1px;
    height:auto;
    background:var(--divider);
    margin:0 10px;
    align-self:stretch;
}

.bbRecordQuality{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:14px;
    padding:10px 14px;
    background:var(--bg);
    border-radius:10px;
}
.bbRecordQualityBar{
    flex:1;
    height:6px;
    background:rgba(128,128,128,0.15);
    border-radius:3px;
    overflow:hidden;
}
.bbRecordQualityFill{
    height:100%;
    background:var(--ok);
    transition:width 0.3s ease-out, background 0.3s;
    border-radius:3px;
}
.bbRecordQualityFill.fair{background:var(--amber)}
.bbRecordQualityFill.poor{background:var(--red)}
.bbRecordQualityText{
    font-size:11px;
    font-weight:600;
    color:var(--text-secondary);
    min-width:60px;
    text-align:right;
    text-transform:uppercase;
    letter-spacing:0.02em;
}

.bbRecordHint{
    text-align:center;
    font-size:13px;
    color:var(--text-tertiary);
    margin:0 0 18px 0;
    line-height:1.45;
}

.bbRecordActions{
    display:flex;
    gap:10px;
}
.bbRecordActionBtn{
    flex:1;
    padding:14px 20px;
    border:none;
    border-radius:12px;
    font-size:15px;
    font-weight:600;
    cursor:pointer;
    font-family:inherit;
    text-align:center;
    justify-content:center;
    align-items:center;
    transition:transform 0.1s, opacity 0.15s;
}
.bbRecordActionBtn:active{transform:scale(0.97)}
.bbRecordActionBtn.secondary{
    background:rgba(128,128,128,0.12);
    color:var(--text);
}
.bbRecordActionBtn.primary{
    background:var(--ok);
    color:#fff;
}
.bbRecordActionBtn.finish{
    background:#ff3b30;
    color:#fff;
}

/* Track Complete Success State */
.bbRecordSuccess{
    text-align:center;
    padding:24px 16px 20px;
}
.bbRecordSuccessIcon{
    width:72px;
    height:72px;
    margin:0 auto 16px;
    background:linear-gradient(135deg, rgba(52,199,89,0.15) 0%, rgba(52,199,89,0.08) 100%);
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:36px;
    color:var(--ok);
    animation:successPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
@keyframes successPop{
    0%{transform:scale(0.5);opacity:0}
    100%{transform:scale(1);opacity:1}
}
.bbRecordSuccessTitle{
    font-size:24px;
    font-weight:700;
    color:var(--text);
    margin-bottom:8px;
    letter-spacing:-0.01em;
}
.bbRecordSuccessStats{
    font-size:14px;
    color:var(--text-secondary);
    line-height:1.4;
}

.bbTrackList{
    border-radius:12px;
    overflow:hidden;
    background:var(--bg);
}
.bbTrackEmpty{
    padding:20px;
    text-align:center;
    color:var(--text-tertiary);
    font-size:13px;
}
.bbTrackItem{
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    align-items:center;
    padding:12px 14px;
    border-bottom:1px solid var(--divider);
}
.bbTrackItem:last-child{border-bottom:none}
.bbTrackInfo{flex:1;min-width:0}
.bbTrackName{
    font-size:14px;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
}
.bbTrackMeta{
    font-size:11px;
    color:var(--text-tertiary);
    margin-top:2px;
}
.bbTrackMeta span{margin-right:10px}
.bbTrackActions{
    display:flex;
    gap:8px;
    margin-left:10px;
}
.bbTrackBtn{
    background:var(--surface);
    border:none;
    border-radius:6px;
    padding:6px 12px;
    font-size:12px;
    font-weight:600;
    color:var(--text);
    cursor:pointer;
    font-family:inherit;
}
.bbTrackBtn:active{opacity:0.7}
.bbTrackBtn.primary{
    background:var(--ok);
    color:#fff;
}
.bbTrackBtn.danger{
    color:var(--red);
}
.bbTrackBtn.secondary{
    background:var(--surface);
    color:var(--text-secondary);
    padding:6px 8px;
}

/* Track History Styles */
.bbTrackHistory{
    width:100%;
    margin-top:12px;
    padding-top:12px;
    border-top:1px solid var(--divider);
}
.bbHistoryEmpty{
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:16px;
    color:var(--text-tertiary);
    font-size:13px;
    text-align:center;
}
.bbHistoryHint{
    font-size:11px;
    margin-top:4px;
    opacity:0.7;
}
.bbHistorySummary{
    display:flex;
    justify-content:space-between;
    font-size:12px;
    color:var(--text-secondary);
    margin-bottom:10px;
}
.bbHistoryTotal{font-weight:600}
.bbHistorySession{
    background:var(--bg);
    border-radius:8px;
    padding:10px 12px;
    margin-bottom:8px;
}
.bbHistorySession:last-child{margin-bottom:0}
.bbHistorySessionHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:8px;
}
.bbHistoryDate{
    font-size:12px;
    font-weight:600;
    color:var(--text);
}
.bbHistorySessionStats{
    font-size:11px;
    color:var(--text-tertiary);
}
.bbHistoryLaps{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
}
.bbHistoryLap{
    font-size:11px;
    font-family:var(--mono);
    color:var(--text-secondary);
    background:var(--surface);
    padding:3px 6px;
    border-radius:4px;
}
.bbHistoryLap.best{
    color:var(--ok);
    font-weight:600;
}
.bbHistoryMore{
    font-size:11px;
    color:var(--text-tertiary);
    text-align:center;
    padding:8px;
    font-style:italic;
}
.bbHistoryActions{
    margin-top:12px;
    text-align:center;
}
.bbHistoryClearBtn{
    background:transparent;
    border:1px solid var(--red);
    color:var(--red);
    font-size:11px;
    padding:6px 12px;
    border-radius:6px;
    cursor:pointer;
    font-family:inherit;
}
.bbHistoryClearBtn:active{opacity:0.7}

.bbActiveTrack{
    background:var(--bg);
    border-radius:12px;
    padding:14px 16px;
    margin-bottom:16px;
}
.bbActiveTrackLabel{
    font-size:11px;
    color:var(--text-tertiary);
    text-transform:uppercase;
    letter-spacing:0.05em;
}
.bbActiveTrackName{
    font-size:15px;
    font-weight:600;
    margin-top:4px;
}
.bbActiveTrackMeta{
    font-size:12px;
    color:var(--text-tertiary);
    margin-top:2px;
}

/* DATA MANAGEMENT MODAL */
.bbStorageOverview{
    background:var(--bg);
    border-radius:12px;
    padding:16px;
    margin-bottom:20px;
}
.bbStorageTotal{
    text-align:center;
    padding-bottom:12px;
    border-bottom:1px solid var(--divider);
    margin-bottom:12px;
}
.bbStorageLabel{
    font-size:11px;
    color:var(--text-tertiary);
    text-transform:uppercase;
    letter-spacing:0.05em;
}
.bbStorageValue{
    font-size:28px;
    font-weight:700;
    margin-top:4px;
}
.bbStorageBreakdown{
    display:flex;
    justify-content:space-around;
}
.bbStorageItem{
    text-align:center;
}
.bbStorageItemLabel{
    font-size:11px;
    color:var(--text-tertiary);
    display:block;
}
.bbStorageItemValue{
    font-size:14px;
    font-weight:600;
    margin-top:2px;
}
.bbSectionCount{
    font-weight:400;
    color:var(--text-tertiary);
    font-size:11px;
}
.bbSessionList{
    border-radius:12px;
    overflow:hidden;
    background:var(--bg);
    max-height:calc(100vh - 350px);
    overflow-y:auto;
}
.bbSessionEmpty{
    padding:30px 20px;
    text-align:center;
    color:var(--text-tertiary);
    font-size:13px;
}
.bbSessionEmpty .icon{
    font-size:32px;
    margin-bottom:10px;
    opacity:0.4;
}
.bbSessionItem{
    padding:14px 16px;
    border-bottom:1px solid var(--divider);
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
}
.bbSessionItem:last-child{border-bottom:none}
.bbSessionItem.active{
    background:rgba(52,199,89,0.08);
}
.bbSessionInfo{flex:1;min-width:0}
.bbSessionDate{
    font-size:14px;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
}
.bbSessionMeta{
    font-size:11px;
    color:var(--text-tertiary);
    margin-top:3px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
}
.bbSessionStatus{
    font-size:10px;
    font-weight:600;
    text-transform:uppercase;
    letter-spacing:0.05em;
    margin-top:4px;
}
.bbSessionStatus.complete{color:var(--ok)}
.bbSessionStatus.active{color:var(--amber)}
.bbSessionStatus.recovered{color:var(--amber)}
.bbSessionActions{
    display:flex;
    gap:8px;
    flex-shrink:0;
}
.bbSessionBtn{
    background:var(--surface);
    border:none;
    border-radius:6px;
    padding:8px 14px;
    font-size:12px;
    font-weight:600;
    color:var(--text);
    cursor:pointer;
    font-family:inherit;
    transition:opacity 0.15s, background 0.15s;
}
.bbSessionBtn:active{opacity:0.7}
.bbSessionBtn:disabled{
    opacity:0.4;
    cursor:not-allowed;
}
.bbSessionBtn.danger{color:var(--red)}
.bbSessionBtn.exporting,.bbSessionBtn.deleting{
    pointer-events:none;
    opacity:0.6;
}
.bbClearAllBtn{
    display:block;
    width:100%;
    padding:14px 18px;
    margin-top:16px;
    border:none;
    border-radius:12px;
    font-size:14px;
    font-weight:600;
    cursor:pointer;
    font-family:inherit;
    background:var(--bg);
    color:var(--red);
    transition:opacity 0.15s;
}
.bbClearAllBtn:active{opacity:0.7}
.bbClearAllBtn:disabled{
    opacity:0.4;
    cursor:not-allowed;
}
.bbTrackDataList{
    border-radius:12px;
    overflow:hidden;
    background:var(--bg);
    max-height:250px;
    overflow-y:auto;
}
.bbTrackDataItem{
    padding:14px 16px;
    border-bottom:1px solid var(--divider);
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
}
.bbTrackDataItem:last-child{border-bottom:none}
.bbTrackDataInfo{flex:1;min-width:0}
.bbTrackDataName{
    font-size:14px;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
}
.bbTrackDataMeta{
    font-size:11px;
    color:var(--text-tertiary);
    margin-top:3px;
    display:flex;
    gap:8px;
}
.bbTrackDataRef{
    margin-top:6px;
    font-size:12px;
}
.bbTrackDataRef.has-ref{
    color:var(--ok);
    font-weight:500;
}
.bbTrackDataRef.no-ref{
    color:var(--text-tertiary);
    font-style:italic;
}
.bbTrackDataActions{
    display:flex;
    gap:8px;
    flex-shrink:0;
}

/* TOAST NOTIFICATIONS */
.bbToast{
    position:fixed;
    bottom:80px;
    left:50%;
    transform:translateX(-50%);
    background:var(--surface);
    border-radius:12px;
    padding:12px 16px;
    box-shadow:0 4px 20px rgba(0,0,0,.25);
    display:flex;
    align-items:center;
    gap:12px;
    z-index:10001;
    animation:bbToastSlideIn 0.3s ease-out;
    max-width:calc(100vw - 32px);
}
@keyframes bbToastSlideIn{
    from{opacity:0;transform:translateX(-50%) translateY(20px)}
    to{opacity:1;transform:translateX(-50%) translateY(0)}
}
.bbToast.dismissing{
    animation:bbToastSlideOut 0.2s ease-in forwards;
}
@keyframes bbToastSlideOut{
    from{opacity:1;transform:translateX(-50%) translateY(0)}
    to{opacity:0;transform:translateX(-50%) translateY(20px)}
}
.bbToastIcon{
    font-size:24px;
    flex-shrink:0;
}
.bbToastText{
    flex:1;
    min-width:0;
}
.bbToastText strong{
    display:block;
    font-size:14px;
    font-weight:600;
    margin-bottom:2px;
}
.bbToastText span{
    font-size:12px;
    color:var(--text-secondary);
    display:block;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
}
.bbToastActions{
    display:flex;
    gap:8px;
    flex-shrink:0;
}
.bbToastBtn{
    padding:8px 14px;
    border-radius:8px;
    border:none;
    font-size:13px;
    font-weight:600;
    cursor:pointer;
    font-family:inherit;
}
.bbToastBtn.primary{
    background:var(--ok);
    color:#fff;
}
.bbToastBtn.secondary{
    background:var(--divider);
    color:var(--text);
}
</style></head>
<body>

<header class="bbTopbar">
    <button class="bbBrandToggle" id="brandToggle" aria-label="Toggle theme">
        <span class="bbBrand">Blackbox</span>
        <span class="bbModeLabel" id="modeLabel">Bright</span>
        <span class="bbModeIcon" aria-hidden="true">‚óê</span>
    </button>
    <div class="bbTopRight">
        <div class="bbStatusCluster">
            <span class="bbStatusItem" id="sourceLabel"><span class="bbHigh">SIM</span></span>
            <span class="bbStatusItem"><span class="bbDot"></span>GPS</span>
            <span class="bbStatusItem"><span class="bbDot"></span>IMU</span>
        </div>
        <button class="bbKebab" id="menu-btn" aria-label="Menu">‚ãÆ</button>
    </div>
</header>

<main class="bbApp">
    <!-- Lap Timer Section -->
    <section class="bbCard bbLapCard inactive" id="lap-section">
        <div class="bbLapSetup" id="lap-setup">
            <span class="bbLapSetupText" id="lap-setup-text">Tap to configure</span>
            <button class="bbLapSetupBtn" id="btn-open-tracks">Tracks</button>
        </div>
        <div class="bbLapActive" id="lap-active" onclick="openTrackModal()">
            <button class="bbLapStop" id="btn-lap-stop" onclick="event.stopPropagation(); confirmStopTiming();" title="Stop timing">√ó</button>
            <div class="bbLapMain">
                <div class="bbLapTime bbNum" id="lap-time">0:00.000</div>
                <!-- Racing-game inspired delta bar (text above, bar below) -->
                <div class="bbDeltaBar no-ref" id="delta-bar">
                    <div class="bbDeltaText" id="delta-text">Set best lap</div>
                    <div class="bbDeltaTrack">
                        <div class="bbDeltaCenter"></div>
                        <div class="bbDeltaFill" id="delta-fill"></div>
                    </div>
                </div>
                <div class="bbLapTrackName" id="lap-track-name"></div>
                <div class="bbLapMeta">
                    <span class="bbLapCount" id="lap-count">Lap 1</span>
                    <span class="bbLapState" id="lap-state">Armed</span>
                </div>
            </div>
            <div class="bbLapHistory">
                <div class="bbLapHistItem">
                    <span class="bbLapHistLabel">Best</span>
                    <span class="bbLapHistValue bbNum" id="best-lap">‚Äî:‚Äî‚Äî</span>
                </div>
                <div class="bbLapHistDivider"></div>
                <div class="bbLapHistItem">
                    <span class="bbLapHistLabel">Last</span>
                    <span class="bbLapHistValue bbNum" id="last-lap">‚Äî:‚Äî‚Äî</span>
                </div>
                <div class="bbLapHistDivider"></div>
                <div class="bbLapHistItem">
                    <span class="bbLapHistLabel">Delta</span>
                    <span class="bbLapHistValue bbNum delta" id="lap-delta">‚Äî</span>
                </div>
            </div>
            <div class="bbStartLineIndicator" id="start-line-indicator">
                <span class="bbStartLineText" id="start-line-text">Calculating...</span>
            </div>
            <div class="bbFinishLineIndicator" id="finish-line-indicator">
                <span class="bbFinishLineText" id="finish-line-text">Finish ahead...</span>
            </div>
        </div>
    </section>

    <section class="bbCard bbGCard">
        <div class="bbGTop">
            <div class="bbGTopLeft">
                <div class="bbSpeedLine"><span class="bbSpeed bbNum" id="speed">0</span><span class="bbUnit">km/h</span></div>
                <div class="bbManeuver" id="maneuver">IDLE</div>
            </div>
            <div class="bbGTopRight"><span class="bbNum" id="session-time">0:00</span></div>
        </div>

        <div class="bbGPlotWrap">
            <div class="bbGPlotFrame">
                <div class="bbAxis bbAxis--top">Accel</div>
                <div class="bbAxis bbAxis--bottom">Brake</div>
                <div class="bbAxis bbAxis--left">Left</div>
                <div class="bbAxis bbAxis--right">Right</div>
                <div class="bbPlotMeta" id="range-val">Range ¬±0.5g</div>
                <canvas class="bbGPlot" id="gcanvas"></canvas>
            </div>
        </div>

        <div class="bbGReadoutRow">
            <div class="bbGReadoutCol">
                <div class="bbGReadoutLbl">Lat</div>
                <div class="bbGReadoutVal bbNum" id="lat-g"><span class="bbSign">+</span><span class="bbVal">0.00</span><span class="bbGUnit">g</span></div>
            </div>
            <div class="bbGDivider"></div>
            <div class="bbGReadoutCol">
                <div class="bbGReadoutLbl">Long</div>
                <div class="bbGReadoutVal bbNum" id="lon-g"><span class="bbSign">+</span><span class="bbVal">0.00</span><span class="bbGUnit">g</span></div>
            </div>
        </div>

        <div class="bbGMax">
            <div class="bbMini"><span class="bbMiniLbl">Max Lat L</span><span class="bbMiniVal bbNum" id="max-l">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Lat R</span><span class="bbMiniVal bbNum" id="max-r">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Acc</span><span class="bbMiniVal bbNum" id="max-a">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Brk</span><span class="bbMiniVal bbNum" id="max-b">0.00g</span></div>
        </div>

        <!-- CSV Progress Bar -->
        <div class="bbCsvRow" id="csv-row">
            <span class="bbCsvName" id="csv-name"></span>
            <div class="bbCsvProgress" id="csv-progress">
                <div class="bbCsvBar" id="csv-bar"></div>
            </div>
            <span class="bbCsvTime" id="csv-time">0:00 / 0:00</span>
        </div>
    </section>

    <div class="bbTelemetryStrip">
        <span class="bbTItem"><span class="bbNum bbNum--hz" id="hz">30</span> Hz</span>
        <span class="bbTItem">GPS <span class="bbNum bbNum--gps" id="gps-acc">2</span>m</span>
        <span class="bbTItem">Drops <span class="bbNum bbNum--drops" id="drops">0</span></span>
        <span class="bbTItem">Yaw <span class="bbNum bbNum--yaw" id="yaw">0</span>¬∞</span>
    </div>
</main>

<div class="bbMenuOverlay" id="menu-overlay">
    <div class="bbMenuPanel">
        <button class="bbMenuItem" id="menu-data">Data</button>
        <button class="bbMenuItem" id="menu-load">Load CSV</button>
        <button class="bbMenuItem" id="menu-sim">Back to Sim</button>
        <button class="bbMenuItem" id="menu-rec">Start Recording</button>
        <button class="bbMenuItem" id="menu-export">Export CSV</button>
        <button class="bbMenuItem destructive" id="menu-clear">Clear Session</button>
    </div>
</div>

<!-- Track Manager Modal - Unified UX -->
<div class="bbModal" id="track-modal">
    <div class="bbModalContent">
        <div class="bbModalHeader">
            <span class="bbModalTitle">Tracks</span>
            <button class="bbModalClose" id="track-modal-close">&times;</button>
        </div>
        <div class="bbModalBody">
            <!-- Active Track (if any) -->
            <div id="active-track-section" class="bbActiveTrack" style="display:none">
                <div class="bbActiveTrackInfo">
                    <div class="bbActiveTrackName" id="active-track-name">‚Äî</div>
                    <div class="bbActiveTrackMeta" id="active-track-meta">‚Äî</div>
                </div>
                <button class="bbActiveTrackClear" id="btn-clear-track" title="Clear active track">√ó</button>
            </div>

            <!-- Create New Track - Unified Recording -->
            <div class="bbModalSection" id="create-track-section">
                <div class="bbSectionTitle">Record New Track</div>
                <p class="bbCreateTrackHint">
                    Drive to start position, then tap to begin
                </p>
                <div class="bbCreateTrackBtns">
                    <button class="bbRecordStartBtn" id="btn-record-loop" onclick="startTrackRecording('loop')">
                        <div class="bbRecordStartIconWrap">
                            <svg class="bbRecordStartIcon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="9"/>
                                <polyline points="16,12 12,8 8,12"/>
                                <line x1="12" y1="8" x2="12" y2="16"/>
                            </svg>
                        </div>
                        <span class="bbRecordStartLabel">Circuit</span>
                        <span class="bbRecordStartDesc">Auto-detects return to start</span>
                    </button>
                    <button class="bbRecordStartBtn" id="btn-record-p2p" onclick="startTrackRecording('point_to_point')">
                        <div class="bbRecordStartIconWrap">
                            <svg class="bbRecordStartIcon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="5" cy="12" r="3"/>
                                <circle cx="19" cy="12" r="3"/>
                                <line x1="8" y1="12" x2="16" y2="12"/>
                                <polyline points="13,9 16,12 13,15"/>
                            </svg>
                        </div>
                        <span class="bbRecordStartLabel">Stage</span>
                        <span class="bbRecordStartDesc">Mark finish when you're done</span>
                    </button>
                </div>
            </div>

            <!-- Demo Tracks -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Demo Tracks</div>
                <div class="bbTrackList" id="demo-track-list"></div>
            </div>

            <!-- Saved Tracks -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Saved Tracks</div>
                <div class="bbTrackList" id="track-list">
                    <div class="bbTrackEmpty">No saved tracks yet</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Data Management Modal -->
<div class="bbModal" id="data-modal">
    <div class="bbModalContent">
        <div class="bbModalHeader">
            <span class="bbModalTitle">Data</span>
            <button class="bbModalClose" id="data-modal-close">&times;</button>
        </div>
        <div class="bbModalBody">
            <!-- Storage Overview -->
            <div class="bbStorageOverview">
                <div class="bbStorageTotal">
                    <div class="bbStorageLabel">Total Storage</div>
                    <div class="bbStorageValue" id="data-total-size">‚Äî</div>
                </div>
                <div class="bbStorageBreakdown">
                    <div class="bbStorageItem">
                        <span class="bbStorageItemLabel">Recordings</span>
                        <span class="bbStorageItemValue" id="data-rec-size">‚Äî</span>
                    </div>
                    <div class="bbStorageItem">
                        <span class="bbStorageItemLabel">Tracks</span>
                        <span class="bbStorageItemValue" id="data-track-size">‚Äî</span>
                    </div>
                </div>
            </div>

            <!-- Recordings Section -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Recordings <span class="bbSectionCount" id="data-rec-count"></span></div>
                <div class="bbSessionList" id="session-list">
                    <div class="bbSessionEmpty">
                        <div class="icon">üìä</div>
                        Loading...
                    </div>
                </div>
                <button class="bbClearAllBtn" id="btn-clear-all-recordings">Clear All Recordings</button>
            </div>

            <!-- Tracks & Reference Laps Section -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Tracks & Best Laps <span class="bbSectionCount" id="data-track-count"></span></div>
                <div class="bbTrackDataList" id="track-data-list">
                    <div class="bbSessionEmpty">
                        <div class="icon">üèÅ</div>
                        Loading...
                    </div>
                </div>
                <button class="bbClearAllBtn" id="btn-clear-all-tracks">Clear All Tracks</button>
            </div>
        </div>
    </div>
</div>

<!-- Track Recording Overlay - Redesigned -->
<div class="bbRecordOverlay" id="record-overlay">
    <!-- Recording State -->
    <div class="bbRecordState" id="rec-state-recording">
        <div class="bbRecordHeader">
            <div class="bbRecordPulse"></div>
            <span class="bbRecordTitle" id="rec-title">Recording Loop</span>
        </div>

        <div class="bbRecordHero">
            <div class="bbRecordHeroValue" id="rec-distance">0</div>
            <div class="bbRecordHeroUnit">meters</div>
        </div>

        <div class="bbRecordMeta">
            <div class="bbRecordMetaItem">
                <span class="bbRecordMetaValue" id="rec-corners">0</span>
                <span class="bbRecordMetaLabel">corners</span>
            </div>
            <div class="bbRecordMetaDivider"></div>
            <div class="bbRecordMetaItem">
                <span class="bbRecordMetaValue" id="rec-points">0</span>
                <span class="bbRecordMetaLabel">points</span>
            </div>
            <div class="bbRecordMetaDivider"></div>
            <div class="bbRecordMetaItem">
                <span class="bbRecordMetaValue" id="rec-elapsed">0:00</span>
                <span class="bbRecordMetaLabel">elapsed</span>
            </div>
        </div>

        <div class="bbRecordQuality">
            <div class="bbRecordQualityBar">
                <div class="bbRecordQualityFill good" id="rec-quality-fill" style="width:80%"></div>
            </div>
            <span class="bbRecordQualityText" id="rec-quality-text">GPS Good</span>
        </div>

        <p class="bbRecordHint" id="rec-hint">Drive around the track. Loop auto-detects on return.</p>

        <div class="bbRecordActions" id="rec-actions-normal">
            <button class="bbRecordActionBtn secondary" onclick="cancelTrackRecording()">Cancel</button>
            <button class="bbRecordActionBtn finish" id="btn-mark-finish" style="display:none" onclick="markRecordingFinish()">Mark Finish</button>
        </div>
    </div>

    <!-- Track Complete State -->
    <div class="bbRecordState" id="rec-state-complete" style="display:none">
        <div class="bbRecordSuccess">
            <div class="bbRecordSuccessIcon">‚úì</div>
            <div class="bbRecordSuccessTitle" id="rec-success-title">Track Complete!</div>
            <div class="bbRecordSuccessStats" id="rec-success-stats">283m ¬∑ 12 corners ¬∑ Good quality</div>
        </div>

        <div class="bbRecordActions">
            <button class="bbRecordActionBtn secondary" onclick="continueTrackRecording()">Keep Driving</button>
            <button class="bbRecordActionBtn primary" onclick="finishTrackRecording()">Save Track</button>
        </div>
    </div>
</div>

<input type="file" id="csv-input" accept=".csv" style="display:none">

<script>
const CANYON_KEYFRAMES = [
    [0,      55,    0.15,  0.05,  3],
    [1300,   70,    0.30,  0.02,  1],
    [2300,   75,    0.10,  0.05,  5],
    [3000,   68,   -0.35,  0.10,  8],
    [3700,   55,   -0.20,  0.35,  25],
    [4700,   52,    0.05,  0.45,  32],
    [5700,   58,    0.25,  0.30,  20],
    [6700,   70,    0.30,  0.10,  6],
    [7700,   78,    0.15,  0.02,  0],
    [8700,   72,   -0.40,  -0.05, -3],
    [9700,   55,   -0.25,  -0.40, -30],
    [11000,  45,    0.05,  -0.55, -40],
    [12300,  50,    0.30,  -0.40, -28],
    [13300,  62,    0.25,  -0.15, -10],
    [14300,  65,    0.10,  0.25,  18],
    [15000,  60,    0.05,  -0.20, -15],
    [15700,  62,    0.15,  0.20,  14],
    [16700,  72,    0.30,  0.05,  2],
    [17700,  78,   -0.25,  -0.10, -8],
    [18700,  65,    0.05,  -0.42, -32],
    [20000,  55,    0.15,  0.05,  3],
];
const LOOP_DURATION = 20000;
const P2P_DURATION = 25000;  // 25 seconds for P2P runs (longer to see messages)

// ============================================================================
// P2P TEST TRACK - A longer oval for point-to-point testing
// Start at (0,0), finish at (200,0) on opposite side
// Total run takes 20 seconds, with approach messages visible
// ============================================================================
const P2P_TRACK = (() => {
    const waypoints = [];
    let d = 0;
    const r = 15;  // Larger corners
    const cornerSteps = 10;
    const arcLength = (Math.PI * r / 2);

    function addCorner(cx, cy, startAngle, endAngle) {
        for (let i = 1; i <= cornerSteps; i++) {
            const t = i / cornerSteps;
            const angle = startAngle + t * (endAngle - startAngle);
            const x = cx + r * Math.cos(angle);
            const y = cy + r * Math.sin(angle);
            const heading = angle - Math.PI / 2;
            d += arcLength / cornerSteps;
            waypoints.push([d, x, y, heading]);
        }
    }

    // Start at (0,0) heading north ‚Üí up to (0,80)
    for (let i = 0; i <= 16; i++) {
        waypoints.push([d, 0, i * 5, Math.PI / 2]);
        if (i < 16) d += 5;
    }
    // Corner 1: turn right at (0,80) ‚Üí (15,95)
    addCorner(15, 80, Math.PI, Math.PI / 2);
    // East along top from (15,95) to (185,95) - 170m
    for (let i = 1; i <= 34; i++) {
        d += 5;
        waypoints.push([d, 15 + i * 5, 95, 0]);
    }
    // Corner 2: turn right at (185,95) ‚Üí (200,80)
    addCorner(185, 80, Math.PI / 2, 0);
    // South from (200,80) to (200,0) - FINISH LINE at y=40
    for (let i = 1; i <= 16; i++) {
        d += 5;
        waypoints.push([d, 200, 80 - i * 5, -Math.PI / 2]);
    }
    // Corner 3: turn right at (200,0) ‚Üí (185,-15)
    addCorner(185, 0, 0, -Math.PI / 2);
    // West along bottom from (185,-15) to (15,-15) - 170m
    for (let i = 1; i <= 34; i++) {
        d += 5;
        waypoints.push([d, 185 - i * 5, -15, Math.PI]);
    }
    // Corner 4: turn right at (15,-15) ‚Üí (0,0)
    addCorner(15, 0, -Math.PI / 2, -Math.PI);
    // Final approach to start
    d += 1;
    waypoints.push([d, 0, 0, Math.PI / 2]);

    return { waypoints, totalLength: d, finishY: 40 };  // finishY marks where finish line should be
})();

// ============================================================================
// DEMO TRACKS - Pre-made tracks matching simulation geometries
// These are always available in Track Manager without needing to create them
// ============================================================================
const DEMO_TRACKS = [
    {
        id: 'demo_loop',
        name: 'Demo Circuit',
        type: 'loop',
        isDemo: true,
        // Start/finish line at (0,0) perpendicular to northbound direction
        // Uses [x, y] array format to match user-created tracks
        startLine: { p1: [-5, 0], p2: [5, 0], direction: Math.PI / 2 }
    },
    {
        id: 'demo_p2p',
        name: 'Demo P2P Stage',
        type: 'point_to_point',
        isDemo: true,
        // Start at (0,0) heading north, finish at (200,40) heading south
        // Uses [x, y] array format to match user-created tracks
        startLine: { p1: [-5, 0], p2: [5, 0], direction: Math.PI / 2 },
        finishLine: { p1: [195, 40], p2: [205, 40], direction: -Math.PI / 2 }
    }
];

// ============================================================================
// SIMULATED TRACK PATH - A rectangular block loop for geometry-based lap timing
// Format: [cumulative_distance_m, x_m, y_m, heading_rad]
// Total length ~283m, completes in 20s at ~14 m/s (51 km/h) average
//
// Track layout (birds-eye view):
//
//        (10,60)-------- 60m --------(70,60)
//           |                           |
//   Corner1 |                           | Corner2
//           |                           |
//        (0,50)                      (80,50)
//           |                           |
//    50m    |                           | 50m
//           |                           |
//        (0,0) START                 (80,0)
//           |                           |
//   Corner4 |                           | Corner3
//           |                           |
//       (10,-10)------- 60m --------(70,-10)
//
// Direction: clockwise (right-hand turns)
// ============================================================================
const BLOCK_TRACK = (() => {
    const waypoints = [];
    let d = 0;  // Cumulative distance
    const r = 10;  // Corner radius
    const cornerSteps = 8;
    const arcLength = (Math.PI * r / 2);  // Quarter circle

    // Helper: add corner waypoints
    // startAngle/endAngle are angles FROM the center TO the position on the arc
    function addCorner(cx, cy, startAngle, endAngle) {
        for (let i = 1; i <= cornerSteps; i++) {
            const t = i / cornerSteps;
            const angle = startAngle + t * (endAngle - startAngle);
            const x = cx + r * Math.cos(angle);
            const y = cy + r * Math.sin(angle);
            // Heading is tangent to circle (perpendicular to radius, in direction of travel)
            // For clockwise travel, heading = angle - PI/2
            const heading = angle - Math.PI / 2;
            d += arcLength / cornerSteps;
            waypoints.push([d, x, y, heading]);
        }
    }

    // === Leg 1: Start at (0,0) heading north, go to (0,50) ===
    for (let i = 0; i <= 10; i++) {
        const y = i * 5;
        waypoints.push([d, 0, y, Math.PI / 2]);
        if (i < 10) d += 5;
    }

    // === Corner 1: Right turn at (0,50) ‚Üí (10,60) ===
    // Center at (10, 50), turn from angle PI (west of center) to PI/2 (north of center)
    addCorner(10, 50, Math.PI, Math.PI / 2);

    // === Leg 2: East from (10,60) to (70,60) ===
    for (let i = 1; i <= 12; i++) {
        const x = 10 + i * 5;
        d += 5;
        waypoints.push([d, x, 60, 0]);  // Heading east
    }

    // === Corner 2: Right turn at (70,60) ‚Üí (80,50) ===
    // Center at (70, 50), turn from angle PI/2 (north of center) to 0 (east of center)
    addCorner(70, 50, Math.PI / 2, 0);

    // === Leg 3: South from (80,50) to (80,0) ===
    for (let i = 1; i <= 10; i++) {
        const y = 50 - i * 5;
        d += 5;
        waypoints.push([d, 80, y, -Math.PI / 2]);  // Heading south
    }

    // === Corner 3: Right turn at (80,0) ‚Üí (70,-10) ===
    // Center at (70, 0), turn from angle 0 (east of center) to -PI/2 (south of center)
    addCorner(70, 0, 0, -Math.PI / 2);

    // === Leg 4: West from (70,-10) to (10,-10) ===
    for (let i = 1; i <= 12; i++) {
        const x = 70 - i * 5;
        d += 5;
        waypoints.push([d, x, -10, Math.PI]);  // Heading west
    }

    // === Corner 4: Right turn at (10,-10) ‚Üí (0,0) ===
    // Center at (10, 0), turn from angle -PI/2 (south of center) to PI (west of center)
    // Note: -PI/2 to PI goes through -PI, so we use -PI/2 to -PI then wrap
    addCorner(10, 0, -Math.PI / 2, -Math.PI);

    // Final point at exactly (0, 0) heading north
    const lastWp = waypoints[waypoints.length - 1];
    const distToStart = Math.sqrt(lastWp[1] * lastWp[1] + lastWp[2] * lastWp[2]);
    if (distToStart > 0.1) {
        d += distToStart;
        waypoints.push([d, 0, 0, Math.PI / 2]);
    }

    return {
        waypoints,
        totalLength: d
    };
})();

// ============================================================================
// GEOMETRY FUNCTIONS (ported from lap_timer.rs)
// ============================================================================

/**
 * Line segment intersection test using parametric form
 * Tests if segment (p1->p2) intersects segment (p3->p4)
 * @returns {number|null} Parameter t along first segment if intersection, null otherwise
 */
function lineSegmentIntersection(p1, p2, p3, p4) {
    const d1x = p2[0] - p1[0];
    const d1y = p2[1] - p1[1];
    const d2x = p4[0] - p3[0];
    const d2y = p4[1] - p3[1];

    // Cross product of direction vectors
    const cross = d1x * d2y - d1y * d2x;

    // Parallel or nearly parallel lines
    if (Math.abs(cross) < 1e-10) {
        return null;
    }

    // Vector from p1 to p3
    const dx = p3[0] - p1[0];
    const dy = p3[1] - p1[1];

    // Solve for t and u
    const t = (dx * d2y - dy * d2x) / cross;
    const u = (dx * d1y - dy * d1x) / cross;

    // Check if intersection is within both segments
    const EPSILON = 1e-6;
    if (t >= -EPSILON && t <= 1 + EPSILON && u >= -EPSILON && u <= 1 + EPSILON) {
        return Math.max(0, Math.min(1, t));
    }
    return null;
}

/**
 * Normalize angle to [-œÄ, œÄ]
 */
function wrapAngle(angle) {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
}

/**
 * Check if velocity direction is within tolerance of expected crossing direction
 * @param {Array} velocity - [vx, vy] in m/s
 * @param {number} expectedDir - Expected direction in radians
 * @param {number} tolerance - Maximum deviation in radians (default ¬±90¬∞)
 * @returns {boolean}
 */
function directionValid(velocity, expectedDir, tolerance = Math.PI / 2) {
    const speedSq = velocity[0] * velocity[0] + velocity[1] * velocity[1];
    if (speedSq < 0.01) return false;  // Too slow to determine direction

    const velDir = Math.atan2(velocity[1], velocity[0]);
    const diff = wrapAngle(velDir - expectedDir);

    return Math.abs(diff) <= tolerance;
}

/**
 * Interpolate position along the track based on elapsed time
 * Uses P2P_TRACK only for demo P2P track, BLOCK_TRACK for all other tracks
 * User-created P2P tracks use BLOCK_TRACK since that's what they were created on
 * @param {number} elapsedMs - Elapsed time since loop start
 * @returns {{x: number, y: number, vx: number, vy: number, heading: number, speed: number}}
 */
function getSimulatedPosition(elapsedMs) {
    // Only use P2P_TRACK for the demo P2P track (id: 'demo_p2p')
    // User-created P2P tracks are positioned based on BLOCK_TRACK
    const isDemoP2P = activeTrack && activeTrack.id === 'demo_p2p';
    const track = isDemoP2P ? P2P_TRACK : BLOCK_TRACK;
    const duration = isDemoP2P ? P2P_DURATION : LOOP_DURATION;

    const loopTime = elapsedMs % duration;
    const progress = loopTime / duration;  // 0 to 1

    // Distance traveled along track
    const totalDist = track.totalLength;
    const targetDist = progress * totalDist;

    // Find the two waypoints we're between
    const wps = track.waypoints;
    let i = 0;
    while (i < wps.length - 1 && wps[i + 1][0] < targetDist) {
        i++;
    }

    if (i >= wps.length - 1) {
        // At end, return last point
        const wp = wps[wps.length - 1];
        return { x: wp[1], y: wp[2], vx: 0, vy: 15, heading: wp[3], speed: 15 };
    }

    // Interpolate between waypoints
    const wp1 = wps[i];
    const wp2 = wps[i + 1];
    const segmentLength = wp2[0] - wp1[0];
    const t = segmentLength > 0 ? (targetDist - wp1[0]) / segmentLength : 0;

    const x = wp1[1] + t * (wp2[1] - wp1[1]);
    const y = wp1[2] + t * (wp2[2] - wp1[2]);

    // Calculate velocity from segment direction
    const dx = wp2[1] - wp1[1];
    const dy = wp2[2] - wp1[2];
    const segLen = Math.sqrt(dx * dx + dy * dy);

    // Speed varies with the canyon keyframes for realism
    const auto = getAutoValues(elapsedMs);
    const speed = auto.speed / 3.6;  // km/h to m/s

    // Velocity direction follows track
    const heading = segLen > 0 ? Math.atan2(dy, dx) : wp1[3];
    const vx = speed * Math.cos(heading);
    const vy = speed * Math.sin(heading);

    return { x, y, vx, vy, heading, speed };
}

// ============================================================================
// TIMING LINE STATE
// ============================================================================
let simTimingLine = null;  // {p1: [x,y], p2: [x,y], direction: radians} - start line
let simFinishLine = null;  // For point-to-point tracks - finish line
let simPrevPos = null;     // Previous position for crossing detection

const $ = id => document.getElementById(id);
const MODES = {0:'IDLE', 1:'ACCEL', 2:'BRAKE', 4:'CORNER', 5:'ACCEL', 6:'BRAKE'};
const MODE_COLORS = {
    0: 'var(--mode-idle)',
    1: 'var(--mode-accel)',
    2: 'var(--mode-brake)',
    4: 'var(--mode-idle)',
    5: 'var(--mode-accel)',
    6: 'var(--mode-brake)'
};

function getModeColorsHex() {
    return {
        0: isDark ? '#636366' : '#8e8e93',
        1: isDark ? '#ffffff' : '#1c1c1e',
        2: '#ff3b30',
        4: isDark ? '#636366' : '#8e8e93',
        5: isDark ? '#ffffff' : '#1c1c1e',
        6: '#ff3b30'
    };
}

let currentModeColor = '#8e8e93';

function catmullRom(p0, p1, p2, p3, t) {
    const t2 = t * t, t3 = t2 * t;
    return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3);
}

function getKeyframeInterp(timeMs) {
    const loopTime = timeMs % LOOP_DURATION;
    let i1 = 0;
    for (let i = 0; i < CANYON_KEYFRAMES.length - 1; i++) {
        if (loopTime >= CANYON_KEYFRAMES[i][0] && loopTime < CANYON_KEYFRAMES[i + 1][0]) { i1 = i; break; }
    }
    const kf0 = CANYON_KEYFRAMES[(i1 - 1 + CANYON_KEYFRAMES.length) % CANYON_KEYFRAMES.length];
    const kf1 = CANYON_KEYFRAMES[i1];
    const kf2 = CANYON_KEYFRAMES[(i1 + 1) % CANYON_KEYFRAMES.length];
    const kf3 = CANYON_KEYFRAMES[(i1 + 2) % CANYON_KEYFRAMES.length];
    const segDur = (kf2[0] - kf1[0] + LOOP_DURATION) % LOOP_DURATION || LOOP_DURATION;
    const t = Math.max(0, Math.min(1, (loopTime - kf1[0]) / segDur));
    return { kf0, kf1, kf2, kf3, t };
}

function getAutoValues(timeMs) {
    const { kf0, kf1, kf2, kf3, t } = getKeyframeInterp(timeMs);
    return {
        speed: catmullRom(kf0[1], kf1[1], kf2[1], kf3[1], t),
        lonG: catmullRom(kf0[2], kf1[2], kf2[2], kf3[2], t),
        latG: catmullRom(kf0[3], kf1[3], kf2[3], kf3[3], t),
        yawDeg: catmullRom(kf0[4], kf1[4], kf2[4], kf3[4], t)
    };
}

function addNoise(val, amount) { return val + (Math.random() - 0.5) * amount * 0.15; }

// === CSV REPLAY ===
let dataSource = 'loop';
let csvData = null;
let csvFileName = '';
let csvPlaybackIndex = 0;
let csvStartTime = 0;
let csvDuration = 0;

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const data = [];
    // Parse header to find column indices
    const header = lines[0].split(',').map(h => h.trim().toLowerCase());
    const posXIdx = header.indexOf('pos_x');
    const posYIdx = header.indexOf('pos_y');
    const hasPosition = posXIdx !== -1 && posYIdx !== -1;

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        if (values.length < 8) continue;
        const row = {
            t: parseFloat(values[0]),
            speed: parseFloat(values[1]),
            latG: parseFloat(values[6]),
            lonG: parseFloat(values[7]),
            yawRad: parseFloat(values[4]),
            mode: parseInt(values[5]) || 0,
            px: hasPosition ? parseFloat(values[posXIdx]) || 0 : 0,
            py: hasPosition ? parseFloat(values[posYIdx]) || 0 : 0,
            hasPosition: hasPosition
        };
        data.push(row);
    }
    if (data.length > 0) {
        const startT = data[0].t;
        data.forEach(d => d.relativeT = d.t - startT);
    }
    return data;
}

function loadCSVData(text, filename) {
    csvData = parseCSV(text);
    if (csvData.length === 0) { alert('No valid data in CSV'); return; }
    csvFileName = filename;
    csvDuration = csvData[csvData.length - 1].relativeT;
    csvPlaybackIndex = 0;
    csvStartTime = Date.now();
    dataSource = 'csv';

    // Check if CSV has position data
    const hasPosition = csvData.length > 0 && csvData[0].hasPosition;
    if (lapTimerActive && !hasPosition) {
        // Deactivate lap timer when loading CSV without position data
        deactivateLapTimer();
        console.log('Lap timer deactivated: CSV has no position data');
    } else if (hasPosition) {
        // Clear previous position for fresh crossing detection
        simPrevPos = null;
        console.log('CSV has position data - lap timing available');
    }

    resetState();
    updateSourceUI();
}

function switchToLoop() {
    dataSource = 'loop';
    loopStartTime = Date.now();
    resetState();
    updateSourceUI();
}

function updateSourceUI() {
    const csvRow = $('csv-row');
    const sourceLabel = $('sourceLabel');
    if (dataSource === 'csv') {
        csvRow.classList.add('visible');
        $('csv-name').textContent = csvFileName.length > 12 ? csvFileName.substring(0, 9) + '...' : csvFileName;
        sourceLabel.innerHTML = '<span class="bbHigh">CSV</span>';
    } else {
        csvRow.classList.remove('visible');
        sourceLabel.innerHTML = '<span class="bbHigh">SIM</span>';
    }
}

function formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function getCSVValues() {
    if (!csvData || csvData.length === 0) return null;
    const elapsed = Date.now() - csvStartTime;
    while (csvPlaybackIndex < csvData.length - 1 && csvData[csvPlaybackIndex + 1].relativeT <= elapsed) {
        csvPlaybackIndex++;
    }
    if (csvPlaybackIndex >= csvData.length - 1 && elapsed > csvDuration) {
        csvPlaybackIndex = 0;
        csvStartTime = Date.now();
    }
    const frame = csvData[csvPlaybackIndex];
    const progress = Math.min(1, elapsed / csvDuration);
    $('csv-bar').style.width = (progress * 100) + '%';
    $('csv-time').textContent = formatDuration(elapsed) + ' / ' + formatDuration(csvDuration);
    return {
        speed: frame.speed,
        lonG: frame.lonG,
        latG: frame.latG,
        yawDeg: frame.yawRad * 180 / Math.PI,
        mode: frame.mode,
        px: frame.px,
        py: frame.py,
        hasPosition: frame.hasPosition
    };
}

function seekCSV(pct) {
    if (!csvData || csvDuration === 0) return;
    const seekTime = pct * csvDuration;
    csvPlaybackIndex = 0;
    for (let i = 0; i < csvData.length; i++) {
        if (csvData[i].relativeT <= seekTime) csvPlaybackIndex = i;
        else break;
    }
    csvStartTime = Date.now() - seekTime;
}

// IndexedDB Recording (matches production)
const DB_NAME = 'blackbox-rec', DB_VERSION = 2, CHUNK_INTERVAL = 60000;
let db = null, sessionId = null, chunkBuffer = [], chunkIndex = 0, lastSaveTime = 0, recSessionStart = 0;

function openDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            const tx = e.target.transaction;
            const oldVersion = e.oldVersion;

            // Version 1: Create base stores
            if (!d.objectStoreNames.contains('chunks')) {
                const chunksStore = d.createObjectStore('chunks', { keyPath: ['sessionId', 'chunkIndex'] });
                chunksStore.createIndex('sessionId', 'sessionId', { unique: false });
            }
            if (!d.objectStoreNames.contains('sessions')) {
                d.createObjectStore('sessions', { keyPath: 'sessionId' });
            }

            // Version 2: Add sessionId index if upgrading from v1
            if (oldVersion >= 1 && oldVersion < 2) {
                const chunksStore = tx.objectStore('chunks');
                if (!chunksStore.indexNames.contains('sessionId')) {
                    chunksStore.createIndex('sessionId', 'sessionId', { unique: false });
                }
            }
        };
    });
}

async function saveChunk() {
    if (!db || chunkBuffer.length === 0) return;
    const data = [...chunkBuffer];
    try {
        const tx = db.transaction('chunks', 'readwrite');
        await new Promise((resolve, reject) => {
            const req = tx.objectStore('chunks').put({ sessionId, chunkIndex, data, timestamp: Date.now() });
            req.onsuccess = resolve; req.onerror = () => reject(req.error);
        });
        chunkIndex++; chunkBuffer = []; lastSaveTime = Date.now();
    } catch (e) { console.error('Chunk save failed:', e); }
}

async function startRecording() {
    if (!db) await openDB();
    sessionId = Date.now(); recSessionStart = sessionId; chunkBuffer = []; chunkIndex = 0; lastSaveTime = Date.now(); rec = true;
    const tx = db.transaction('sessions', 'readwrite');
    tx.objectStore('sessions').put({ sessionId, startTime: sessionId, status: 'active' });
    $('menu-rec').textContent = 'Stop Recording';
}

async function stopRecording() {
    if (chunkBuffer.length > 0) await saveChunk();
    if (db && sessionId) {
        const tx = db.transaction('sessions', 'readwrite');
        tx.objectStore('sessions').put({ sessionId, startTime: recSessionStart, status: 'complete', chunks: chunkIndex });
    }
    rec = false;
    $('menu-rec').textContent = 'Start Recording';
}

async function exportCSV() {
    if (!db) { alert('No data'); return; }
    if (rec && chunkBuffer.length > 0) await saveChunk();
    const tx = db.transaction(['sessions', 'chunks'], 'readonly');
    const sessions = await new Promise(r => { const req = tx.objectStore('sessions').getAll(); req.onsuccess = () => r(req.result); });
    if (!sessions.length) { alert('No recordings found'); return; }
    const latest = sessions.sort((a, b) => b.sessionId - a.sessionId)[0];
    const chunks = await new Promise(r => { const req = tx.objectStore('chunks').getAll(); req.onsuccess = () => r(req.result); });
    const sessionChunks = chunks.filter(c => c.sessionId === latest.sessionId).sort((a, b) => a.chunkIndex - b.chunkIndex);
    if (!sessionChunks.length) { alert('No data in recording'); return; }
    let allData = [];
    sessionChunks.forEach(c => allData = allData.concat(c.data));
    let csv = 'time,speed,ax,ay,wz,mode,lat_g,lon_g,gps_lat,gps_lon,gps_valid,pos_x,pos_y\n';
    allData.forEach(r => { csv += [r.t, r.sp, r.ax, r.ay, r.wz, r.mo, r.latg, r.lng, r.lat || 0, r.lon || 0, r.gpsOk || 0, r.px || 0, r.py || 0].join(',') + '\n'; });
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = 'blackbox_' + new Date(latest.sessionId).toISOString().slice(0, 19).replace(/[T:]/g, '-') + '.csv'; a.click();
}

// ========== DATA MANAGEMENT FUNCTIONS ==========

// Helper: wrap IndexedDB request in Promise
function idbPromise(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

// Get all sessions with computed statistics
async function getAllSessions() {
    if (!db) await openDB();

    const tx = db.transaction(['sessions', 'chunks'], 'readonly');
    const sessions = await idbPromise(tx.objectStore('sessions').getAll());
    const allChunks = await idbPromise(tx.objectStore('chunks').getAll());

    // Build a map of sessionId -> chunk stats
    const chunksBySession = new Map();
    for (const chunk of allChunks) {
        if (!chunksBySession.has(chunk.sessionId)) {
            chunksBySession.set(chunk.sessionId, { count: 0, samples: 0 });
        }
        const stats = chunksBySession.get(chunk.sessionId);
        stats.count++;
        stats.samples += chunk.data?.length || 0;
    }

    // Enrich sessions with computed stats
    const enriched = sessions.map(s => {
        const chunkStats = chunksBySession.get(s.sessionId) || { count: 0, samples: 0 };
        const durationMs = chunkStats.samples * 50; // 20 Hz = 50ms per sample
        return {
            sessionId: s.sessionId,
            startTime: s.startTime || s.sessionId,
            status: s.status,
            chunkCount: chunkStats.count,
            sampleCount: chunkStats.samples,
            durationMs: durationMs,
            estimatedBytes: chunkStats.samples * 50 // ~50 bytes per sample
        };
    });

    // Sort by sessionId descending (newest first)
    enriched.sort((a, b) => b.sessionId - a.sessionId);
    return enriched;
}

// Get aggregate storage statistics
async function getStorageStats() {
    const sessions = await getAllSessions();
    const totalBytes = sessions.reduce((sum, s) => sum + s.estimatedBytes, 0);
    const totalSamples = sessions.reduce((sum, s) => sum + s.sampleCount, 0);

    return {
        sessionCount: sessions.length,
        totalBytes,
        totalSamples,
        sessions
    };
}

// Delete a single session and all its chunks
async function deleteSession(targetSessionId) {
    if (!db) await openDB();

    // Prevent deletion of currently active recording
    if (rec && targetSessionId === sessionId) {
        throw new Error('Cannot delete active recording');
    }

    const tx = db.transaction(['sessions', 'chunks'], 'readwrite');

    // Use sessionId index to find and delete chunks efficiently
    const chunksStore = tx.objectStore('chunks');
    const index = chunksStore.index('sessionId');
    const range = IDBKeyRange.only(targetSessionId);

    // Open cursor on index and delete each matching chunk
    await new Promise((resolve, reject) => {
        const cursorReq = index.openCursor(range);
        cursorReq.onerror = () => reject(cursorReq.error);
        cursorReq.onsuccess = (e) => {
            const cursor = e.target.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            } else {
                resolve();
            }
        };
    });

    // Delete the session record
    await idbPromise(tx.objectStore('sessions').delete(targetSessionId));

    // Wait for transaction to complete
    await new Promise((resolve, reject) => {
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
    });
}

// Export a specific session by ID
async function exportSessionById(targetSessionId) {
    if (!db) await openDB();

    // If exporting active session, flush buffer first
    if (rec && targetSessionId === sessionId && chunkBuffer.length > 0) {
        await saveChunk();
    }

    const tx = db.transaction(['sessions', 'chunks'], 'readonly');
    const session = await idbPromise(tx.objectStore('sessions').get(targetSessionId));

    if (!session) {
        throw new Error('Session not found');
    }

    // Get chunks using sessionId index
    const index = tx.objectStore('chunks').index('sessionId');
    const chunks = await idbPromise(index.getAll(targetSessionId));
    chunks.sort((a, b) => a.chunkIndex - b.chunkIndex);

    if (!chunks.length) {
        throw new Error('No data in recording');
    }

    // Reassemble all data
    let allData = [];
    chunks.forEach(c => allData = allData.concat(c.data || []));

    // Build CSV with all columns
    let csv = 'time,speed,ax,ay,wz,mode,lat_g,lon_g,gps_lat,gps_lon,gps_valid,pos_x,pos_y\n';
    allData.forEach(r => {
        csv += [
            r.t, r.sp, r.ax, r.ay, r.wz, r.mo,
            r.latg, r.lng, r.lat || 0, r.lon || 0,
            r.gpsOk || 0, r.px || 0, r.py || 0
        ].join(',') + '\n';
    });

    // Create and download file
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'blackbox_' + new Date(targetSessionId).toISOString().slice(0, 19).replace(/[T:]/g, '-') + '.csv';
    a.click();

    return { session, sampleCount: allData.length };
}

// Clear all recordings (sessions and chunks)
async function clearAllRecordings() {
    if (rec) {
        throw new Error('Cannot clear while recording is active');
    }
    if (!db) await openDB();

    const tx = db.transaction(['sessions', 'chunks'], 'readwrite');
    await idbPromise(tx.objectStore('sessions').clear());
    await idbPromise(tx.objectStore('chunks').clear());

    // Wait for transaction to complete
    await new Promise((resolve, reject) => {
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
    });
}

// Cleanup orphaned chunks (chunks with no matching session)
async function cleanupOrphanedChunks() {
    if (!db) await openDB();

    const tx = db.transaction(['sessions', 'chunks'], 'readwrite');
    const sessions = await idbPromise(tx.objectStore('sessions').getAll());
    const sessionIds = new Set(sessions.map(s => s.sessionId));

    const chunks = await idbPromise(tx.objectStore('chunks').getAll());
    let orphanCount = 0;

    for (const chunk of chunks) {
        if (!sessionIds.has(chunk.sessionId)) {
            tx.objectStore('chunks').delete([chunk.sessionId, chunk.chunkIndex]);
            orphanCount++;
        }
    }

    await new Promise((resolve, reject) => {
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
    });

    return orphanCount;
}

// Format bytes for display
function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

// Format date for display
function formatSessionDate(timestamp) {
    const d = new Date(timestamp);
    const now = new Date();
    const isToday = d.toDateString() === now.toDateString();
    const isYesterday = d.toDateString() === new Date(now - 86400000).toDateString();

    const time = d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });

    if (isToday) return `Today ${time}`;
    if (isYesterday) return `Yesterday ${time}`;

    return d.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' }) + ' ' + time;
}

// Format duration for session display (hours/minutes/seconds)
function formatSessionDuration(ms) {
    const totalSec = Math.floor(ms / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;

    if (h > 0) return `${h}h ${m}m`;
    if (m > 0) return `${m}m ${s}s`;
    return `${s}s`;
}

// Format lap time (mm:ss.xxx)
function formatLapTimeMs(ms) {
    if (!ms || ms <= 0) return '‚Äî:‚Äî‚Äî';
    const totalSec = ms / 1000;
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    return `${min}:${sec.toFixed(3).padStart(6, '0')}`;
}

// Estimate object size in bytes (rough approximation)
function estimateObjectSize(obj) {
    const str = JSON.stringify(obj);
    return str ? str.length * 2 : 0; // UTF-16 characters = 2 bytes each
}

// ========== TRACK DATABASE (IndexedDB) ==========
const TRACK_DB_NAME = 'blackbox-tracks', TRACK_DB_VERSION = 3;
let trackDb = null;

function openTrackDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(TRACK_DB_NAME, TRACK_DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => { trackDb = req.result; resolve(trackDb); };
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            const oldVersion = e.oldVersion;

            // Version 1: tracks store
            if (!d.objectStoreNames.contains('tracks')) {
                const store = d.createObjectStore('tracks', { keyPath: 'id' });
                store.createIndex('modified', 'modified', { unique: false });
            }

            // Version 2: reference_laps store for predictive delta
            if (oldVersion < 2) {
                if (!d.objectStoreNames.contains('reference_laps')) {
                    const refStore = d.createObjectStore('reference_laps', { keyPath: 'id' });
                    refStore.createIndex('trackId', 'trackId', { unique: true });
                }
            }

            // Version 3: lap_history store for session history
            if (oldVersion < 3) {
                if (!d.objectStoreNames.contains('lap_history')) {
                    const histStore = d.createObjectStore('lap_history', { keyPath: 'id' });
                    histStore.createIndex('trackId', 'trackId', { unique: false });
                    histStore.createIndex('sessionId', 'sessionId', { unique: false });
                    histStore.createIndex('timestamp', 'timestamp', { unique: false });
                }
            }
        };
    });
}

async function saveTrack(track) {
    if (!trackDb) await openTrackDB();
    track.modified = Date.now();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readwrite');
        const req = tx.objectStore('tracks').put(track);
        req.onsuccess = () => resolve(track);
        req.onerror = () => reject(req.error);
    });
}

async function getTrack(id) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readonly');
        const req = tx.objectStore('tracks').get(id);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function getAllTracks() {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readonly');
        const req = tx.objectStore('tracks').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

async function deleteTrack(id) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readwrite');
        const req = tx.objectStore('tracks').delete(id);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
    });
}

// ========== REFERENCE LAP DATABASE ==========
/**
 * Reference lap format:
 * {
 *   id: string,
 *   trackId: string,           // Foreign key to tracks
 *   lapTimeMs: number,         // Total lap time
 *   created: number,           // Timestamp
 *   samples: ArrayBuffer,      // Float32Array: [distance0, time0, distance1, time1, ...]
 *   sampleCount: number,
 *   totalDistance: number      // Final distance for validation
 * }
 */

async function saveReferenceLap(refLap) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('reference_laps', 'readwrite');
        const req = tx.objectStore('reference_laps').put(refLap);
        req.onsuccess = () => resolve(refLap);
        req.onerror = () => reject(req.error);
    });
}

async function getReferenceLap(trackId) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('reference_laps', 'readonly');
        const index = tx.objectStore('reference_laps').index('trackId');
        const req = index.get(trackId);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
    });
}

async function deleteReferenceLap(trackId) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('reference_laps', 'readwrite');
        const index = tx.objectStore('reference_laps').index('trackId');
        const req = index.openCursor(IDBKeyRange.only(trackId));
        req.onsuccess = () => {
            const cursor = req.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            } else {
                resolve();
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// ========== LAP HISTORY DATABASE ==========
/**
 * Lap history format:
 * {
 *   id: string,           // crypto.randomUUID()
 *   trackId: string,      // Foreign key to tracks
 *   timestamp: number,    // When lap completed
 *   lapTimeMs: number,    // The lap time
 *   lapNumber: number,    // 1, 2, 3... within session
 *   sessionId: string,    // Groups laps from same activation
 *   sessionStart: number  // Date.now() at session start (for date grouping)
 * }
 */

// Current session tracking
let currentSessionId = null;
let currentSessionStart = null;

function generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Start a new session (called when track is activated)
function startNewSession() {
    currentSessionId = generateSessionId();
    currentSessionStart = Date.now();
}

// Clear session (called when track is deactivated)
function clearSession() {
    currentSessionId = null;
    currentSessionStart = null;
}

// Generate a UUID (with fallback for browsers without crypto.randomUUID)
function genUUID() {
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

// Record a lap to history
async function recordLapToHistory(trackId, lapTimeMs, lapNumber) {
    if (!trackDb) await openTrackDB();
    if (!currentSessionId) return; // No active session

    const lap = {
        id: genUUID(),
        trackId: trackId,
        timestamp: Date.now(),
        lapTimeMs: lapTimeMs,
        lapNumber: lapNumber,
        sessionId: currentSessionId,
        sessionStart: currentSessionStart
    };

    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('lap_history', 'readwrite');
        const req = tx.objectStore('lap_history').put(lap);
        req.onsuccess = () => resolve(lap);
        req.onerror = () => reject(req.error);
    });
}

// Get all lap history for a track, grouped by session
async function getLapHistoryForTrack(trackId, limit = 200) {
    if (!trackDb) await openTrackDB();

    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('lap_history', 'readonly');
        const index = tx.objectStore('lap_history').index('trackId');
        const req = index.getAll(IDBKeyRange.only(trackId));

        req.onsuccess = () => {
            const laps = req.result || [];

            // Sort by timestamp descending
            laps.sort((a, b) => b.timestamp - a.timestamp);

            // Limit total laps
            const limitedLaps = laps.slice(0, limit);

            // Group by sessionId
            const sessionMap = new Map();
            for (const lap of limitedLaps) {
                if (!sessionMap.has(lap.sessionId)) {
                    sessionMap.set(lap.sessionId, {
                        sessionId: lap.sessionId,
                        sessionStart: lap.sessionStart,
                        laps: [],
                        bestMs: Infinity
                    });
                }
                const session = sessionMap.get(lap.sessionId);
                session.laps.push(lap);
                if (lap.lapTimeMs < session.bestMs) {
                    session.bestMs = lap.lapTimeMs;
                }
            }

            // Convert to array and sort sessions by date descending
            const sessions = Array.from(sessionMap.values());
            sessions.sort((a, b) => b.sessionStart - a.sessionStart);

            // Sort laps within each session by lap number ascending
            for (const session of sessions) {
                session.laps.sort((a, b) => a.lapNumber - b.lapNumber);
            }

            resolve({
                sessions: sessions,
                totalLaps: laps.length
            });
        };
        req.onerror = () => reject(req.error);
    });
}

// Get history stats for a track (summary only, no full lap data)
async function getLapHistoryStats(trackId) {
    if (!trackDb) await openTrackDB();

    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('lap_history', 'readonly');
        const index = tx.objectStore('lap_history').index('trackId');
        const req = index.getAll(IDBKeyRange.only(trackId));

        req.onsuccess = () => {
            const laps = req.result || [];
            if (laps.length === 0) {
                resolve({ totalLaps: 0, sessionCount: 0, lastSessionDate: null });
                return;
            }

            // Count unique sessions
            const sessionIds = new Set(laps.map(l => l.sessionId));

            // Find most recent lap
            const mostRecent = laps.reduce((max, l) => l.timestamp > max.timestamp ? l : max, laps[0]);

            resolve({
                totalLaps: laps.length,
                sessionCount: sessionIds.size,
                lastSessionDate: mostRecent.sessionStart
            });
        };
        req.onerror = () => reject(req.error);
    });
}

// Delete all lap history for a track
async function deleteLapHistoryForTrack(trackId) {
    if (!trackDb) await openTrackDB();

    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('lap_history', 'readwrite');
        const index = tx.objectStore('lap_history').index('trackId');
        const req = index.openCursor(IDBKeyRange.only(trackId));
        req.onsuccess = () => {
            const cursor = req.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            } else {
                resolve();
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Clear all lap history
async function clearAllLapHistory() {
    if (!trackDb) await openTrackDB();

    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('lap_history', 'readwrite');
        const req = tx.objectStore('lap_history').clear();
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
    });
}

// ========== TRACK DATA MANAGEMENT ==========

// Get all tracks with their reference lap info for data management
async function getTrackDataStats() {
    if (!trackDb) await openTrackDB();

    const tx = trackDb.transaction(['tracks', 'reference_laps', 'lap_history'], 'readonly');
    const tracks = await new Promise((res, rej) => {
        const req = tx.objectStore('tracks').getAll();
        req.onsuccess = () => res(req.result || []);
        req.onerror = () => rej(req.error);
    });
    const refLaps = await new Promise((res, rej) => {
        const req = tx.objectStore('reference_laps').getAll();
        req.onsuccess = () => res(req.result || []);
        req.onerror = () => rej(req.error);
    });
    const lapHistory = await new Promise((res, rej) => {
        const req = tx.objectStore('lap_history').getAll();
        req.onsuccess = () => res(req.result || []);
        req.onerror = () => rej(req.error);
    });

    // Map reference laps by trackId
    const refLapByTrack = new Map();
    for (const ref of refLaps) {
        refLapByTrack.set(ref.trackId, ref);
    }

    // Group lap history by trackId
    const historyByTrack = new Map();
    let totalHistoryBytes = 0;
    for (const lap of lapHistory) {
        if (!historyByTrack.has(lap.trackId)) {
            historyByTrack.set(lap.trackId, []);
        }
        historyByTrack.get(lap.trackId).push(lap);
        totalHistoryBytes += estimateObjectSize(lap);
    }

    // Calculate storage for each track
    let totalTrackBytes = 0;
    let totalRefBytes = 0;

    const trackData = tracks.map(track => {
        const trackBytes = estimateObjectSize(track);
        totalTrackBytes += trackBytes;

        const refLap = refLapByTrack.get(track.id);
        let refBytes = 0;
        if (refLap) {
            refBytes = estimateObjectSize(refLap);
            // Account for ArrayBuffer in samples
            if (refLap.samples instanceof ArrayBuffer) {
                refBytes += refLap.samples.byteLength;
            }
            totalRefBytes += refBytes;
        }

        // Get lap history for this track
        const trackHistory = historyByTrack.get(track.id) || [];
        const historyBytes = trackHistory.reduce((sum, lap) => sum + estimateObjectSize(lap), 0);

        // Handle corners: can be a number (new) or array (legacy) or undefined
        const corners = typeof track.corners === 'number' ? track.corners :
                        (Array.isArray(track.corners) ? track.corners.length : 0);
        // Handle points: use keyPoints if number, centerline length as fallback
        const points = typeof track.keyPoints === 'number' ? track.keyPoints :
                       (track.centerline?.length || 0);

        return {
            id: track.id,
            name: track.name,
            type: track.type,
            corners: corners,
            points: points,
            created: track.created,
            modified: track.modified,
            bestLapMs: track.bestLapMs,
            lapCount: track.lapCount || 0,
            trackBytes,
            hasReferenceLap: !!refLap,
            referenceLapTime: refLap ? refLap.lapTimeMs : 0,
            referenceLapSamples: refLap?.samples?.length || (refLap?.sampleCount || 0),
            refBytes,
            historyLapCount: trackHistory.length,
            historyBytes,
            totalBytes: trackBytes + refBytes + historyBytes
        };
    });

    // Sort by most recently modified
    trackData.sort((a, b) => (b.modified || 0) - (a.modified || 0));

    return {
        trackCount: tracks.length,
        totalTrackBytes,
        totalRefBytes,
        totalHistoryBytes,
        totalBytes: totalTrackBytes + totalRefBytes + totalHistoryBytes,
        tracks: trackData
    };
}

// Get combined storage stats for recordings + tracks
async function getCombinedStorageStats() {
    const recStats = await getStorageStats();
    const trackStats = await getTrackDataStats();

    return {
        totalBytes: recStats.totalBytes + trackStats.totalBytes,
        recordingsBytes: recStats.totalBytes,
        tracksBytes: trackStats.totalBytes,
        sessionCount: recStats.sessionCount,
        trackCount: trackStats.tracks.length
    };
}

// Delete a track, its reference lap, and lap history
async function deleteTrackWithRef(trackId) {
    // Delete reference lap if exists
    try {
        await deleteReferenceLap(trackId);
    } catch (e) {
        console.warn('No reference lap to delete for track:', trackId);
    }

    // Delete lap history
    try {
        await deleteLapHistoryForTrack(trackId);
    } catch (e) {
        console.warn('No lap history to delete for track:', trackId);
    }

    // Then delete the track
    await deleteTrack(trackId);

    // Clear active track if it was the deleted one
    if (activeTrack && activeTrack.id === trackId) {
        activeTrack = null;
        referenceLap = null;
        clearSession();
    }
}

// Clear all tracks, reference laps, and lap history
async function clearAllTracks() {
    if (!trackDb) await openTrackDB();

    const tx = trackDb.transaction(['tracks', 'reference_laps', 'lap_history'], 'readwrite');
    await new Promise((res, rej) => {
        const req = tx.objectStore('tracks').clear();
        req.onsuccess = () => res();
        req.onerror = () => rej(req.error);
    });
    await new Promise((res, rej) => {
        const req = tx.objectStore('reference_laps').clear();
        req.onsuccess = () => res();
        req.onerror = () => rej(req.error);
    });
    await new Promise((res, rej) => {
        const req = tx.objectStore('lap_history').clear();
        req.onsuccess = () => res();
        req.onerror = () => rej(req.error);
    });

    // Wait for transaction to complete
    await new Promise((res, rej) => {
        tx.oncomplete = res;
        tx.onerror = () => rej(tx.error);
    });

    // Clear active track state
    activeTrack = null;
    referenceLap = null;
    clearSession();
}

// ========== LAP TRACKER (Distance + Delta) ==========
/**
 * LapTracker - Tracks cumulative distance during a lap and collects samples
 * for potential reference lap storage. Used for predictive delta calculation.
 */
class LapTracker {
    constructor() {
        this.reset();
    }

    reset() {
        this.distance = 0;           // Cumulative distance this lap (meters)
        this.lastPos = null;         // Previous position {x, y}
        this.samples = [];           // [{distance, time}, ...] for potential new reference
        this.startTime = null;
        this.sampleInterval = 100;   // Downsample to ~10 Hz (100ms min between samples)
        this.lastSampleTime = 0;
    }

    /**
     * Update with new position - call every telemetry frame
     * @param {number} x - Position X in meters
     * @param {number} y - Position Y in meters
     * @param {number} lapTimeMs - Current lap time in ms
     * @returns {number} Current cumulative distance
     */
    update(x, y, lapTimeMs) {
        if (this.startTime === null) {
            this.startTime = lapTimeMs;
        }

        // Calculate distance traveled since last update
        if (this.lastPos !== null) {
            const dx = x - this.lastPos.x;
            const dy = y - this.lastPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Sanity check: reject teleports (GPS glitch)
            // Max 50m between samples at 30Hz = 1500 m/s = impossible
            if (dist < 50 && dist > 0.01) {  // Also reject micro-movements
                this.distance += dist;
            }
        }
        this.lastPos = { x, y };

        // Store sample for potential new reference lap (downsampled to ~10 Hz)
        if (lapTimeMs - this.lastSampleTime >= this.sampleInterval) {
            this.samples.push({
                distance: this.distance,
                time: lapTimeMs
            });
            this.lastSampleTime = lapTimeMs;
        }

        return this.distance;
    }

    /**
     * Convert collected samples to binary format for storage
     * @returns {ArrayBuffer} Float32Array buffer with [dist, time] pairs
     */
    toBinaryFormat() {
        const buffer = new ArrayBuffer(this.samples.length * 8);  // 4 bytes each for distance and time
        const view = new Float32Array(buffer);
        for (let i = 0; i < this.samples.length; i++) {
            view[i * 2] = this.samples[i].distance;
            view[i * 2 + 1] = this.samples[i].time;
        }
        return buffer;
    }

    /**
     * Check if we have enough samples for a valid reference lap
     * @returns {boolean}
     */
    isValid() {
        return this.samples.length >= 10 && this.distance > 50;  // At least 10 samples and 50m
    }
}

/**
 * Calculate delta to reference lap using binary search + interpolation
 * @param {number} currentDistance - Current cumulative distance in meters
 * @param {number} currentTime - Current lap time in ms
 * @param {Object} refLap - Reference lap object with samples ArrayBuffer
 * @returns {Object} { deltaMs, valid, gaining }
 */
function calculateDelta(currentDistance, currentTime, refLap) {
    if (!refLap || !refLap.samples) {
        return { deltaMs: 0, valid: false, gaining: false };
    }

    const samples = new Float32Array(refLap.samples);
    const n = samples.length / 2;  // Number of [distance, time] pairs

    if (n < 2) {
        return { deltaMs: 0, valid: false, gaining: false };
    }

    // Check if current distance exceeds reference lap (went off track?)
    const refTotalDistance = samples[(n - 1) * 2];
    if (currentDistance > refTotalDistance * 1.1) {
        return { deltaMs: 0, valid: false, gaining: false };
    }

    // Handle before first sample
    if (currentDistance < samples[0]) {
        return { deltaMs: 0, valid: false, gaining: false };
    }

    // Binary search to find bracketing samples
    let lo = 0, hi = n - 1;
    while (hi - lo > 1) {
        const mid = Math.floor((lo + hi) / 2);
        const refDist = samples[mid * 2];
        if (refDist < currentDistance) {
            lo = mid;
        } else {
            hi = mid;
        }
    }

    // Get bracketing samples
    const d0 = samples[lo * 2], t0 = samples[lo * 2 + 1];
    const d1 = samples[hi * 2], t1 = samples[hi * 2 + 1];

    // Handle edge case where we're exactly at a sample point
    if (d1 === d0) {
        return {
            deltaMs: currentTime - t0,
            valid: true,
            gaining: false
        };
    }

    // Linear interpolation to get reference time at current distance
    const frac = (currentDistance - d0) / (d1 - d0);
    const refTime = t0 + frac * (t1 - t0);

    const deltaMs = currentTime - refTime;  // Positive = behind, negative = ahead

    return {
        deltaMs: deltaMs,
        valid: true,
        gaining: false  // Will be calculated by trend tracking
    };
}

/**
 * Format delta for display
 * @param {number} deltaMs - Delta in milliseconds
 * @returns {string} Formatted delta string
 */
function formatDelta(deltaMs) {
    const sign = deltaMs > 0 ? '+' : '';
    const seconds = deltaMs / 1000;
    if (Math.abs(seconds) < 10) {
        return sign + seconds.toFixed(2);
    } else {
        return sign + seconds.toFixed(1);
    }
}

/**
 * Update delta bar visualization (racing-game inspired)
 *
 * Design philosophy (Gran Turismo, Forza, iRacing):
 * - Bar extends from center: LEFT = ahead (green), RIGHT = behind (red)
 * - Glow effects for dramatic deltas (>1 second)
 * - Smooth transitions for responsive feel
 * - Trend arrows show if gaining/losing
 * - EXAGGERATED for dashboard-dev testing (3x sensitivity)
 *
 * @param {Object} opts - Options
 * @param {number|null} opts.deltaMs - Delta in ms (null = no reference)
 * @param {number} opts.trend - Trend value (positive = losing, negative = gaining)
 * @param {boolean} opts.hasReference - Whether a reference lap exists
 * @param {boolean} opts.isP2P - Whether this is a point-to-point track
 */
function updateDeltaBar(opts) {
    const { deltaMs, trend = 0, hasReference = false, isP2P = false } = opts;

    const barEl = $('delta-bar');
    const fillEl = $('delta-fill');
    const textEl = $('delta-text');

    if (!barEl || !fillEl || !textEl) return;

    // No reference state
    if (!hasReference) {
        barEl.classList.add('no-ref');
        barEl.classList.remove('ahead', 'behind');
        fillEl.className = 'bbDeltaFill';
        fillEl.style.width = '0%';
        fillEl.style.left = '50%';
        // Use appropriate terminology for track type
        textEl.textContent = isP2P ? 'Set best run' : 'Set best lap';
        textEl.className = 'bbDeltaText';
        return;
    }

    // Reset display at lap start (deltaMs = 0)
    if (deltaMs === 0) {
        barEl.classList.remove('no-ref');
        fillEl.className = 'bbDeltaFill';
        fillEl.style.width = '0%';
        fillEl.style.left = '50%';
        textEl.textContent = '¬±0.00';
        textEl.className = 'bbDeltaText';
        return;
    }

    // Active delta display
    barEl.classList.remove('no-ref');

    // === BAR SCALING FOR DASHBOARD-DEV ===
    // Variance system generates deltas up to ~3 seconds on 20-second laps:
    //   - Faster laps (1.05-1.15x): up to -2.6s ahead
    //   - Slower laps (0.87-0.97x): up to +3.0s behind
    // Bar should grow meaningfully throughout lap, not peg at max immediately
    // Scale: 2000ms = 50% fill (full bar), giving nice progression for 0-3s deltas
    const MAX_DELTA_MS = 2000; // Full bar at ¬±2 seconds, caps above that

    // Calculate fill percentage (0-50% range, extends from center)
    const absDelta = Math.abs(deltaMs);
    const fillPercent = Math.min(50, (absDelta / MAX_DELTA_MS) * 50);

    // Determine ahead/behind state
    const isAhead = deltaMs < 0;
    const isBehind = deltaMs > 0;
    const isNeutral = Math.abs(deltaMs) < 30; // Within 30ms = neutral

    // Position the fill bar
    // Ahead (negative delta): bar extends LEFT from center
    // Behind (positive delta): bar extends RIGHT from center
    if (isAhead) {
        fillEl.style.left = (50 - fillPercent) + '%';
        fillEl.style.width = fillPercent + '%';
    } else {
        fillEl.style.left = '50%';
        fillEl.style.width = fillPercent + '%';
    }

    // Build fill class list
    let fillClass = 'bbDeltaFill';
    if (!isNeutral) {
        fillClass += isAhead ? ' ahead' : ' behind';

        // Glow effect for dramatic deltas (>1 second)
        const GLOW_THRESHOLD = 1000;
        if (absDelta > GLOW_THRESHOLD) {
            fillClass += isAhead ? ' glow-ahead' : ' glow-behind';
        }
    }
    fillEl.className = fillClass;

    // Format delta text with trend arrow
    let deltaStr = formatDelta(deltaMs);

    // Trend arrows: show if consistently gaining/losing
    // With larger variance, trend rate is higher, so 3ms threshold is good
    const TREND_THRESHOLD = 3;
    if (trend < -TREND_THRESHOLD) {
        deltaStr += ' ‚ñ≤'; // Gaining (delta getting more negative = faster)
    } else if (trend > TREND_THRESHOLD) {
        deltaStr += ' ‚ñº'; // Losing (delta getting more positive = slower)
    }

    textEl.textContent = deltaStr;

    // Text color
    let textClass = 'bbDeltaText';
    if (!isNeutral) {
        textClass += isAhead ? ' ahead' : ' behind';
    }
    textEl.className = textClass;
}

/**
 * Save a new reference lap (helper function)
 * Deletes any existing reference for this track, then saves the new one
 * @param {string} trackId - Track ID
 * @param {number} lapTimeMs - Lap time in ms
 * @param {LapTracker} tracker - LapTracker instance with samples
 */
async function saveNewReferenceLap(trackId, lapTimeMs, tracker) {
    try {
        // Create new reference lap FIRST (synchronously available for next lap)
        const refLap = {
            id: 'ref_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            trackId: trackId,
            lapTimeMs: lapTimeMs,
            created: Date.now(),
            samples: tracker.toBinaryFormat(),
            sampleCount: tracker.samples.length,
            totalDistance: tracker.distance
        };

        // Set immediately so next lap can use it
        referenceLap = refLap;

        // Enable delta bar for next lap (has-ref class controls visibility)
        const section = $('lap-section');
        if (section) section.classList.add('has-ref');

        // Demo tracks don't persist to IndexedDB - reference exists only for current session
        if (activeTrack && activeTrack.isDemo) {
            return;
        }

        // Delete old reference and save new one asynchronously
        await deleteReferenceLap(trackId);
        await saveReferenceLap(refLap);
    } catch (err) {
        console.error('Failed to save reference lap:', err);
    }
}

// Global state for lap tracking and delta
let lapTracker = new LapTracker();
let referenceLap = null;
let lastDeltaMs = 0;        // For trend calculation
let deltaTrend = 0;         // Smoothed trend: positive = losing time, negative = gaining

// ========== TRACK RECORDER CLASS ==========
/**
 * TrackRecorder - Records a track by capturing position samples during driving.
 *
 * Features:
 * - Adaptive sampling based on distance AND heading change
 * - Quality filtering (rejects poor GPS samples)
 * - Corner detection via curvature analysis
 * - Loop closure detection with heading alignment
 * - Post-processing: smoothing, corner-preserving downsampling
 * - Automatic timing line generation
 */
class TrackRecorder {
    constructor() {
        // Recording state
        this.recording = false;
        this.trackType = 'loop';
        this.startTime = 0;

        // Sample storage
        this.rawSamples = [];      // All samples for post-processing
        this.keyPoints = [];       // Adaptively sampled points

        // Start position for loop detection
        this.startPos = null;
        this.startHeading = null;

        // Statistics
        this.totalDistance = 0;
        this.loopDetected = false;
        this.lastSigma = 3.0;

        // Corner detection state machine
        this.inCorner = false;          // Are we currently in a corner?
        this.cornerCount = 0;           // Number of completed corners
        this.cornerEntryDist = 0;       // Distance when we entered current corner

        // Configuration - tuned for real-world GPS behavior
        this.config = {
            // Quality thresholds
            maxSigma: 5.0,              // Reject samples with uncertainty > 5m

            // Adaptive sampling
            minDistance: 1.5,           // Minimum 1.5m between samples
            maxDistance: 20.0,          // Force sample after 20m even without heading change
            headingThreshold: 0.05,     // ~3¬∞ heading change triggers sample

            // Corner detection (with hysteresis)
            cornerEntryThreshold: 0.025,  // rad/m to ENTER a corner (higher = need sharper turn)
            cornerExitThreshold: 0.012,   // rad/m to EXIT a corner (lower = need straighter)
            minCornerLength: 3,           // Minimum meters to count as a corner (filters noise)

            // Loop detection
            minLoopDistance: 150,       // Minimum track length before checking for loop (meters)
            closeProximity: 25,         // Distance to start to detect closure (meters)
            headingTolerance: 0.5,      // ~30¬∞ heading alignment for loop closure

            // Post-processing
            smoothingWindow: 3,         // Points for moving average
            maxCenterlinePoints: 500,   // Maximum points in final centerline
            timingLineWidth: 12         // Half-width of timing line (total 24m)
        };
    }

    /**
     * Start recording a new track
     * @param {Object} pos - Initial position {x, y, heading, speed, sigma}
     * @param {string} trackType - 'loop' or 'point_to_point'
     */
    start(pos, trackType = 'loop') {
        if (!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number') {
            throw new Error('Invalid position: requires x, y coordinates');
        }

        this.recording = true;
        this.trackType = trackType;
        this.startTime = Date.now();
        this.rawSamples = [];
        this.keyPoints = [];
        this.startPos = { x: pos.x, y: pos.y };
        this.startHeading = pos.heading || 0;
        this.totalDistance = 0;
        this.loopDetected = false;
        this.lastSigma = pos.sigma || 3.0;

        // Reset corner state machine
        this.inCorner = false;
        this.cornerCount = 0;
        this.cornerEntryDist = 0;

        // First sample is always a key point
        const firstSample = {
            x: pos.x,
            y: pos.y,
            heading: pos.heading || 0,
            speed: pos.speed || 0,
            sigma: pos.sigma || 3.0,
            t: 0,
            curvature: 0,
            isCorner: false
        };

        this.rawSamples.push({ ...firstSample });
        this.keyPoints.push(firstSample);

        return { started: true, trackType };
    }

    /**
     * Add a position sample during recording
     * @param {Object} pos - Position {x, y, heading, speed, sigma}
     * @returns {Object} Result with stored flag, loop detection, stats
     */
    addSample(pos) {
        if (!this.recording) {
            return { stored: false, reason: 'not_recording' };
        }

        if (!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number') {
            return { stored: false, reason: 'invalid_position' };
        }

        const t = Date.now() - this.startTime;
        const sigma = pos.sigma || 3.0;
        this.lastSigma = sigma;

        // Always store raw sample for post-processing
        this.rawSamples.push({
            x: pos.x,
            y: pos.y,
            heading: pos.heading || 0,
            speed: pos.speed || 0,
            sigma: sigma,
            t: t
        });

        // Quality gate - don't add poor GPS as key points
        if (sigma > this.config.maxSigma) {
            return {
                stored: false,
                reason: 'poor_gps',
                sigma: sigma,
                stats: this.getStats()
            };
        }

        // Calculate distance and heading change from last key point
        const last = this.keyPoints[this.keyPoints.length - 1];
        const dx = pos.x - last.x;
        const dy = pos.y - last.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const headingChange = Math.abs(this._wrapAngle(pos.heading - last.heading));

        // Update cumulative distance
        this.totalDistance += dist;

        // Adaptive sampling decision
        const speedBasedMinDist = Math.max(
            this.config.minDistance,
            (pos.speed || 0) * 0.08  // 80ms of travel at current speed
        );

        const shouldStore =
            dist >= speedBasedMinDist ||
            headingChange >= this.config.headingThreshold ||
            dist >= this.config.maxDistance;

        if (!shouldStore) {
            return {
                stored: false,
                reason: 'too_close',
                distance: dist,
                headingChange: headingChange,
                stats: this.getStats()
            };
        }

        // Compute local curvature (heading change per meter traveled)
        const curvature = dist > 0.1 ? headingChange / dist : 0;

        // Corner detection state machine with hysteresis
        let isCorner = false;
        if (!this.inCorner) {
            // Not in a corner - check if we're entering one
            if (curvature > this.config.cornerEntryThreshold) {
                this.inCorner = true;
                this.cornerEntryDist = this.totalDistance;
                isCorner = true;
            }
        } else {
            // In a corner - check if we're exiting
            isCorner = true;  // Still in corner
            if (curvature < this.config.cornerExitThreshold) {
                // Exiting corner - count it if it was long enough
                const cornerLength = this.totalDistance - this.cornerEntryDist;
                if (cornerLength >= this.config.minCornerLength) {
                    this.cornerCount++;
                }
                this.inCorner = false;
            }
        }

        // Store as key point
        const keyPoint = {
            x: pos.x,
            y: pos.y,
            heading: pos.heading || 0,
            speed: pos.speed || 0,
            sigma: sigma,
            t: t,
            curvature: curvature,
            isCorner: isCorner
        };

        this.keyPoints.push(keyPoint);

        // Check for loop closure (loop tracks only)
        if (this.trackType === 'loop') {
            const loopResult = this._checkLoopClosure(pos);
            if (loopResult.detected) {
                this.loopDetected = true;
                return {
                    stored: true,
                    loopDetected: true,
                    loopQuality: loopResult.quality,
                    distToStart: loopResult.distToStart,
                    stats: this.getStats()
                };
            }
        }

        return {
            stored: true,
            curvature: curvature,
            isCorner: isCorner,
            stats: this.getStats()
        };
    }

    /**
     * Check if we've closed the loop (returned to start with aligned heading)
     * @private
     */
    _checkLoopClosure(pos) {
        if (this.totalDistance < this.config.minLoopDistance) {
            return { detected: false, reason: 'min_distance_not_met' };
        }

        const distToStart = Math.sqrt(
            (pos.x - this.startPos.x) ** 2 +
            (pos.y - this.startPos.y) ** 2
        );

        if (distToStart >= this.config.closeProximity) {
            return { detected: false, reason: 'too_far_from_start', distToStart };
        }

        // Check heading alignment (should be traveling same direction as at start)
        const headingDiff = Math.abs(this._wrapAngle(pos.heading - this.startHeading));
        const headingAligned = headingDiff < this.config.headingTolerance;

        if (!headingAligned) {
            return { detected: false, reason: 'heading_not_aligned', headingDiff };
        }

        return {
            detected: true,
            distToStart: distToStart,
            headingDiff: headingDiff,
            quality: this._assessQuality()
        };
    }

    /**
     * Assess overall recording quality
     * @private
     */
    _assessQuality() {
        // Guard against empty array
        if (this.keyPoints.length === 0) {
            return {
                rating: 'poor',
                avgUncertainty: 5.0,
                goodSampleRatio: 0,
                corners: 0,
                totalPoints: 0
            };
        }

        const validPoints = this.keyPoints.filter(p => p.sigma < 3.0);
        const totalSigma = this.keyPoints.reduce((s, p) => s + (p.sigma || 3.0), 0);
        const avgSigma = totalSigma / this.keyPoints.length;
        const goodRatio = validPoints.length / this.keyPoints.length;

        let rating = 'good';
        if (isNaN(avgSigma) || avgSigma > 3.5 || goodRatio < 0.7) {
            rating = 'fair';
        }
        if (isNaN(avgSigma) || avgSigma > 4.5 || goodRatio < 0.5) {
            rating = 'poor';
        }

        // Use actual corner count from state machine (include current corner if in one)
        const displayCorners = this.inCorner ? this.cornerCount + 1 : this.cornerCount;

        return {
            rating: rating,
            avgUncertainty: isNaN(avgSigma) ? 3.0 : avgSigma,
            goodSampleRatio: isNaN(goodRatio) ? 0.5 : goodRatio,
            corners: displayCorners,
            totalPoints: this.keyPoints.length
        };
    }

    /**
     * Finish recording and process into final track object
     * @param {string} trackName - Name for the track
     * @param {Object} gpsOrigin - GPS reference point {lat, lon} (optional)
     * @returns {Object} Complete track object ready for storage
     */
    finish(trackName, gpsOrigin = null) {
        if (!this.recording) {
            throw new Error('Not recording');
        }

        this.recording = false;

        if (this.keyPoints.length < 10) {
            throw new Error(`Not enough points recorded (got ${this.keyPoints.length}, need at least 10)`);
        }

        // Post-processing pipeline
        // 1. Smooth the path to reduce GPS jitter
        const smoothed = this._smoothPath(this.keyPoints, this.config.smoothingWindow);

        // 2. Recompute curvatures on smoothed path
        const withCurvature = this._computeCurvatures(smoothed);

        // 3. Corner-preserving downsampling
        const centerline = this._curvaturePreservingDownsample(
            withCurvature,
            this.config.maxCenterlinePoints
        );

        // 4. Calculate timing line(s)
        const startLine = this._calculateTimingLine(centerline, 'start');
        let finishLine = null;
        if (this.trackType === 'point_to_point') {
            finishLine = this._calculateTimingLine(centerline, 'finish');
        }

        // 5. Calculate bounding box
        const bounds = this._calculateBounds(centerline);

        // 6. Calculate total distance
        const totalDistance = this._calculatePathLength(centerline);

        // 7. Assess quality
        const quality = this._assessQuality();

        // Generate unique ID
        const id = 'track_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        return {
            id: id,
            name: trackName,
            type: this.trackType,
            created: Date.now(),
            modified: Date.now(),

            // Timing lines
            startLine: startLine,
            finishLine: finishLine,

            // Track geometry
            centerline: centerline,
            displayPath: centerline.map(p => [p.x, p.y]),
            bounds: bounds,
            totalDistance: totalDistance,

            // Origin for coordinate system matching
            origin: { x: this.startPos.x, y: this.startPos.y },
            gpsOrigin: gpsOrigin,

            // Statistics
            bestLapMs: null,
            lapCount: 0,
            corners: this.cornerCount,
            keyPoints: this.keyPoints.length,

            // Learning state
            learningEnabled: true,
            lastLearnedLap: null,

            // Quality metadata
            quality: quality
        };
    }

    /**
     * Smooth path using weighted moving average
     * @private
     */
    _smoothPath(points, windowSize) {
        if (!points || points.length === 0) return [];
        if (points.length <= windowSize) return points.map(p => ({ ...p }));

        const result = [];
        const halfWindow = Math.floor(windowSize / 2);

        for (let i = 0; i < points.length; i++) {
            const start = Math.max(0, i - halfWindow);
            const end = Math.min(points.length - 1, i + halfWindow);
            const window = points.slice(start, end + 1);

            // Guard against empty window
            if (window.length === 0) {
                result.push({ ...points[i] });
                continue;
            }

            // Weighted average: higher weight for center and low-sigma samples
            let sumX = 0, sumY = 0, sumWeight = 0;

            for (let j = 0; j < window.length; j++) {
                const distFromCenter = Math.abs(j - (i - start));
                const positionWeight = 1.0 / (1 + distFromCenter * 0.5);
                const sigma = window[j].sigma || 3.0;  // Default sigma if missing
                const qualityWeight = 1.0 / (sigma + 0.5);
                const weight = positionWeight * qualityWeight;

                sumX += (window[j].x || 0) * weight;
                sumY += (window[j].y || 0) * weight;
                sumWeight += weight;
            }

            // Guard against zero weight (shouldn't happen but be safe)
            const x = sumWeight > 0 ? sumX / sumWeight : points[i].x;
            const y = sumWeight > 0 ? sumY / sumWeight : points[i].y;

            result.push({
                x: isNaN(x) ? points[i].x : x,
                y: isNaN(y) ? points[i].y : y,
                heading: points[i].heading || 0,
                speed: points[i].speed || 0,
                sigma: points[i].sigma || 3.0,
                t: points[i].t || 0
            });
        }

        return result;
    }

    /**
     * Compute curvature at each point using central differences
     * @private
     */
    _computeCurvatures(points) {
        const result = [];

        for (let i = 0; i < points.length; i++) {
            let curvature = 0;

            if (i > 0 && i < points.length - 1) {
                // Central difference for heading change
                const dHeading = this._wrapAngle(points[i + 1].heading - points[i - 1].heading);
                const dx = points[i + 1].x - points[i - 1].x;
                const dy = points[i + 1].y - points[i - 1].y;
                const ds = Math.sqrt(dx * dx + dy * dy);

                if (ds > 0.5) {
                    curvature = Math.abs(dHeading / ds);
                }
            }

            result.push({
                ...points[i],
                curvature: curvature,
                isCorner: curvature > this.config.cornerCurvature
            });
        }

        return result;
    }

    /**
     * Downsample while preserving high-curvature points (corners)
     * @private
     */
    _curvaturePreservingDownsample(points, maxPoints) {
        if (points.length <= maxPoints) {
            return points.map(p => ({
                x: p.x,
                y: p.y,
                heading: p.heading,
                curvature: p.curvature,
                confidence: 1.0 / (p.sigma + 0.5),
                lapCount: 1
            }));
        }

        // Score each point by curvature importance
        const scored = points.map((p, i) => ({
            point: p,
            index: i,
            score: p.curvature || 0
        }));

        // Always keep first and last
        const kept = new Set([0, points.length - 1]);

        // Keep high-curvature points (corners) - allocate 30% of budget
        const cornerBudget = Math.floor(maxPoints * 0.3);
        const sortedByScore = scored.slice(1, -1).sort((a, b) => b.score - a.score);

        for (let i = 0; i < Math.min(cornerBudget, sortedByScore.length); i++) {
            kept.add(sortedByScore[i].index);
        }

        // Fill remaining with evenly spaced points
        const remaining = maxPoints - kept.size;
        if (remaining > 0) {
            const step = Math.floor(points.length / remaining);
            for (let i = 0; i < points.length && kept.size < maxPoints; i += step) {
                kept.add(i);
            }
        }

        // Return in original order
        return Array.from(kept)
            .sort((a, b) => a - b)
            .map(i => ({
                x: points[i].x,
                y: points[i].y,
                heading: points[i].heading,
                curvature: points[i].curvature,
                confidence: 1.0 / (points[i].sigma + 0.5),
                lapCount: 1
            }));
    }

    /**
     * Calculate timing line perpendicular to track direction
     * @private
     */
    _calculateTimingLine(centerline, which = 'start') {
        // Guard: need at least one point
        if (!centerline || centerline.length === 0) {
            return {
                p1: [0, 12],
                p2: [0, -12],
                direction: 0
            };
        }

        const windowSize = Math.min(10, Math.floor(centerline.length * 0.05));
        const window = which === 'start'
            ? centerline.slice(0, Math.max(windowSize, 1))
            : centerline.slice(-Math.max(windowSize, 1));

        // Guard: empty window
        if (window.length === 0) {
            const p = centerline[0];
            return {
                p1: [p.x || 0, (p.y || 0) + 12],
                p2: [p.x || 0, (p.y || 0) - 12],
                direction: p.heading || 0
            };
        }

        // Weighted average position and heading
        let sumX = 0, sumY = 0, sumWeight = 0;
        let sumSin = 0, sumCos = 0;

        for (const p of window) {
            const weight = p.confidence || 0.5;
            const x = p.x || 0;
            const y = p.y || 0;
            const heading = p.heading || 0;

            sumX += x * weight;
            sumY += y * weight;
            sumSin += Math.sin(heading) * weight;
            sumCos += Math.cos(heading) * weight;
            sumWeight += weight;
        }

        // Guard: zero weight
        if (sumWeight === 0) sumWeight = 1;

        const centerX = sumX / sumWeight;
        const centerY = sumY / sumWeight;
        const direction = Math.atan2(sumSin / sumWeight, sumCos / sumWeight);

        // Guard: NaN values
        const safeCenterX = isNaN(centerX) ? 0 : centerX;
        const safeCenterY = isNaN(centerY) ? 0 : centerY;
        const safeDirection = isNaN(direction) ? 0 : direction;

        // Perpendicular direction for line endpoints
        const perpAngle = safeDirection + Math.PI / 2;
        const halfWidth = this.config.timingLineWidth;

        return {
            p1: [
                safeCenterX + Math.cos(perpAngle) * halfWidth,
                safeCenterY + Math.sin(perpAngle) * halfWidth
            ],
            p2: [
                safeCenterX - Math.cos(perpAngle) * halfWidth,
                safeCenterY - Math.sin(perpAngle) * halfWidth
            ],
            direction: safeDirection
        };
    }

    /**
     * Calculate bounding box with margin
     * @private
     */
    _calculateBounds(centerline, margin = 30) {
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        for (const p of centerline) {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y);
            maxY = Math.max(maxY, p.y);
        }

        return {
            minX: minX - margin,
            maxX: maxX + margin,
            minY: minY - margin,
            maxY: maxY + margin
        };
    }

    /**
     * Calculate total path length
     * @private
     */
    _calculatePathLength(centerline) {
        let total = 0;
        for (let i = 1; i < centerline.length; i++) {
            const dx = centerline[i].x - centerline[i - 1].x;
            const dy = centerline[i].y - centerline[i - 1].y;
            total += Math.sqrt(dx * dx + dy * dy);
        }
        return total;
    }

    /**
     * Cancel recording without saving
     */
    cancel() {
        this.recording = false;
        this.rawSamples = [];
        this.keyPoints = [];
        this.totalDistance = 0;
        this.loopDetected = false;
    }

    /**
     * Get current recording statistics
     */
    getStats() {
        // If currently in a corner, count it as a partial corner for display
        const displayCorners = this.inCorner ? this.cornerCount + 1 : this.cornerCount;

        return {
            recording: this.recording,
            trackType: this.trackType,
            keyPointCount: this.keyPoints.length,
            rawSampleCount: this.rawSamples.length,
            totalDistance: this.totalDistance,
            loopDetected: this.loopDetected,
            elapsedMs: this.recording ? Date.now() - this.startTime : 0,
            gpsQuality: this._gpsQualityRating(this.lastSigma),
            lastSigma: this.lastSigma,
            corners: displayCorners,  // Actual corner count, not corner points
            inCorner: this.inCorner   // For debugging
        };
    }

    /**
     * Get GPS quality rating string
     * @private
     */
    _gpsQualityRating(sigma) {
        if (sigma < 2.0) return 'excellent';
        if (sigma < 3.0) return 'good';
        if (sigma < 4.0) return 'fair';
        if (sigma < 5.0) return 'poor';
        return 'bad';
    }

    /**
     * Wrap angle to [-PI, PI]
     * @private
     */
    _wrapAngle(angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }
}

// Global track recorder instance
let trackRecorder = null;

// ========== TRACK RECORDING CONTROL FUNCTIONS ==========

/**
 * Start recording a new track
 * @param {string} trackType - 'loop' or 'point_to_point'
 */
function startTrackRecording(trackType = 'loop') {
    if (!currentSimPos || currentSimPos.speed === undefined) {
        console.warn('Cannot start recording: no position data');
        return false;
    }

    // Create recorder if needed
    if (!trackRecorder) {
        trackRecorder = new TrackRecorder();
    }

    // Create position object with required fields (TrackRecorder expects 'heading')
    const pos = {
        x: currentSimPos.x,
        y: currentSimPos.y,
        heading: currentSimPos.heading,
        speed: currentSimPos.speed,
        valid: true,
        sigma: 2.5  // Simulate good GPS quality
    };

    // Start recording
    const success = trackRecorder.start(pos, trackType);
    if (!success) {
        console.warn('Failed to start track recording');
        return false;
    }

    // Show overlay
    const overlay = $('record-overlay');
    overlay.classList.add('active');

    // Update title
    $('rec-title').textContent = trackType === 'loop' ? 'Recording Circuit' : 'Recording Stage';

    // Reset stats display
    $('rec-distance').textContent = '0';
    $('rec-corners').textContent = '0';
    $('rec-points').textContent = '0';
    $('rec-elapsed').textContent = '0:00';
    updateRecordingQualityDisplay('good', 80);

    // Set hint based on track type
    if (trackType === 'loop') {
        $('rec-hint').textContent = 'Complete one lap. We\'ll detect when you return.';
    } else {
        $('rec-hint').textContent = 'Drive the stage, then tap Mark Finish at the end.';
    }

    // Show recording state, hide complete state
    $('rec-state-recording').style.display = 'block';
    $('rec-state-complete').style.display = 'none';

    // Show/hide Mark Finish button based on track type
    const markFinishBtn = $('btn-mark-finish');
    if (markFinishBtn) {
        markFinishBtn.style.display = trackType === 'point_to_point' ? 'flex' : 'none';
    }

    // Close track modal if open
    closeTrackModal();

    console.log(`Track recording started: ${trackType}`);
    return true;
}

/**
 * Update track recording with current position (called from simulation loop)
 */
function updateTrackRecording() {
    if (!trackRecorder || !trackRecorder.recording) return;
    if (!currentSimPos) return;

    // Create position object (TrackRecorder expects 'heading' not 'yaw')
    const pos = {
        x: currentSimPos.x,
        y: currentSimPos.y,
        heading: currentSimPos.heading,
        speed: currentSimPos.speed,
        valid: true,
        sigma: 2.5  // Simulate good GPS quality
    };

    // Add sample (returns object with stored, loopDetected, stats, etc.)
    const result = trackRecorder.addSample(pos);

    // Update stats display
    const stats = trackRecorder.getStats();
    const distVal = Math.round(stats.totalDistance);
    $('rec-distance').textContent = isNaN(distVal) ? '0' : distVal;
    $('rec-corners').textContent = stats.corners || 0;
    $('rec-points').textContent = stats.keyPointCount || 0;

    // Update elapsed time
    const elapsed = stats.elapsedMs || 0;
    const mins = Math.floor(elapsed / 60000);
    const secs = Math.floor((elapsed % 60000) / 1000);
    $('rec-elapsed').textContent = mins + ':' + secs.toString().padStart(2, '0');

    // Update quality display
    const qualityPercent = getQualityPercent(stats.gpsQuality);
    updateRecordingQualityDisplay(stats.gpsQuality, qualityPercent);

    // Handle loop detection (only trigger once when first detected)
    if (result && result.loopDetected && $('rec-state-complete').style.display === 'none') {
        onLoopDetected();
    }
}

/**
 * Handle loop/circuit detection event
 */
function onLoopDetected() {
    console.log('Circuit loop detected!');

    // Get stats for success message
    const stats = trackRecorder.getStats();
    const quality = (stats.gpsQuality || 'good').charAt(0).toUpperCase() + (stats.gpsQuality || 'good').slice(1);
    const distance = Math.round(stats.totalDistance) || 0;
    const corners = stats.corners || 0;

    // Set title based on track type
    const isStage = trackRecorder && trackRecorder.trackType === 'point_to_point';
    $('rec-success-title').textContent = isStage ? 'Stage Complete!' : 'Circuit Complete!';

    // Update success stats
    $('rec-success-stats').textContent = `${distance}m ¬∑ ${corners} corners ¬∑ ${quality} quality`;

    // Switch to complete state
    $('rec-state-recording').style.display = 'none';
    $('rec-state-complete').style.display = 'block';
}

/**
 * Finish track recording and save
 */
async function finishTrackRecording() {
    if (!trackRecorder || !trackRecorder.recording) return;

    // Get track name from user
    const defaultName = trackRecorder.trackType === 'loop' ? 'New Circuit' : 'New Stage';
    const trackName = prompt('Enter track name:', defaultName);
    if (!trackName) return;  // User cancelled

    // Get GPS origin if available (for simulation, use fixed value)
    const gpsOrigin = {
        lat: 37.82,
        lon: -122.48
    };

    // Finish recording and get track data
    const trackData = trackRecorder.finish(trackName, gpsOrigin);
    if (!trackData) {
        alert('Failed to create track: not enough data or poor quality');
        return;
    }

    // Hide overlay
    $('record-overlay').classList.remove('active');

    // Save to track manager
    await saveRecordedTrack(trackData);

    console.log('Track saved:', trackData.name, `(${trackData.centerline.length} points)`);
}

/**
 * Save recorded track to IndexedDB and activate it
 */
async function saveRecordedTrack(trackData) {
    // Convert to track manager format
    const track = {
        id: trackData.id,
        name: trackData.name,
        type: trackData.type,
        startLine: trackData.startLine,
        finishLine: trackData.finishLine,
        origin: trackData.origin,
        centerline: trackData.centerline,
        bounds: trackData.bounds,
        pathLength: trackData.totalDistance || 0,
        quality: trackData.quality,
        bestLapMs: null,
        lapCount: 0,
        corners: trackData.corners || 0,
        keyPoints: trackData.centerline?.length || trackData.keyPoints || 0,
        createdAt: trackData.createdAt,
        isNew: true  // For P2P warmup - clears after first run
    };

    // Save to IndexedDB using existing track database infrastructure
    try {
        await saveTrack(track);
    } catch (err) {
        console.error('Failed to save track:', err);
        alert('Failed to save track to database');
        return;
    }

    // Activate the track (sets up timing lines and arms the timer)
    activateTrack(track);

    // Refresh track list if modal is open
    if ($('track-modal').classList.contains('open')) {
        renderTrackList();
        updateActiveTrackDisplay();
    }

    // Show success message
    const pathLen = Math.round(track.pathLength || 0);
    alert(`Track "${track.name}" saved!\n${track.centerline.length} points ¬∑ ${pathLen}m`);
}

/**
 * Cancel track recording without saving
 */
function cancelTrackRecording() {
    if (trackRecorder) {
        trackRecorder.cancel();
    }

    // Hide overlay
    $('record-overlay').classList.remove('active');

    console.log('Track recording cancelled');
}

/**
 * Continue recording after loop detection (for additional laps)
 */
function continueTrackRecording() {
    if (!trackRecorder) return;

    // Reset loop detection state
    trackRecorder.loopDetected = false;

    // Switch back to recording state
    $('rec-state-recording').style.display = 'block';
    $('rec-state-complete').style.display = 'none';

    // Update hint based on track type
    const isStage = trackRecorder.trackType === 'point_to_point';
    $('rec-hint').textContent = isStage
        ? 'Continue driving. Tap Mark Finish when done.'
        : 'Continue driving. We\'ll detect the next loop.';

    console.log('Continuing track recording...');
}

/**
 * Mark finish line for point-to-point tracks
 */
function markRecordingFinish() {
    if (!trackRecorder || !trackRecorder.recording) return;
    if (trackRecorder.trackType !== 'point_to_point') return;

    // Check minimum distance
    const stats = trackRecorder.getStats();
    if (stats.totalDistance < 50) {
        alert('Track is too short. Drive at least 50 meters before marking finish.');
        return;
    }

    // Trigger finish
    finishTrackRecording();
}

/**
 * Update quality display in recording overlay
 */
function updateRecordingQualityDisplay(quality, percent) {
    const fill = $('rec-quality-fill');
    const text = $('rec-quality-text');

    // Guard against NaN
    const safePercent = isNaN(percent) ? 80 : Math.max(0, Math.min(100, percent));
    const safeQuality = quality || 'good';

    fill.style.width = safePercent + '%';

    // Remove all quality classes
    fill.className = 'bbRecordQualityFill';

    // Add appropriate class to fill bar
    if (safeQuality === 'excellent' || safeQuality === 'good') {
        fill.classList.add('good');
    } else if (safeQuality === 'fair') {
        fill.classList.add('fair');
    } else {
        fill.classList.add('poor');
    }

    // Format text: "GPS Good" etc.
    const qualityLabel = safeQuality.charAt(0).toUpperCase() + safeQuality.slice(1);
    text.textContent = 'GPS ' + qualityLabel;
}

/**
 * Get quality percentage for progress bar
 */
function getQualityPercent(quality) {
    switch (quality) {
        case 'excellent': return 100;
        case 'good': return 80;
        case 'fair': return 60;
        case 'poor': return 40;
        case 'bad': return 20;
        default: return 50;
    }
}

/**
 * Open IndexedDB for tracks
 */
// ========== TRACK MANAGER STATE ==========
let activeTrack = null;
let currentSimPos = null;  // Updated by simulation loop

// ========== TRACK AUTO-DETECTION ==========
class TrackAutoDetector {
    constructor() {
        this.lastCheck = 0;
        this.checkInterval = 3000;  // Check every 3 seconds
        this.candidateTrack = null;
        this.matchCount = 0;
        this.requiredMatches = 2;   // Need 2 consecutive matches
        this.activeToast = null;    // Currently displayed toast
    }

    async check(x, y, heading) {
        const now = Date.now();
        if (now - this.lastCheck < this.checkInterval) return null;
        this.lastCheck = now;

        // Don't auto-detect if already have active track
        if (activeTrack) {
            this.reset();
            return null;
        }

        // Don't auto-detect if a toast is already showing
        if (this.activeToast) return null;

        const tracks = await getAllTracks();
        let bestMatch = null;
        let bestScore = 0;

        for (const track of tracks) {
            // Skip demo tracks
            if (track.isDemo) continue;

            const score = this.scoreMatch(x, y, heading, track);
            if (score > bestScore && score > 0.5) {
                bestScore = score;
                bestMatch = track;
            }
        }

        if (bestMatch) {
            if (this.candidateTrack?.id === bestMatch.id) {
                this.matchCount++;
            } else {
                this.candidateTrack = bestMatch;
                this.matchCount = 1;
            }

            if (this.matchCount >= this.requiredMatches) {
                return { track: bestMatch, confidence: bestScore };
            }
        } else {
            this.reset();
        }

        return null;
    }

    scoreMatch(x, y, heading, track) {
        // Quick bounds check with margin
        if (track.bounds) {
            const margin = 100;
            if (x < track.bounds.minX - margin || x > track.bounds.maxX + margin ||
                y < track.bounds.minY - margin || y > track.bounds.maxY + margin) {
                return 0;
            }
        }

        // Find nearest centerline point
        const centerline = track.centerline || [];
        if (centerline.length === 0) return 0;

        let minDist = Infinity;
        let nearestPoint = null;
        for (const p of centerline) {
            const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
            if (dist < minDist) {
                minDist = dist;
                nearestPoint = p;
            }
        }

        if (!nearestPoint || minDist > 50) return 0;

        // Score based on distance and heading alignment
        const distScore = Math.max(0, 1 - minDist / 50);

        // Heading comparison (handle wrap-around)
        const headingDiff = Math.abs(wrapAngle(heading - (nearestPoint.heading || 0)));
        const headingScore = Math.max(0, 1 - headingDiff / Math.PI);

        return distScore * 0.6 + headingScore * 0.4;
    }

    reset() {
        this.candidateTrack = null;
        this.matchCount = 0;
    }

    setActiveToast(toast) {
        this.activeToast = toast;
    }

    clearActiveToast() {
        this.activeToast = null;
    }
}

const trackAutoDetector = new TrackAutoDetector();

// Toast helper functions
function showTrackDetectedToast(track) {
    // Remove any existing toast
    dismissActiveToast();

    const toast = document.createElement('div');
    toast.className = 'bbToast';
    toast.innerHTML = `
        <div class="bbToastIcon">üìç</div>
        <div class="bbToastText">
            <strong>Track detected</strong>
            <span>${escapeHtml(track.name)}</span>
        </div>
        <div class="bbToastActions">
            <button class="bbToastBtn primary" onclick="activateDetectedTrack()">Activate</button>
            <button class="bbToastBtn secondary" onclick="dismissActiveToast()">Dismiss</button>
        </div>
    `;
    document.body.appendChild(toast);
    trackAutoDetector.setActiveToast(toast);

    // Store the detected track for activation
    toast._detectedTrack = track;

    // Auto-dismiss after 10 seconds
    toast._dismissTimeout = setTimeout(() => {
        dismissActiveToast();
    }, 10000);
}

function dismissActiveToast() {
    const toast = trackAutoDetector.activeToast;
    if (!toast) return;

    // Clear the timeout
    if (toast._dismissTimeout) {
        clearTimeout(toast._dismissTimeout);
    }

    // Animate out
    toast.classList.add('dismissing');
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 200);

    trackAutoDetector.clearActiveToast();
    trackAutoDetector.reset();
}

async function activateDetectedTrack() {
    const toast = trackAutoDetector.activeToast;
    if (!toast || !toast._detectedTrack) return;

    const track = toast._detectedTrack;
    dismissActiveToast();

    // Activate the track
    await activateTrack(track);
}

function generateTrackId() {
    return 'track_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// ========== TRACK MANAGER UI ==========
function openTrackModal() {
    $('track-modal').classList.add('open');
    renderDemoTrackList();
    renderTrackList();
    updateActiveTrackDisplay();
}

function closeTrackModal() {
    $('track-modal').classList.remove('open');
}

function updateActiveTrackDisplay() {
    const section = $('active-track-section');
    if (activeTrack) {
        section.style.display = 'flex';
        $('active-track-name').textContent = activeTrack.name;
        const typeLabel = activeTrack.type === 'point_to_point' ? 'runs' : 'laps';
        const bestStr = activeTrack.bestLapMs ? formatLapTime(activeTrack.bestLapMs) : '‚Äî';
        $('active-track-meta').textContent = 'Best: ' + bestStr + ' ¬∑ ' + (activeTrack.lapCount || 0) + ' ' + typeLabel;
    } else {
        section.style.display = 'none';
    }
}

async function renderTrackList() {
    const listEl = $('track-list');
    try {
        const tracks = await getAllTracks();

        if (tracks.length === 0) {
            listEl.innerHTML = '<div class="bbTrackEmpty">No saved tracks</div>';
            return;
        }

        // Sort by most recently modified
        tracks.sort((a, b) => b.modified - a.modified);

        listEl.innerHTML = tracks.map(track => {
            const bestStr = track.bestLapMs ? formatLapTime(track.bestLapMs) : '‚Äî';
            const isActive = activeTrack && activeTrack.id === track.id;
            const isP2P = track.type === 'point_to_point';
            const unitPlural = isP2P ? 'runs' : 'laps';
            const lapCount = track.lapCount || 0;

            return '<div class="bbTrackItem" data-track-id="' + track.id + '">' +
                '<div class="bbTrackInfo">' +
                    '<div class="bbTrackName">' + escapeHtml(track.name) + (isActive ? ' ‚úì' : '') + '</div>' +
                    '<div class="bbTrackMeta">' +
                        '<span>Best: ' + bestStr + '</span>' +
                        '<span>' + lapCount + ' ' + unitPlural + '</span>' +
                    '</div>' +
                '</div>' +
                '<div class="bbTrackActions">' +
                    '<button class="bbTrackBtn primary" data-action="use">Use</button>' +
                    (lapCount > 0 ? '<button class="bbTrackBtn secondary" data-action="history" title="View lap history">H</button>' : '') +
                    '<button class="bbTrackBtn danger" data-action="delete">√ó</button>' +
                '</div>' +
            '</div>';
        }).join('');

        // Add event listeners
        listEl.querySelectorAll('.bbTrackBtn').forEach(btn => {
            btn.onclick = () => handleTrackAction(btn.dataset.action, btn.closest('.bbTrackItem').dataset.trackId);
        });
    } catch (e) {
        console.error('Failed to load tracks:', e);
        listEl.innerHTML = '<div class="bbTrackEmpty">Error loading tracks</div>';
    }
}

function renderDemoTrackList() {
    const listEl = $('demo-track-list');

    listEl.innerHTML = DEMO_TRACKS.map(track => {
        const isActive = activeTrack && activeTrack.id === track.id;
        const typeLabel = track.type === 'point_to_point' ? 'Stage' : 'Circuit';
        return '<div class="bbTrackItem" data-track-id="' + track.id + '">' +
            '<div class="bbTrackInfo">' +
                '<div class="bbTrackName">' + escapeHtml(track.name) + (isActive ? ' ‚úì' : '') + '</div>' +
                '<div class="bbTrackMeta">' +
                    '<span>' + typeLabel + '</span>' +
                    '<span>Simulation track</span>' +
                '</div>' +
            '</div>' +
            '<div class="bbTrackActions">' +
                '<button class="bbTrackBtn primary" data-action="use">Use</button>' +
            '</div>' +
        '</div>';
    }).join('');

    // Add event listeners
    listEl.querySelectorAll('.bbTrackBtn').forEach(btn => {
        btn.onclick = () => {
            const trackId = btn.closest('.bbTrackItem').dataset.trackId;
            const demoTrack = DEMO_TRACKS.find(t => t.id === trackId);
            if (demoTrack) {
                // Make a copy so we can add lap data without modifying the constant
                const track = { ...demoTrack, isNew: true };
                activateTrack(track);
                closeTrackModal();
            }
        };
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function handleTrackAction(action, trackId) {
    if (action === 'use') {
        const track = await getTrack(trackId);
        if (track) {
            activateTrack(track);
            closeTrackModal();
        }
    } else if (action === 'delete') {
        if (confirm('Delete this track and all lap history?')) {
            // Delete lap history first
            await deleteLapHistoryForTrack(trackId);
            await deleteTrack(trackId);
            if (activeTrack && activeTrack.id === trackId) {
                deactivateTrack();
            }
            renderTrackList();
        }
    } else if (action === 'history') {
        await showTrackHistory(trackId);
    }
}

// Format a date for session grouping (Today, Yesterday, or date)
function formatSessionDate(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today.getTime() - 86400000);
    const sessionDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    if (sessionDay.getTime() === today.getTime()) {
        return 'Today';
    } else if (sessionDay.getTime() === yesterday.getTime()) {
        return 'Yesterday';
    } else {
        // Format as "Mon, Jan 15"
        return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
    }
}

// Format session time of day
function formatSessionTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
}

// Show lap history for a track in an expandable section
async function showTrackHistory(trackId) {
    const track = await getTrack(trackId);
    if (!track) return;

    const historyData = await getLapHistoryForTrack(trackId);
    const isP2P = track.type === 'point_to_point';
    const unit = isP2P ? 'run' : 'lap';
    const unitPlural = isP2P ? 'runs' : 'laps';

    // Find or create the history section for this track
    const trackItem = document.querySelector(`.bbTrackItem[data-track-id="${trackId}"]`);
    if (!trackItem) return;

    // Toggle existing history section
    const existingHistory = trackItem.querySelector('.bbTrackHistory');
    if (existingHistory) {
        existingHistory.remove();
        return;
    }

    // Create history section
    const historySection = document.createElement('div');
    historySection.className = 'bbTrackHistory';

    if (historyData.sessions.length === 0) {
        historySection.innerHTML = `
            <div class="bbHistoryEmpty">
                <span>No ${unit} history yet</span>
                <span class="bbHistoryHint">Complete some ${unitPlural} to start tracking</span>
            </div>
        `;
    } else {
        let html = `
            <div class="bbHistorySummary">
                <span class="bbHistoryTotal">${historyData.totalLaps} ${historyData.totalLaps === 1 ? unit : unitPlural} total</span>
                <span class="bbHistorySessions">${historyData.sessions.length} session${historyData.sessions.length === 1 ? '' : 's'}</span>
            </div>
            <div class="bbHistorySessions">
        `;

        // Show up to 5 most recent sessions
        const recentSessions = historyData.sessions.slice(0, 5);
        for (const session of recentSessions) {
            const dateStr = formatSessionDate(session.sessionStart);
            const timeStr = formatSessionTime(session.sessionStart);
            const bestStr = formatLapTime(session.bestMs);
            const lapCount = session.laps.length;

            html += `
                <div class="bbHistorySession">
                    <div class="bbHistorySessionHeader">
                        <span class="bbHistoryDate">${dateStr} ${timeStr}</span>
                        <span class="bbHistorySessionStats">Best: ${bestStr} ¬∑ ${lapCount} ${lapCount === 1 ? unit : unitPlural}</span>
                    </div>
                    <div class="bbHistoryLaps">
            `;

            // Show lap times in a compact grid
            for (const lap of session.laps) {
                const isBest = lap.lapTimeMs === session.bestMs;
                html += `<span class="bbHistoryLap${isBest ? ' best' : ''}">${formatLapTime(lap.lapTimeMs)}</span>`;
            }

            html += `
                    </div>
                </div>
            `;
        }

        // Show "more sessions" indicator if there are more
        if (historyData.sessions.length > 5) {
            const moreCount = historyData.sessions.length - 5;
            html += `<div class="bbHistoryMore">+${moreCount} more session${moreCount === 1 ? '' : 's'}</div>`;
        }

        html += '</div>';

        // Add clear history button
        html += `
            <div class="bbHistoryActions">
                <button class="bbHistoryClearBtn" onclick="clearTrackHistoryConfirm('${trackId}')">Clear History</button>
            </div>
        `;

        historySection.innerHTML = html;
    }

    trackItem.appendChild(historySection);
}

// Confirm and clear lap history for a track
async function clearTrackHistoryConfirm(trackId) {
    if (confirm('Clear all lap history for this track? This cannot be undone.')) {
        await deleteLapHistoryForTrack(trackId);
        // Also reset lapCount on the track
        const track = await getTrack(trackId);
        if (track) {
            track.lapCount = 0;
            await saveTrack(track);
        }
        // Refresh the track list
        renderTrackList();
    }
}

async function activateTrack(track) {
    activeTrack = track;
    suppressStartLineIndicator = false; // Reset indicator suppression

    // Start a new session for lap history (only for non-demo tracks)
    if (!track.isDemo) {
        startNewSession();
    }

    const isP2P = track.type === 'point_to_point';

    // Set up timing lines from the track
    simTimingLine = {
        p1: track.startLine.p1,
        p2: track.startLine.p2,
        direction: track.startLine.direction
    };
    simFinishLine = isP2P && track.finishLine ? {
        p1: track.finishLine.p1,
        p2: track.finishLine.p2,
        direction: track.finishLine.direction
    } : null;
    simPrevPos = null;

    // For new P2P tracks, require moving away from start before timing can begin
    // This prevents immediate timing start when the simulation car is already near the start
    p2pNeedsWarmup = isP2P && track.isNew;

    // Load reference lap for predictive delta
    // Demo tracks start fresh each session (educational purpose)
    // User-created tracks persist references across sessions
    if (track.isDemo) {
        referenceLap = null;
    } else {
        try {
            referenceLap = await getReferenceLap(track.id);
        } catch (err) {
            console.error('Failed to load reference lap:', err);
            referenceLap = null;
        }
    }

    // Reset lap tracker
    lapTracker.reset();
    lastDeltaMs = 0;
    deltaTrend = 0;

    // Activate lap timer
    lapTimerActive = true;
    lapTimerState = 'armed';
    lapStartTime = 0;
    currentLapMs = 0;
    lapCount = 0;
    bestLapMs = track.bestLapMs || null;
    lastLapMs = null;

    // Update UI
    const section = $('lap-section');
    section.classList.remove('inactive');
    section.classList.add('active');
    section.classList.toggle('p2p', isP2P);
    section.classList.toggle('first-run', !track.lapCount);
    section.classList.toggle('has-ref', !!referenceLap);
    $('lap-time').textContent = '0:00.000';

    // Terminology: "Run" for P2P, "Lap" for loops
    // Show lapCount for loaded tracks, or 1 for new tracks (avoids "Lap 0")
    const unit = isP2P ? 'Run' : 'Lap';
    $('lap-count').textContent = unit + ' ' + Math.max(1, lapCount);
    $('lap-state').textContent = 'Armed';
    $('lap-state').classList.remove('timing');

    // Show messaging for new tracks (no completed laps/runs yet)
    if (!track.lapCount) {
        $('best-lap').textContent = '‚Äî:‚Äî‚Äî';
        $('best-lap').classList.remove('best');
        $('last-lap').textContent = '‚Äî:‚Äî‚Äî';
    } else {
        $('best-lap').textContent = bestLapMs ? formatLapTime(bestLapMs) : '‚Äî:‚Äî‚Äî';
        $('best-lap').classList.toggle('best', !!bestLapMs);
        $('last-lap').textContent = '‚Äî:‚Äî‚Äî';
    }
    $('lap-delta').textContent = '‚Äî';
    $('lap-delta').className = 'bbLapHistValue bbNum delta';

    // Initialize delta bar display (isP2P already declared at function start)
    updateDeltaBar({ deltaMs: null, hasReference: !!referenceLap, isP2P });

    // Update track name displays
    $('lap-setup-text').textContent = track.name;
    $('lap-track-name').textContent = track.name;
}

function deactivateTrack() {
    activeTrack = null;
    referenceLap = null;
    lapTracker.reset();
    clearSession(); // Clear session for lap history
    deactivateLapTimer();
    $('lap-setup-text').textContent = 'No track configured';
    $('lap-track-name').textContent = '';
}

async function clearActiveTrack() {
    if (!activeTrack) return;
    deactivateTrack();
    updateActiveTrackDisplay();
    renderTrackList();
}

// Stop timing with confirmation
function confirmStopTiming() {
    if (!activeTrack) return;

    const trackName = activeTrack.name || 'this track';
    if (confirm(`Stop timing "${trackName}"?`)) {
        clearActiveTrack();
    }
}

// Update track's best lap when a new best is set
async function updateTrackBestLap(lapTimeMs) {
    if (!activeTrack) return;

    // Demo tracks don't persist to IndexedDB - they start fresh each session
    if (activeTrack.isDemo) {
        // Still update in-memory for current session
        if (!activeTrack.bestLapMs || lapTimeMs < activeTrack.bestLapMs) {
            activeTrack.bestLapMs = lapTimeMs;
        }
        activeTrack.lapCount = (activeTrack.lapCount || 0) + 1;
        return;
    }

    if (!activeTrack.bestLapMs || lapTimeMs < activeTrack.bestLapMs) {
        activeTrack.bestLapMs = lapTimeMs;
    }
    activeTrack.lapCount = (activeTrack.lapCount || 0) + 1;
    await saveTrack(activeTrack);
}

// State
let loopStartTime = Date.now();
let sessionStart = Date.now();
let rec = false, cnt = 0, drops = 0;

// === LAP TIMER STATE ===
let lapTimerActive = false;
let lapTimerState = 'idle'; // 'idle', 'armed', 'timing'
let suppressStartLineIndicator = false; // True after creating new track, cleared on first crossing
let p2pNeedsWarmup = false; // True for new P2P tracks - must move away from start before crossings count
let lapStartTime = 0;
let currentLapMs = 0;
let lapCount = 0;
let bestLapMs = null;
let lastLapMs = null;
let lapCrossingDebounce = 0;
const LAP_DEBOUNCE_MS = 1000; // Prevent double-crossings
const MIN_LAP_TIME_MS = 5000; // 5 second minimum lap

// === LAP SPEED VARIANCE ===
// Creates realistic lap-to-lap variation for meaningful delta display
// Without this, every lap is identical and delta is always ~0
let lapSpeedModifier = 1.0;      // Overall speed modifier for current lap (0.85-1.15)
let lapSectorVariance = [];      // Per-sector speed modifiers for within-lap variation

/**
 * Generate new speed variance for a lap
 * Creates meaningful lap-to-lap differences for the delta display
 *
 * DEMO EXPLANATION:
 * - Lap 1: Near-baseline (~20s) to set a fair reference
 * - Lap 2+: Random variance creates faster/slower laps
 * - Speed modifier 1.10 = 10% faster = ~18.2s lap (was 20s) = -1.8s delta
 * - Speed modifier 0.90 = 10% slower = ~22.2s lap (was 20s) = +2.2s delta
 */
function generateLapVariance() {
    const BASE_LAP_TIME = 20.0; // seconds (LOOP_DURATION / 1000)
    let expectedLapTime, description;

    if (lapCount === 0) {
        // First lap: near-baseline for reference
        lapSpeedModifier = 0.98 + Math.random() * 0.04;  // 0.98-1.02
        expectedLapTime = BASE_LAP_TIME / lapSpeedModifier;
        description = 'REFERENCE LAP (baseline)';
    } else {
        // Subsequent laps: meaningful variance
        const roll = Math.random();
        if (roll < 0.4) {
            // Faster lap - will show NEGATIVE delta (green, ahead)
            lapSpeedModifier = 1.05 + Math.random() * 0.10;  // 1.05-1.15
            expectedLapTime = BASE_LAP_TIME / lapSpeedModifier;
            description = 'FASTER LAP (expect green/ahead delta)';
        } else if (roll < 0.8) {
            // Slower lap - will show POSITIVE delta (red, behind)
            lapSpeedModifier = 0.87 + Math.random() * 0.10;  // 0.87-0.97
            expectedLapTime = BASE_LAP_TIME / lapSpeedModifier;
            description = 'SLOWER LAP (expect red/behind delta)';
        } else {
            // Similar - small delta
            lapSpeedModifier = 0.98 + Math.random() * 0.04;  // 0.98-1.02
            expectedLapTime = BASE_LAP_TIME / lapSpeedModifier;
            description = 'SIMILAR LAP (small delta)';
        }
    }

    // Generate 4 sector modifiers for within-lap variation
    // This makes deltas evolve during the lap (not just flat)
    lapSectorVariance = [
        0.96 + Math.random() * 0.08,  // Sector 1
        0.96 + Math.random() * 0.08,  // Sector 2
        0.96 + Math.random() * 0.08,  // Sector 3
        0.96 + Math.random() * 0.08   // Sector 4
    ];

}

/**
 * Get the current speed modifier based on lap progress
 * Combines overall lap modifier with sector-specific variance
 */
function getCurrentSpeedModifier(lapProgress) {
    if (lapSectorVariance.length === 0) return lapSpeedModifier;

    // Determine which sector we're in (0-3)
    const sectorIndex = Math.min(3, Math.floor(lapProgress * 4));
    const sectorMod = lapSectorVariance[sectorIndex];

    // Combine with overall lap modifier
    return lapSpeedModifier * sectorMod;
}

function formatLapTime(ms) {
    if (ms === null || ms === undefined) return '‚Äî:‚Äî‚Äî';
    const totalSec = ms / 1000;
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    return min + ':' + sec.toFixed(3).padStart(6, '0');
}

function deactivateLapTimer() {
    lapTimerActive = false;
    lapTimerState = 'idle';

    // Clear timing line and position tracking
    simTimingLine = null;
    simFinishLine = null;
    simPrevPos = null;
    p2pNeedsWarmup = false;

    const section = $('lap-section');
    section.classList.remove('active', 'timing', 'p2p', 'first-run', 'has-ref');
    section.classList.add('inactive');
}

function updateLapDisplay() {
    const isP2P = activeTrack && activeTrack.type === 'point_to_point';
    const unit = isP2P ? 'Run' : 'Lap';

    $('lap-time').textContent = formatLapTime(currentLapMs);
    // Show current lap/run being timed, or completed count when not timing
    // During timing: lapCount + 1 (current lap)
    // Armed/idle: lapCount (completed laps), minimum 1 to avoid "Lap 0"
    const isTiming = lapTimerState === 'timing';
    const displayNum = Math.max(1, lapCount + (isTiming ? 1 : 0));
    $('lap-count').textContent = unit + ' ' + displayNum;

    if (bestLapMs !== null) {
        $('best-lap').textContent = formatLapTime(bestLapMs);
        $('best-lap').classList.add('best');
    } else {
        $('best-lap').textContent = '‚Äî:‚Äî‚Äî';
        $('best-lap').classList.remove('best');
    }

    if (lastLapMs !== null) {
        $('last-lap').textContent = formatLapTime(lastLapMs);
    } else {
        $('last-lap').textContent = '‚Äî:‚Äî‚Äî';
    }
}

// Calculate distance and bearing from current position to timing line center
function getDistanceToStartLine() {
    if (!simTimingLine || !currentSimPos) return null;

    // Center of timing line
    const cx = (simTimingLine.p1[0] + simTimingLine.p2[0]) / 2;
    const cy = (simTimingLine.p1[1] + simTimingLine.p2[1]) / 2;

    // Vector from current position to timing line center
    const dx = cx - currentSimPos.x;
    const dy = cy - currentSimPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Bearing in radians (0 = east, œÄ/2 = north)
    const bearing = Math.atan2(dy, dx);

    return { distance, bearing, cx, cy };
}

// Format distance with km for large values, m for small
function formatDistance(meters) {
    if (meters >= 1000) {
        return (meters / 1000).toFixed(1) + 'km';
    }
    return Math.round(meters) + 'm';
}

// Convert bearing to arrow character (cardinal direction relative to current heading)
function bearingToArrow(bearing, currentHeading) {
    // Relative bearing (how far to turn from current heading)
    let relBearing = bearing - currentHeading;

    // Normalize to [-œÄ, œÄ]
    while (relBearing > Math.PI) relBearing -= 2 * Math.PI;
    while (relBearing < -Math.PI) relBearing += 2 * Math.PI;

    // Convert to 8-direction arrow
    const deg = relBearing * 180 / Math.PI;
    if (deg > -22.5 && deg <= 22.5) return '‚Üë';      // Ahead
    if (deg > 22.5 && deg <= 67.5) return '‚Üó';      // Ahead-right
    if (deg > 67.5 && deg <= 112.5) return '‚Üí';     // Right
    if (deg > 112.5 && deg <= 157.5) return '‚Üò';    // Behind-right
    if (deg > 157.5 || deg <= -157.5) return '‚Üì';   // Behind
    if (deg > -157.5 && deg <= -112.5) return '‚Üô';  // Behind-left
    if (deg > -112.5 && deg <= -67.5) return '‚Üê';   // Left
    if (deg > -67.5 && deg <= -22.5) return '‚Üñ';    // Ahead-left
    return '‚Ä¢';
}

// Update the start line indicator UI
function updateStartLineIndicator() {
    const indicator = $('start-line-indicator');
    const textEl = $('start-line-text');

    if (!indicator || !textEl) return;

    // Only show when armed (not timing/running or idle)
    if (lapTimerState !== 'armed' || !simTimingLine || !currentSimPos) {
        indicator.style.display = 'none';
        return;
    }

    indicator.style.display = 'block';

    const isP2P = activeTrack && activeTrack.type === 'point_to_point';
    const hasHistory = activeTrack && activeTrack.lapCount > 0;

    // For newly created tracks, show contextual instruction
    if (suppressStartLineIndicator) {
        if (isP2P) {
            // For P2P, show distance to start (user is at finish location)
            const result = getDistanceToStartLine();
            if (result) {
                const arrow = bearingToArrow(result.bearing, currentSimPos.heading);
                textEl.textContent = 'Return to start: ' + formatDistance(result.distance) + ' ' + arrow;
                textEl.className = result.distance < 50 ? 'bbStartLineText approaching' : 'bbStartLineText';
            } else {
                textEl.textContent = 'Return to start';
                textEl.className = 'bbStartLineText';
            }
        } else {
            // For loops, user is at the start already
            textEl.textContent = 'Drive a lap, then cross start to begin';
            textEl.className = 'bbStartLineText';
        }
        return;
    }

    const result = getDistanceToStartLine();
    if (!result) {
        textEl.textContent = 'Position unavailable';
        textEl.className = 'bbStartLineText';
        return;
    }

    const { distance, bearing } = result;
    const arrow = bearingToArrow(bearing, currentSimPos.heading);

    // For loaded tracks without history, show simple instruction
    if (!hasHistory) {
        if (distance > 50) {
            textEl.textContent = 'Start line: ' + formatDistance(distance) + ' ' + arrow;
            textEl.className = 'bbStartLineText';
        } else if (distance > 15) {
            textEl.textContent = 'Approaching start: ' + formatDistance(distance) + ' ' + arrow;
            textEl.className = 'bbStartLineText approaching';
        } else {
            textEl.textContent = 'Cross to begin! ' + arrow;
            textEl.className = 'bbStartLineText at-line';
        }
        return;
    }

    // Distance-based messaging for loaded tracks with history
    if (distance > 100) {
        textEl.textContent = 'Start line: ' + formatDistance(distance) + ' ' + arrow;
        textEl.className = 'bbStartLineText';
    } else if (distance > 50) {
        textEl.textContent = 'Approaching start: ' + formatDistance(distance) + ' ' + arrow;
        textEl.className = 'bbStartLineText approaching';
    } else if (distance > 15) {
        textEl.textContent = 'Almost there: ' + formatDistance(distance) + ' ' + arrow;
        textEl.className = 'bbStartLineText close';
    } else {
        textEl.textContent = 'Cross to begin! ' + arrow;
        textEl.className = 'bbStartLineText at-line';
    }
}

// Calculate distance to finish line (P2P tracks only)
function getDistanceToFinishLine() {
    if (!simFinishLine || !currentSimPos) return null;

    // Center of finish line
    const cx = (simFinishLine.p1[0] + simFinishLine.p2[0]) / 2;
    const cy = (simFinishLine.p1[1] + simFinishLine.p2[1]) / 2;

    // Vector from current position to finish line center
    const dx = cx - currentSimPos.x;
    const dy = cy - currentSimPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Bearing in radians (0 = east, œÄ/2 = north)
    const bearing = Math.atan2(dy, dx);

    return { distance, bearing, cx, cy };
}

// Update the finish line indicator UI (P2P tracks when running)
function updateFinishLineIndicator() {
    const indicator = $('finish-line-indicator');
    const textEl = $('finish-line-text');

    if (!indicator || !textEl) return;

    const isP2P = activeTrack && activeTrack.type === 'point_to_point';

    // Only show when P2P and timing (running)
    if (!isP2P || lapTimerState !== 'timing' || !simFinishLine || !currentSimPos) {
        indicator.style.display = 'none';
        return;
    }

    indicator.style.display = 'block';

    const result = getDistanceToFinishLine();
    if (!result) {
        textEl.textContent = 'Position unavailable';
        textEl.className = 'bbFinishLineText';
        return;
    }

    const { distance, bearing } = result;
    const arrow = bearingToArrow(bearing, currentSimPos.heading);

    // Distance-based messaging
    if (distance > 100) {
        textEl.textContent = 'Distance to finish: ' + formatDistance(distance) + ' ' + arrow;
        textEl.className = 'bbFinishLineText';
    } else if (distance > 50) {
        textEl.textContent = 'Approaching finish: ' + formatDistance(distance) + ' ' + arrow;
        textEl.className = 'bbFinishLineText approaching';
    } else if (distance > 15) {
        textEl.textContent = 'Almost there: ' + formatDistance(distance) + ' ' + arrow;
        textEl.className = 'bbFinishLineText close';
    } else {
        textEl.textContent = 'Cross to finish! ' + arrow;
        textEl.className = 'bbFinishLineText at-line';
    }
}

function onStartLineCrossing(timestamp) {
    if (!lapTimerActive) return;

    // Debounce check
    if (timestamp - lapCrossingDebounce < LAP_DEBOUNCE_MS) return;
    lapCrossingDebounce = timestamp;

    const isP2P = activeTrack && activeTrack.type === 'point_to_point';
    const unit = isP2P ? 'Run' : 'Lap';

    if (lapTimerState === 'armed') {
        // First crossing - start timing
        lapTimerState = 'timing';
        lapStartTime = timestamp;
        currentLapMs = 0;
        suppressStartLineIndicator = false; // Clear suppression on first crossing
        $('lap-state').textContent = isP2P ? 'Running' : 'Timing';
        $('lap-state').classList.add('timing');

        // Reset lap tracker for delta calculation
        lapTracker.reset();
        lastDeltaMs = 0;
        deltaTrend = 0;

        // Generate new speed variance for this lap (creates meaningful deltas)
        generateLapVariance();

        // Reset delta bar for new lap/run
        updateDeltaBar({ deltaMs: 0, trend: 0, hasReference: !!referenceLap, isP2P });

        // Add timing class to card (hides start line indicator via CSS)
        const section = $('lap-section');
        section.classList.add('timing');

        // Flash to indicate crossing
        section.classList.add('bbLapFlash');
        setTimeout(() => section.classList.remove('bbLapFlash'), 600);

        // For P2P, we wait for finish line, not start line again
        if (isP2P) return;

    } else if (lapTimerState === 'timing') {
        // For P2P tracks, ignore start line crossing while timing (wait for finish)
        if (isP2P) return;

        // Complete lap (loop tracks only)
        completeLapOrRun(timestamp);
    }
}

// Called when crossing finish line (P2P tracks only)
function onFinishLineCrossing(timestamp) {
    if (!lapTimerActive || lapTimerState !== 'timing') return;

    const isP2P = activeTrack && activeTrack.type === 'point_to_point';
    if (!isP2P) return; // Shouldn't happen, but guard

    // Debounce check (use same debounce variable)
    if (timestamp - lapCrossingDebounce < LAP_DEBOUNCE_MS) return;
    lapCrossingDebounce = timestamp;

    // Complete the run
    completeLapOrRun(timestamp, true);
}

// Complete a lap (loops) or run (P2P) and update state
function completeLapOrRun(timestamp, isFinishLine = false) {
    const isP2P = activeTrack && activeTrack.type === 'point_to_point';
    const unit = isP2P ? 'Run' : 'Lap';
    const lapTimeMs = timestamp - lapStartTime;

    // Validate lap/run time
    if (lapTimeMs < MIN_LAP_TIME_MS) {
        return; // Too short
    }

    lastLapMs = lapTimeMs;
    lapCount++;

    const isNewBest = bestLapMs === null || lapTimeMs < bestLapMs;
    if (isNewBest) {
        bestLapMs = lapTimeMs;

        // Save as new reference lap for predictive delta
        if (activeTrack && lapTracker.isValid()) {
            saveNewReferenceLap(activeTrack.id, lapTimeMs, lapTracker);
        }
    }

    // Update delta display
    const deltaEl = $('lap-delta');
    if (isNewBest && lapCount > 1) {
        deltaEl.textContent = 'BEST';
        deltaEl.className = 'bbLapHistValue bbNum delta faster';
    } else if (!isNewBest) {
        const deltaMs = lapTimeMs - bestLapMs;
        const sign = deltaMs > 0 ? '+' : '';
        deltaEl.textContent = sign + (deltaMs / 1000).toFixed(3);
        deltaEl.className = 'bbLapHistValue bbNum delta slower';
    } else {
        deltaEl.textContent = '‚Äî';
        deltaEl.className = 'bbLapHistValue bbNum delta';
    }

    // Flash animations
    const section = $('lap-section');
    section.classList.add('bbLapFlash');
    setTimeout(() => section.classList.remove('bbLapFlash'), 600);

    if (isNewBest) {
        const bestEl = $('best-lap');
        bestEl.classList.add('bbLapBestFlash');
        setTimeout(() => bestEl.classList.remove('bbLapBestFlash'), 800);
    }

    // Update track's best lap in IndexedDB
    updateTrackBestLap(lapTimeMs);

    // Record lap to history (non-demo tracks only)
    if (activeTrack && !activeTrack.isDemo) {
        recordLapToHistory(activeTrack.id, lapTimeMs, lapCount).catch(e => {
            console.error('Failed to record lap to history:', e);
        });
    }

    // Clear first-run badge after first completion (both loop and P2P)
    section.classList.remove('first-run');

    if (isP2P) {
        // P2P: Run complete - show "Finished!" briefly, then show "Armed"
        lapTimerState = 'armed';  // Set state immediately to prevent more crossings
        suppressStartLineIndicator = true;  // Show "Return to start" message
        section.classList.remove('timing');
        $('lap-state').classList.remove('timing');
        $('lap-state').textContent = 'Finished!';
        $('lap-state').classList.add('finished');
        $('lap-count').textContent = unit + ' ' + lapCount;

        // After 1.5s, show "Armed" text
        setTimeout(() => {
            $('lap-state').textContent = 'Armed';
            $('lap-state').classList.remove('finished');
        }, 1500);
    } else {
        // Loop: Start new lap immediately
        lapStartTime = timestamp;
        currentLapMs = 0;

        // Reset lap tracker for next lap
        lapTracker.reset();
        lastDeltaMs = 0;
        deltaTrend = 0;

        // Generate new speed variance for this lap (creates meaningful deltas)
        generateLapVariance();

        // Reset delta bar for next lap
        updateDeltaBar({ deltaMs: 0, trend: 0, hasReference: !!referenceLap, isP2P: false });
    }

    updateLapDisplay();
}

/**
 * Update lap timer state and check for line crossings
 * @param {number} now - Current timestamp (ms)
 * @param {Object|null} posData - Position data: {x, y, vx, vy, speed} or null
 */
function simulateLapTimerUpdate(now, posData) {
    if (!lapTimerActive) return;

    // Update current lap time if timing
    if (lapTimerState === 'timing') {
        currentLapMs = now - lapStartTime;
        $('lap-time').textContent = formatLapTime(currentLapMs);

        // Update lap tracker for delta calculation (requires position data)
        if (posData) {
            const currentDistance = lapTracker.update(posData.x, posData.y, currentLapMs);
            const isP2P = activeTrack && activeTrack.type === 'point_to_point';

            // Calculate and display live delta via delta bar
            if (referenceLap) {
                const delta = calculateDelta(currentDistance, currentLapMs, referenceLap);
                if (delta.valid) {
                    // Calculate trend (smoothed derivative of delta)
                    const trendAlpha = 0.15;
                    deltaTrend = trendAlpha * (delta.deltaMs - lastDeltaMs) + (1 - trendAlpha) * deltaTrend;
                    lastDeltaMs = delta.deltaMs;

                    // Update delta bar (scale: 2000ms = full bar)
                    updateDeltaBar({
                        deltaMs: delta.deltaMs,
                        trend: deltaTrend,
                        hasReference: true,
                        isP2P
                    });
                }
            } else {
                updateDeltaBar({ deltaMs: null, hasReference: false, isP2P });
            }
        }
    }

    // Geometry-based crossing detection (requires position data and timing line)
    if (posData && simTimingLine) {
        // P2P warmup check: car must move away from start before timing can begin
        if (p2pNeedsWarmup) {
            const cx = (simTimingLine.p1[0] + simTimingLine.p2[0]) / 2;
            const cy = (simTimingLine.p1[1] + simTimingLine.p2[1]) / 2;
            const distToStart = Math.sqrt(
                (posData.x - cx) ** 2 + (posData.y - cy) ** 2
            );
            // Once car is 50m away, allow crossings
            if (distToStart > 50) {
                p2pNeedsWarmup = false;
            }
        }

        // Need previous position for crossing detection
        if (simPrevPos) {
            // Skip if nearly stationary (< 0.5 m/s)
            if (posData.speed >= 0.5) {
                // Check for start line crossing (skip if warmup needed)
                if (!p2pNeedsWarmup) {
                    const intersection = lineSegmentIntersection(
                        [simPrevPos.x, simPrevPos.y],
                        [posData.x, posData.y],
                        simTimingLine.p1,
                        simTimingLine.p2
                    );

                    if (intersection !== null) {
                        // Validate crossing direction
                        if (directionValid([posData.vx, posData.vy], simTimingLine.direction)) {
                            onStartLineCrossing(now);
                        }
                    }
                }

                // Check for finish line crossing (P2P only, when timing)
                if (simFinishLine && lapTimerState === 'timing') {
                    const finishIntersection = lineSegmentIntersection(
                        [simPrevPos.x, simPrevPos.y],
                        [posData.x, posData.y],
                        simFinishLine.p1,
                        simFinishLine.p2
                    );

                    if (finishIntersection !== null) {
                        if (directionValid([posData.vx, posData.vy], simFinishLine.direction)) {
                            onFinishLineCrossing(now);
                        }
                    }
                }
            }
        }

        // Store current position for next frame
        simPrevPos = { x: posData.x, y: posData.y };
    }

    // Update finish line indicator for P2P tracks when running
    updateFinishLineIndicator();
}
let trail = [], maxL = 0, maxR = 0, maxA = 0, maxB = 0, peak = 0;
let emaGx = 0, emaGy = 0, lastT = 0, speed_ema = 0;
const EMA_TAU = 0.10;
const TRAIL_DURATION_MS = 2500;
const TRAIL_MAX_POINTS = 60;
const TRAIL_JITTER_THRESHOLD = 0.008;

const SCALE_STEPS = [0.3, 0.5, 0.8, 1.0, 1.5, 2.0];
let currentScale = 0.5;

let config = { acc_thr: 0.22, acc_exit: 0.11, brake_thr: 0.35, brake_exit: 0.17, lat_thr: 0.28, lat_exit: 0.14, yaw_thr: 0.10, min_speed: 3.0, alpha: 0.35 };
let emaLat = 0, emaYaw = 0, inAccel = false, inBrake = false, inCorner = false;

function classifyMode(lonG, latG, yawRad, speedMs) {
    emaLat = config.alpha * Math.abs(latG) + (1 - config.alpha) * emaLat;
    emaYaw = config.alpha * Math.abs(yawRad) + (1 - config.alpha) * emaYaw;
    if (speedMs < config.min_speed) { inAccel = inBrake = inCorner = false; return 0; }
    if (lonG > config.acc_thr) inAccel = true; else if (lonG < config.acc_exit) inAccel = false;
    if (lonG < -config.brake_thr) inBrake = true; else if (lonG > -config.brake_exit) inBrake = false;
    const signConsistent = (latG * yawRad) > 0;
    if (emaLat > config.lat_thr && emaYaw > config.yaw_thr && signConsistent) inCorner = true;
    else if (emaLat < config.lat_exit || emaYaw < config.yaw_thr * 0.5) inCorner = false;
    let mode = 0;
    if (inAccel) mode |= 1; if (inBrake) mode |= 2; if (inCorner) mode |= 4;
    if ((mode & 3) === 3) mode &= ~2;
    return mode;
}

let isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
function applyTheme() {
    document.body.classList.toggle('dark', isDark);
    $('modeLabel').textContent = isDark ? 'Dark' : 'Bright';
}
applyTheme();

$('brandToggle').onclick = () => { isDark = !isDark; applyTheme(); };

const cv = $('gcanvas');
const ctx = cv.getContext('2d');

function resize() {
    const frame = cv.parentElement;
    const rect = frame.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    cv.width = size * devicePixelRatio;
    cv.height = size * devicePixelRatio;
    cv.style.width = size + 'px';
    cv.style.height = size + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
}
resize();
window.addEventListener('resize', resize);

let magHist = [];
function updateScale(gx, gy) {
    const now = Date.now();
    const mag = Math.sqrt(gx * gx + gy * gy);
    magHist.push({ t: now, m: mag });
    magHist = magHist.filter(h => now - h.t < 1000);
    const peakMag = Math.max(...magHist.map(h => h.m), 0.1);
    const needed = peakMag * 1.4;
    let targetScale = SCALE_STEPS[0];
    for (const step of SCALE_STEPS) {
        if (step >= needed) { targetScale = step; break; }
        targetScale = step;
    }
    if (targetScale > currentScale) currentScale += (targetScale - currentScale) * 0.15;
    else if (targetScale < currentScale) currentScale += (targetScale - currentScale) * 0.03;
    for (const step of SCALE_STEPS) {
        if (Math.abs(currentScale - step) < 0.02) { currentScale = step; break; }
    }
    $('range-val').textContent = 'Range ¬±' + currentScale.toFixed(1) + 'g';
}

function hexToRgba(hex, a) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${a})`;
}

function downsampleTrail(points, maxPoints) {
    if (points.length <= maxPoints) return points;
    const recentCount = Math.min(25, Math.floor(maxPoints * 0.4));
    const recent = points.slice(-recentCount);
    const older = points.slice(0, -recentCount);
    const olderTarget = maxPoints - recentCount;
    const step = Math.ceil(older.length / olderTarget);
    const sampled = older.filter((_, i) => i % step === 0);
    return [...sampled, ...recent];
}

function drawG() {
    const size = cv.width / devicePixelRatio;
    const cx = size / 2, cy = size / 2;
    const r = size * 0.38;

    ctx.clearRect(0, 0, size, size);

    const ringColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
    const axisColor = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.18)';

    ctx.lineWidth = 1;
    ctx.strokeStyle = ringColor;
    [0.2, 0.4, 0.6, 0.8].forEach((f) => {
        ctx.beginPath();
        ctx.arc(cx, cy, r * f, 0, Math.PI * 2);
        ctx.stroke();
    });

    ctx.strokeStyle = axisColor;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
    ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
    ctx.stroke();

    ctx.fillStyle = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fill();

    const now = Date.now();
    const recentTrail = trail.filter(p => now - p.t < TRAIL_DURATION_MS);
    const displayTrail = downsampleTrail(recentTrail, TRAIL_MAX_POINTS);

    if (displayTrail.length > 1) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        for (let i = 1; i < displayTrail.length; i++) {
            const p0 = displayTrail[i - 1];
            const p1 = displayTrail[i];
            const age = (now - p1.t) / TRAIL_DURATION_MS;
            const alpha = Math.max(0.05, 0.35 * (1 - age * 0.85));
            ctx.strokeStyle = hexToRgba(currentModeColor, alpha);
            ctx.lineWidth = 1.5 - age * 0.6;
            ctx.beginPath();
            const x0 = cx + (p0.x / currentScale) * r;
            const y0 = cy - (p0.y / currentScale) * r;
            const x1 = cx + (p1.x / currentScale) * r;
            const y1 = cy - (p1.y / currentScale) * r;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }
    }

    if (trail.length > 0) {
        const cur = trail[trail.length - 1];
        const x = cx + (cur.x / currentScale) * r;
        const y = cy - (cur.y / currentScale) * r;
        const crossSize = 8;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x - crossSize, y);
        ctx.lineTo(x + crossSize, y);
        ctx.moveTo(x, y - crossSize);
        ctx.lineTo(x, y + crossSize);
        ctx.stroke();
    }
}

function fmtGSigned(v) {
    const sign = v >= 0 ? '+' : '‚àí';
    return { sign, num: Math.abs(v).toFixed(2) };
}

function fmtTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function updateModeDisplay(mo) {
    const name = MODES[mo] || 'IDLE';
    const color = MODE_COLORS[mo] || MODE_COLORS[0];
    const hexColors = getModeColorsHex();
    currentModeColor = hexColors[mo] || hexColors[0];
    const el = $('maneuver');
    el.textContent = name;
    el.style.color = color;
}

function updateReadouts(lat, lon) {
    const latFmt = fmtGSigned(lat);
    const lonFmt = fmtGSigned(lon);
    $('lat-g').innerHTML = `<span class="bbSign">${latFmt.sign}</span><span class="bbVal">${latFmt.num}</span><span class="bbGUnit">g</span>`;
    $('lon-g').innerHTML = `<span class="bbSign">${lonFmt.sign}</span><span class="bbVal">${lonFmt.num}</span><span class="bbGUnit">g</span>`;
}

function resetState() {
    maxL = maxR = maxA = maxB = peak = drops = 0;
    $('max-l').textContent = $('max-r').textContent = $('max-a').textContent = $('max-b').textContent = '0.00g';
    $('speed').classList.remove('peak');
    trail = []; magHist = []; currentScale = SCALE_STEPS[0];
    $('range-val').textContent = 'Range ¬±' + currentScale.toFixed(1) + 'g';
    emaGx = emaGy = 0; sessionStart = Date.now();
}

let peakHighlightTimeout = null;

function simulate() {
    let sp, longRaw, latRaw, yawDeg, yawRad, speedMs, mo;
    let posData = null;  // Position data for lap timer: {x, y, vx, vy, speed}

    if (dataSource === 'csv' && csvData) {
        const values = getCSVValues();
        if (!values) return;
        sp = values.speed;
        longRaw = values.lonG;
        latRaw = values.latG;
        yawDeg = Math.abs(values.yawDeg);
        yawRad = values.yawDeg * Math.PI / 180;
        speedMs = sp / 3.6;
        mo = values.mode;

        // If CSV has position data, use it for lap timing
        if (values.hasPosition && (values.px !== 0 || values.py !== 0)) {
            // Estimate velocity from speed and heading (using yaw as rough approximation)
            // For more accurate velocity, we'd need to track position changes
            const heading = yawRad;  // Use yaw as heading approximation
            posData = {
                x: values.px,
                y: values.py,
                vx: speedMs * Math.cos(heading),
                vy: speedMs * Math.sin(heading),
                speed: speedMs
            };
        }
    } else {
        const realElapsed = Date.now() - loopStartTime;

        // Calculate simulated elapsed time for position
        let simElapsed = realElapsed;

        if (lapTimerState === 'timing' && lapStartTime > 0) {
            // During lap timing: position based on SCALED lap elapsed time
            // This makes the car actually take longer/shorter to complete the track
            //
            // With modifier 0.884 (slower):
            //   - At real lapElapsed 10s: scaled = 8.84s ‚Üí car at 8.84s position
            //   - At real lapElapsed 20s: scaled = 17.68s ‚Üí car at 17.68s position (NOT finished)
            //   - At real lapElapsed 22.6s: scaled = 20s ‚Üí car crosses finish
            //
            // With modifier 1.15 (faster):
            //   - At real lapElapsed 10s: scaled = 11.5s ‚Üí car at 11.5s position
            //   - At real lapElapsed 17.4s: scaled = 20s ‚Üí car crosses finish
            const lapElapsed = Date.now() - lapStartTime;

            // Calculate progress through lap (0-1) for sector variance lookup
            const approxProgress = Math.min(0.999, (lapElapsed * lapSpeedModifier) / LOOP_DURATION);
            const sectorMod = getCurrentSpeedModifier(approxProgress);

            // Car position = scaled lap elapsed time
            // getSimulatedPosition will use this % LOOP_DURATION for track position
            simElapsed = lapElapsed * sectorMod;
        }

        const auto = getAutoValues(simElapsed);
        sp = addNoise(auto.speed, 2);
        longRaw = addNoise(auto.lonG, 0.02);
        latRaw = addNoise(auto.latG, 0.02);
        yawDeg = Math.abs(addNoise(auto.yawDeg, 1));
        yawRad = auto.yawDeg * Math.PI / 180;
        speedMs = sp / 3.6;
        mo = classifyMode(longRaw, latRaw, yawRad, speedMs);

        // Get position data for lap timer from track simulation
        const pos = getSimulatedPosition(simElapsed);
        posData = {
            x: pos.x,
            y: pos.y,
            vx: pos.vx,
            vy: pos.vy,
            speed: pos.speed
        };

        // Update current position for track manager
        currentSimPos = {
            x: pos.x,
            y: pos.y,
            heading: pos.heading,
            speed: pos.speed
        };

        // Update start line indicator
        updateStartLineIndicator();

        // Update track recording if active
        updateTrackRecording();

        // Check for track auto-detection (only when no active track)
        if (!activeTrack && !trackRecorder) {
            trackAutoDetector.check(pos.x, pos.y, pos.heading).then(detected => {
                if (detected) showTrackDetectedToast(detected.track);
            }).catch(() => {}); // Silently ignore IndexedDB errors
        }
    }

    speed_ema = 0.7 * sp + 0.3 * speed_ema;
    const dspd = speed_ema < 1 ? 0 : Math.round(speed_ema);

    const now = Date.now();
    const dt = lastT ? Math.min((now - lastT) / 1000, 0.2) : 0.033;
    lastT = now;
    const alpha = 1 - Math.exp(-dt / EMA_TAU);

    emaGx = alpha * latRaw + (1 - alpha) * emaGx;
    emaGy = alpha * longRaw + (1 - alpha) * emaGy;

    const mag = Math.sqrt(emaGx * emaGx + emaGy * emaGy);
    const noise = speed_ema < 5 ? 0.04 : 0.015;
    const lat = mag < noise ? 0 : emaGx;
    const lon = mag < noise ? 0 : emaGy;

    const speedEl = $('speed');
    if (dspd > peak) {
        peak = dspd;
        speedEl.classList.add('peak');
        if (peakHighlightTimeout) clearTimeout(peakHighlightTimeout);
        peakHighlightTimeout = setTimeout(() => speedEl.classList.remove('peak'), 900);
    }
    speedEl.textContent = dspd;

    updateModeDisplay(mo);
    updateReadouts(lat, lon);
    $('yaw').textContent = Math.round(yawDeg);

    if (latRaw < 0 && Math.abs(latRaw) > maxL) { maxL = Math.abs(latRaw); $('max-l').textContent = maxL.toFixed(2) + 'g'; }
    if (latRaw > 0 && latRaw > maxR) { maxR = latRaw; $('max-r').textContent = maxR.toFixed(2) + 'g'; }
    if (longRaw > 0 && longRaw > maxA) { maxA = longRaw; $('max-a').textContent = maxA.toFixed(2) + 'g'; }
    if (longRaw < 0 && Math.abs(longRaw) > maxB) { maxB = Math.abs(longRaw); $('max-b').textContent = maxB.toFixed(2) + 'g'; }

    if (speed_ema >= 2) {
        updateScale(lat, lon);
    } else {
        magHist = [];
        currentScale = SCALE_STEPS[0];
        $('range-val').textContent = 'Range ¬±' + currentScale.toFixed(1) + 'g';
    }

    const lastPt = trail.length > 0 ? trail[trail.length - 1] : null;
    const dx = lastPt ? Math.abs(lat - lastPt.x) : 1;
    const dy = lastPt ? Math.abs(lon - lastPt.y) : 1;
    if (!lastPt || dx > TRAIL_JITTER_THRESHOLD || dy > TRAIL_JITTER_THRESHOLD) {
        trail.push({ x: lat, y: lon, t: now });
    }
    trail = trail.filter(p => now - p.t < TRAIL_DURATION_MS + 200);
    drawG();

    cnt++;
    if (rec) {
        // Get position data from already-computed posData (if available)
        const px = posData ? posData.x : 0;
        const py = posData ? posData.y : 0;
        chunkBuffer.push({ t: now, sp, ax: -longRaw * 9.81, ay: latRaw * 9.81, wz: yawRad, mo, latg: latRaw, lng: longRaw, lat: 37.82, lon: -122.48, gpsOk: 1, px, py });
        if (now - lastSaveTime >= CHUNK_INTERVAL) saveChunk();
    }

    // Update lap timer with position data for crossing detection
    simulateLapTimerUpdate(now, posData);
}

setInterval(simulate, 33);

setInterval(() => {
    $('hz').textContent = cnt;
    cnt = 0;
    $('session-time').textContent = fmtTime(Date.now() - sessionStart);
    $('gps-acc').textContent = '2';
    $('drops').textContent = drops;
}, 1000);

$('menu-btn').onclick = () => $('menu-overlay').classList.add('open');
$('menu-overlay').onclick = e => { if (e.target === $('menu-overlay')) $('menu-overlay').classList.remove('open'); };

$('menu-load').onclick = () => {
    $('menu-overlay').classList.remove('open');
    $('csv-input').click();
};

$('csv-input').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => loadCSVData(evt.target.result, file.name);
    reader.readAsText(file);
};

$('menu-sim').onclick = () => {
    $('menu-overlay').classList.remove('open');
    switchToLoop();
};

$('csv-progress').onclick = (e) => {
    const rect = e.target.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    seekCSV(pct);
};

$('menu-rec').onclick = async () => {
    $('menu-overlay').classList.remove('open');
    if (rec) await stopRecording();
    else { sessionStart = Date.now(); await startRecording(); }
};

$('menu-export').onclick = () => {
    $('menu-overlay').classList.remove('open');
    exportCSV();
};

$('menu-clear').onclick = () => {
    $('menu-overlay').classList.remove('open');
    loopStartTime = Date.now();
    resetState();
};

// Lap timer controls
// Open track manager from lap card button
$('btn-open-tracks').onclick = () => {
    openTrackModal();
};

// Track modal close button
$('track-modal-close').onclick = closeTrackModal;

// Close modal when clicking outside
$('track-modal').onclick = (e) => {
    if (e.target === $('track-modal')) closeTrackModal();
};

// Clear active track button
$('btn-clear-track').onclick = clearActiveTrack;

// ========== DATA MODAL ==========

function openDataModal() {
    $('data-modal').classList.add('open');
    renderDataModal();
}

function closeDataModal() {
    $('data-modal').classList.remove('open');
}

async function renderDataModal() {
    // Fetch combined stats
    const combined = await getCombinedStorageStats();

    // Update storage overview
    $('data-total-size').textContent = formatBytes(combined.totalBytes);
    $('data-rec-size').textContent = formatBytes(combined.recordingsBytes);
    $('data-track-size').textContent = formatBytes(combined.tracksBytes);
    $('data-rec-count').textContent = `(${combined.sessionCount})`;
    $('data-track-count').textContent = `(${combined.trackCount})`;

    // Render both lists
    await renderSessionList();
    await renderTrackDataList();
}

async function renderSessionList() {
    const listEl = $('session-list');
    const clearBtn = $('btn-clear-all-recordings');

    try {
        const stats = await getStorageStats();

        // Enable/disable clear button
        clearBtn.disabled = stats.sessionCount === 0 || rec;

        if (stats.sessionCount === 0) {
            listEl.innerHTML = `
                <div class="bbSessionEmpty">
                    <div class="icon">üìä</div>
                    No recordings yet.<br>Start recording to capture telemetry data.
                </div>
            `;
            return;
        }

        // Render session list
        listEl.innerHTML = stats.sessions.map(session => {
            const isCurrentRecording = rec && session.sessionId === sessionId;
            const statusClass = isCurrentRecording ? 'active' : (session.status === 'active' ? 'recovered' : 'complete');
            const statusLabel = isCurrentRecording ? '‚óè Recording' : (session.status === 'active' ? '‚ö† Recovered' : '‚óè Complete');

            return `
                <div class="bbSessionItem ${isCurrentRecording ? 'active' : ''}" data-session-id="${session.sessionId}">
                    <div class="bbSessionInfo">
                        <div class="bbSessionDate">${formatSessionDate(session.startTime)}</div>
                        <div class="bbSessionMeta">
                            <span>${session.chunkCount} chunk${session.chunkCount !== 1 ? 's' : ''}</span>
                            <span>${formatBytes(session.estimatedBytes)}</span>
                            <span>${formatSessionDuration(session.durationMs)}</span>
                        </div>
                        <div class="bbSessionStatus ${statusClass}">${statusLabel}</div>
                    </div>
                    <div class="bbSessionActions">
                        <button class="bbSessionBtn" data-action="export">Export</button>
                        <button class="bbSessionBtn danger" data-action="delete" ${isCurrentRecording ? 'disabled' : ''}>Delete</button>
                    </div>
                </div>
            `;
        }).join('');

        // Add event listeners using delegation
        listEl.querySelectorAll('.bbSessionBtn').forEach(btn => {
            btn.onclick = () => handleSessionAction(btn);
        });

    } catch (e) {
        console.error('Failed to load sessions:', e);
        listEl.innerHTML = `
            <div class="bbSessionEmpty">
                <div class="icon">‚ö†Ô∏è</div>
                Error loading recordings
            </div>
        `;
    }
}

async function renderTrackDataList() {
    const listEl = $('track-data-list');
    const clearBtn = $('btn-clear-all-tracks');

    try {
        const stats = await getTrackDataStats();

        // Enable/disable clear button
        clearBtn.disabled = stats.tracks.length === 0;

        if (stats.tracks.length === 0) {
            listEl.innerHTML = `
                <div class="bbSessionEmpty">
                    <div class="icon">üèÅ</div>
                    No tracks saved.<br>Record a track to get started.
                </div>
            `;
            return;
        }

        // Render track list
        listEl.innerHTML = stats.tracks.map(track => {
            const hasRef = track.hasReferenceLap;
            const refInfo = hasRef ?
                `Best: ${formatLapTimeMs(track.referenceLapTime)} (${track.referenceLapSamples} pts)` :
                'No best lap';

            return `
                <div class="bbTrackDataItem" data-track-id="${track.id}">
                    <div class="bbTrackDataInfo">
                        <div class="bbTrackDataName">${track.name}</div>
                        <div class="bbTrackDataMeta">
                            <span>${track.corners} corners</span>
                            <span>${track.points} points</span>
                            <span>${formatBytes(track.totalBytes)}</span>
                        </div>
                        <div class="bbTrackDataRef ${hasRef ? 'has-ref' : 'no-ref'}">${refInfo}</div>
                    </div>
                    <div class="bbTrackDataActions">
                        <button class="bbSessionBtn" data-action="clear-best" ${!hasRef ? 'disabled' : ''}>Clear Best</button>
                        <button class="bbSessionBtn danger" data-action="delete-track">Delete</button>
                    </div>
                </div>
            `;
        }).join('');

        // Add event listeners
        listEl.querySelectorAll('.bbSessionBtn').forEach(btn => {
            btn.onclick = () => handleDataTrackAction(btn);
        });

    } catch (e) {
        console.error('Failed to load tracks:', e);
        listEl.innerHTML = `
            <div class="bbSessionEmpty">
                <div class="icon">‚ö†Ô∏è</div>
                Error loading tracks
            </div>
        `;
    }
}

async function handleSessionAction(btn) {
    const action = btn.dataset.action;
    const item = btn.closest('.bbSessionItem');
    const targetSessionId = parseInt(item.dataset.sessionId, 10);

    if (action === 'export') {
        try {
            btn.textContent = 'Exporting...';
            btn.classList.add('exporting');
            await exportSessionById(targetSessionId);
            btn.textContent = 'Export';
            btn.classList.remove('exporting');
        } catch (err) {
            alert('Export failed: ' + err.message);
            btn.textContent = 'Export';
            btn.classList.remove('exporting');
        }
    } else if (action === 'delete') {
        const dateStr = item.querySelector('.bbSessionDate').textContent;
        if (!confirm(`Delete recording from ${dateStr}?\n\nThis cannot be undone.`)) return;

        try {
            btn.textContent = 'Deleting...';
            btn.classList.add('deleting');
            await deleteSession(targetSessionId);
            await renderDataModal();
        } catch (err) {
            alert('Delete failed: ' + err.message);
            btn.textContent = 'Delete';
            btn.classList.remove('deleting');
        }
    }
}

async function handleDataTrackAction(btn) {
    const action = btn.dataset.action;
    const item = btn.closest('.bbTrackDataItem');
    const trackId = item.dataset.trackId;
    const trackName = item.querySelector('.bbTrackDataName').textContent;

    if (action === 'clear-best') {
        if (!confirm(`Clear best lap for "${trackName}"?\n\nThis cannot be undone.`)) return;

        try {
            btn.textContent = 'Clearing...';
            btn.disabled = true;
            await deleteReferenceLap(trackId);
            await renderDataModal();
        } catch (err) {
            alert('Clear failed: ' + err.message);
            btn.textContent = 'Clear Best';
            btn.disabled = false;
        }
    } else if (action === 'delete-track') {
        if (!confirm(`Delete track "${trackName}" and its best lap?\n\nThis cannot be undone.`)) return;

        try {
            btn.textContent = 'Deleting...';
            btn.classList.add('deleting');
            await deleteTrackWithRef(trackId);
            // If this was the active track, clear it
            if (activeTrack && activeTrack.id === trackId) {
                activeTrack = null;
                lapTimerState = 'idle';
                updateActiveTrackDisplay();
            }
            await renderDataModal();
        } catch (err) {
            alert('Delete failed: ' + err.message);
            btn.textContent = 'Delete';
            btn.classList.remove('deleting');
        }
    }
}

// Menu: Open data modal
$('menu-data').onclick = () => {
    $('menu-overlay').classList.remove('open');
    openDataModal();
};

// Data modal close button
$('data-modal-close').onclick = closeDataModal;

// Close data modal when clicking outside
$('data-modal').onclick = (e) => {
    if (e.target === $('data-modal')) closeDataModal();
};

// Clear all recordings button
$('btn-clear-all-recordings').onclick = async () => {
    if (rec) {
        alert('Cannot clear recordings while recording is active. Stop recording first.');
        return;
    }

    const stats = await getStorageStats();
    if (stats.sessionCount === 0) {
        alert('No recordings to clear.');
        return;
    }

    const confirmed = confirm(
        `Delete all ${stats.sessionCount} recording${stats.sessionCount !== 1 ? 's' : ''}?\n\n` +
        `This will free ${formatBytes(stats.totalBytes)} of storage.\n\n` +
        `This cannot be undone.`
    );

    if (!confirmed) return;

    try {
        const btn = $('btn-clear-all-recordings');
        btn.textContent = 'Clearing...';
        btn.disabled = true;
        await clearAllRecordings();
        await renderDataModal();
        btn.textContent = 'Clear All Recordings';
    } catch (err) {
        alert('Clear failed: ' + err.message);
        const btn = $('btn-clear-all-recordings');
        btn.textContent = 'Clear All Recordings';
        btn.disabled = false;
    }
};

// Clear all tracks button
$('btn-clear-all-tracks').onclick = async () => {
    const stats = await getTrackDataStats();
    if (stats.tracks.length === 0) {
        alert('No tracks to clear.');
        return;
    }

    const confirmed = confirm(
        `Delete all ${stats.tracks.length} track${stats.tracks.length !== 1 ? 's' : ''} and their best laps?\n\n` +
        `This will free ${formatBytes(stats.totalBytes)} of storage.\n\n` +
        `This cannot be undone.`
    );

    if (!confirmed) return;

    try {
        const btn = $('btn-clear-all-tracks');
        btn.textContent = 'Clearing...';
        btn.disabled = true;
        await clearAllTracks();
        // Clear active track if it was deleted
        activeTrack = null;
        lapTimerState = 'idle';
        updateActiveTrackDisplay();
        await renderDataModal();
        btn.textContent = 'Clear All Tracks';
    } catch (err) {
        alert('Clear failed: ' + err.message);
        const btn = $('btn-clear-all-tracks');
        btn.textContent = 'Clear All Tracks';
        btn.disabled = false;
    }
};

// Initialize
setTimeout(() => { resize(); drawG(); }, 50);
openDB().catch(e => console.log('IndexedDB error:', e));
openTrackDB().catch(e => console.log('Track DB error:', e));
</script>
</body></html>
