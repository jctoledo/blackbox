<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><title>Blackbox</title>
<style>
:root{
    --bg:#f2f2f7;
    --surface:#ffffff;
    --text:#1c1c1e;
    --text-secondary:#48484a;
    --text-tertiary:#8e8e93;
    --divider:rgba(0,0,0,.08);
    --ok:#34c759;
    --amber:#ff9500;
    --red:#ff3b30;
    --mode-idle:#8e8e93;
    --mode-accel:#1c1c1e;
    --mode-brake:#ff3b30;
}
.dark{
    --bg:#000000;
    --surface:#1c1c1e;
    --text:#ffffff;
    --text-secondary:#aeaeb2;
    --text-tertiary:#636366;
    --divider:rgba(255,255,255,.08);
    --mode-idle:#636366;
    --mode-accel:#ffffff;
    --mode-brake:#ff3b30;
}
*{margin:0;padding:0;box-sizing:border-box}
body{
    font-family:-apple-system,BlinkMacSystemFont,'SF Pro Text','SF Pro Display',system-ui,sans-serif;
    background:var(--bg);
    color:var(--text);
    height:100vh;
    height:100dvh;
    display:flex;
    flex-direction:column;
    -webkit-user-select:none;
    user-select:none;
    overflow:hidden;
    transition:background 0.3s,color 0.3s;
}

.bbNum{
    font-variant-numeric:tabular-nums;
    font-feature-settings:"tnum" 1,"lnum" 1;
}

/* HEADER */
.bbTopbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:14px 16px;
    background:transparent;
    flex-shrink:0;
}
.bbBrandToggle{
    background:none;
    border:0;
    padding:0;
    display:flex;
    align-items:baseline;
    gap:8px;
    cursor:pointer;
    color:inherit;
    font-family:inherit;
}
.bbBrand{font-size:11px;font-weight:600;opacity:.55;letter-spacing:.03em}
.bbModeLabel{font-size:11px;font-weight:400;opacity:.40;letter-spacing:.03em}
.bbModeIcon{font-size:10px;opacity:.40}
.bbTopRight{
    display:flex;
    align-items:center;
    gap:10px;
}
.bbStatusCluster{
    display:flex;
    align-items:center;
    gap:12px;
    opacity:.55;
    font-size:10px;
    letter-spacing:.03em;
}
.bbStatusItem{display:flex;align-items:center;gap:4px}
.bbStatusItem .bbHigh{margin-right:2px}
.bbDot{width:6px;height:6px;border-radius:50%;background:var(--ok);display:inline-block;opacity:.9;margin-right:2px}
.bbHigh{color:var(--ok);font-weight:600}
.bbKebab{background:none;border:0;padding:4px;font-size:24px;line-height:1;opacity:.6;cursor:pointer;color:inherit}

/* APP CONTAINER */
.bbApp{
    flex:1;
    display:flex;
    flex-direction:column;
    padding:0 12px 8px;
    min-height:0;
}

/* CARD */
.bbCard{
    background:var(--surface);
    border-radius:16px;
    overflow:hidden;
}
.bbGCard{
    flex:1;
    display:flex;
    flex-direction:column;
    margin-bottom:4px;
}

/* TOP ROW */
.bbGTop{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    padding:12px 18px 6px;
    flex-shrink:0;
}
.bbGTopLeft{}
.bbSpeedLine{display:flex;align-items:baseline;gap:4px}
.bbSpeed{font-size:22px;font-weight:600;opacity:.75;transition:color 0.3s,opacity 0.3s}
.bbSpeed.peak{color:var(--amber);opacity:1}
.bbUnit{font-size:12px;opacity:.45}
.bbManeuver{font-size:14px;font-weight:600;margin-top:4px;min-width:7ch;transition:color 0.15s}
.bbGTopRight{font-size:11px;opacity:.50}

/* PLOT AREA */
.bbGPlotWrap{
    display:flex;
    justify-content:center;
    padding:2px 18px 0;
}
.bbGPlotFrame{
    position:relative;
    width:min(560px, 100%);
    aspect-ratio:1/1;
}
.bbGPlot{
    display:block;
    width:100%;
    height:100%;
}

/* AXIS LABELS */
.bbAxis{
    position:absolute;
    font-size:10px;
    font-weight:500;
    letter-spacing:.02em;
    text-transform:uppercase;
    opacity:.50;
    color:var(--text-tertiary);
    pointer-events:none;
}
.bbAxis--top{top:4px;left:50%;transform:translateX(-50%)}
.bbAxis--bottom{bottom:4px;left:50%;transform:translateX(-50%)}
.bbAxis--left{left:6px;top:50%;transform:translateY(-50%)}
.bbAxis--right{right:6px;top:50%;transform:translateY(-50%)}

.bbPlotMeta{
    position:absolute;
    top:6px;
    right:8px;
    font-size:10px;
    color:var(--text-tertiary);
    opacity:.50;
}

/* READOUT ROW */
.bbGReadoutRow{
    display:flex;
    justify-content:center;
    align-items:center;
    gap:0;
    padding:16px 18px;
    flex-shrink:0;
    margin:auto 0;
}
.bbGReadoutCol{
    flex:1;
    display:flex;
    flex-direction:column;
    align-items:center;
    text-align:center;
}
.bbGReadoutLbl{
    font-size:11px;
    letter-spacing:.02em;
    text-transform:uppercase;
    opacity:.55;
    color:var(--text-tertiary);
}
.bbGReadoutVal{
    margin-top:8px;
    font-size:34px;
    font-weight:600;
    line-height:1.0;
    min-width:8ch;
    display:inline-flex;
    align-items:baseline;
    justify-content:center;
    gap:2px;
}
.bbSign{display:inline-block;width:1.2ch;text-align:right;opacity:.9;margin-right:2px}
.bbGUnit{font-size:.5em;opacity:.55;margin-left:2px}
.bbGDivider{
    width:1px;
    height:48px;
    background:var(--divider);
    margin:0 12px;
    flex-shrink:0;
}

/* MAX STRIP */
.bbGMax{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px 16px;
    padding:16px 24px 20px;
    border-top:1px solid var(--divider);
    flex-shrink:0;
}
.bbMini{
    display:grid;
    grid-template-columns:auto 7ch;
    column-gap:10px;
    align-items:baseline;
}
.bbMiniLbl{font-size:11px;color:var(--text-tertiary);opacity:.75;white-space:nowrap}
.bbMiniVal{font-size:13px;font-weight:600;color:var(--text-secondary);text-align:left;justify-self:start}

/* CSV PROGRESS BAR */
.bbCsvRow{
    display:none;
    align-items:center;
    gap:10px;
    padding:10px 24px;
    border-top:1px solid var(--divider);
}
.bbCsvRow.visible{display:flex}
.bbCsvName{font-size:10px;color:var(--text-tertiary);max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.bbCsvProgress{
    flex:1;
    height:6px;
    background:var(--divider);
    border-radius:3px;
    cursor:pointer;
    position:relative;
}
.bbCsvBar{
    height:100%;
    background:var(--ok);
    width:0%;
    border-radius:3px;
    transition:width 0.1s linear;
}
.bbCsvTime{font-size:10px;color:var(--text-tertiary);font-variant-numeric:tabular-nums;min-width:70px;text-align:right}

/* TELEMETRY STRIP */
.bbTelemetryStrip{
    display:flex;
    gap:14px;
    justify-content:center;
    padding:14px 0 10px;
    font-size:11px;
    color:var(--text-tertiary);
    flex-shrink:0;
}
.bbTItem{display:flex;align-items:baseline;gap:3px}
.bbTItem .bbNum{color:var(--text-secondary);font-weight:500;display:inline-block;text-align:right}
.bbNum--hz{min-width:2.5ch}
.bbNum--gps{min-width:2ch}
.bbNum--drops{min-width:2ch}
.bbNum--yaw{min-width:3ch}

/* MENU */
.bbMenuOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.25);
    opacity:0;
    visibility:hidden;
    transition:opacity 0.15s ease;
    z-index:100;
}
.dark .bbMenuOverlay{background:rgba(0,0,0,0.5)}
.bbMenuOverlay.open{opacity:1;visibility:visible}
.bbMenuPanel{
    position:fixed;
    top:44px;
    right:12px;
    background:var(--surface);
    border-radius:12px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    min-width:180px;
    transform:scale(0.95);
    opacity:0;
    transition:transform 0.15s ease,opacity 0.15s ease;
    z-index:101;
    overflow:hidden;
}
.dark .bbMenuPanel{box-shadow:0 4px 20px rgba(0,0,0,0.4)}
.bbMenuOverlay.open .bbMenuPanel{transform:scale(1);opacity:1}
.bbMenuItem{
    display:block;
    width:100%;
    padding:14px 18px;
    font-size:15px;
    text-align:left;
    border:none;
    background:none;
    color:var(--text);
    cursor:pointer;
    border-bottom:0.5px solid var(--divider);
    font-family:inherit;
}
.bbMenuItem:last-child{border-bottom:none}
.bbMenuItem:active{background:var(--bg)}
.bbMenuItem.destructive{color:var(--red)}

/* LAP TIMER SECTION */
.bbLapCard{
    background:var(--surface);
    border-radius:16px;
    margin-bottom:8px;
    overflow:hidden;
}
.bbLapCard.inactive{
    padding:14px 18px;
}
.bbLapCard.active{
    padding:0;
}
.bbLapSetup{
    display:flex;
    justify-content:space-between;
    align-items:center;
}
.bbLapSetupText{
    font-size:13px;
    color:var(--text-tertiary);
}
.bbLapSetupBtn{
    background:var(--bg);
    border:none;
    border-radius:8px;
    padding:8px 16px;
    font-size:13px;
    font-weight:600;
    color:var(--text);
    cursor:pointer;
    font-family:inherit;
}
.bbLapSetupBtn:active{opacity:0.7}

.bbLapActive{display:none}
.bbLapCard.active .bbLapActive{display:block}
.bbLapCard.active .bbLapSetup{display:none}

.bbLapMain{
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:16px 18px 12px;
}
.bbLapTime{
    font-size:44px;
    font-weight:600;
    line-height:1;
}
.bbLapMeta{
    display:flex;
    align-items:center;
    gap:12px;
    margin-top:6px;
}
.bbLapCount{
    font-size:13px;
    color:var(--text-tertiary);
    opacity:0.7;
}
.bbLapState{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:0.04em;
    color:var(--text-tertiary);
    opacity:0.5;
}
.bbLapState.timing{color:var(--ok);opacity:0.9}

.bbLapHistory{
    display:flex;
    justify-content:center;
    gap:0;
    padding:12px 18px;
    border-top:1px solid var(--divider);
}
.bbLapHistItem{
    flex:1;
    display:flex;
    flex-direction:column;
    align-items:center;
}
.bbLapHistDivider{
    width:1px;
    height:36px;
    background:var(--divider);
}
.bbLapHistLabel{
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:0.02em;
    color:var(--text-tertiary);
    opacity:0.55;
}
.bbLapHistValue{
    font-size:20px;
    font-weight:600;
    margin-top:4px;
}
.bbLapHistValue.best{color:var(--ok)}
.bbLapHistValue.delta{font-size:18px}
.bbLapHistValue.delta.faster{color:var(--ok)}
.bbLapHistValue.delta.slower{color:var(--red)}

.bbLapFlash{
    animation:lapFlash 0.6s ease-out;
}
@keyframes lapFlash{
    0%{background:rgba(52,199,89,0.25)}
    100%{background:var(--surface)}
}
.bbLapBestFlash{
    animation:bestFlash 0.8s ease-out;
}
@keyframes bestFlash{
    0%,30%{transform:scale(1.05)}
    100%{transform:scale(1)}
}

/* START LINE APPROACH INDICATOR */
.bbStartLineIndicator{
    display:none;
    padding:10px 16px;
    border-top:1px solid var(--divider);
    text-align:center;
}
.bbLapCard.active .bbStartLineIndicator{display:block}
.bbLapCard.active.timing .bbStartLineIndicator{display:none}
.bbStartLineText{
    font-size:14px;
    color:var(--text-secondary);
    font-weight:500;
}
.bbStartLineText.approaching{color:var(--yellow)}
.bbStartLineText.close{color:var(--ok)}
.bbStartLineText.at-line{
    color:var(--ok);
    font-weight:600;
    animation:pulseText 1s ease-in-out infinite;
}
@keyframes pulseText{
    0%,100%{opacity:1}
    50%{opacity:0.6}
}
.bbStartLineArrow{
    display:inline-block;
    margin-left:6px;
    font-size:16px;
}

/* TRACK MANAGER MODAL */
.bbModal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.4);
    display:flex;
    align-items:center;
    justify-content:center;
    opacity:0;
    visibility:hidden;
    transition:opacity 0.2s ease;
    z-index:200;
    padding:16px;
}
.dark .bbModal{background:rgba(0,0,0,0.6)}
.bbModal.open{opacity:1;visibility:visible}
.bbModalContent{
    background:var(--surface);
    border-radius:16px;
    width:100%;
    max-width:400px;
    max-height:calc(100vh - 32px);
    overflow:hidden;
    display:flex;
    flex-direction:column;
    transform:scale(0.95);
    transition:transform 0.2s ease;
}
.bbModal.open .bbModalContent{transform:scale(1)}
.bbModalHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 18px;
    border-bottom:1px solid var(--divider);
}
.bbModalTitle{
    font-size:17px;
    font-weight:600;
}
.bbModalClose{
    background:none;
    border:none;
    font-size:24px;
    color:var(--text-tertiary);
    cursor:pointer;
    padding:0;
    line-height:1;
}
.bbModalClose:active{opacity:0.5}
.bbModalBody{
    padding:16px 18px;
    overflow-y:auto;
    flex:1;
}
.bbModalSection{
    margin-bottom:20px;
}
.bbModalSection:last-child{margin-bottom:0}
.bbSectionTitle{
    font-size:11px;
    font-weight:600;
    color:var(--text-tertiary);
    text-transform:uppercase;
    letter-spacing:0.08em;
    margin-bottom:10px;
}
.bbPosDisplay{
    background:var(--bg);
    border-radius:12px;
    padding:14px 16px;
}
.bbPosRow{
    display:flex;
    justify-content:space-between;
    align-items:baseline;
    padding:4px 0;
}
.bbPosLabel{
    font-size:12px;
    color:var(--text-tertiary);
}
.bbPosValue{
    font-size:14px;
    font-weight:600;
    font-variant-numeric:tabular-nums;
}
.bbPosValue.waiting{
    color:var(--text-tertiary);
    font-weight:400;
}
.bbActionBtn{
    display:block;
    width:100%;
    padding:14px 18px;
    border:none;
    border-radius:12px;
    font-size:15px;
    font-weight:600;
    cursor:pointer;
    font-family:inherit;
    margin-bottom:10px;
    transition:opacity 0.15s;
}
.bbActionBtn:last-child{margin-bottom:0}
.bbActionBtn:active{opacity:0.7}
.bbActionBtn.primary{
    background:var(--ok);
    color:#fff;
}
.bbActionBtn.secondary{
    background:var(--bg);
    color:var(--text);
}
.bbActionBtn:disabled{
    opacity:0.4;
    cursor:not-allowed;
}
.bbTrackList{
    border-radius:12px;
    overflow:hidden;
    background:var(--bg);
}
.bbTrackEmpty{
    padding:20px;
    text-align:center;
    color:var(--text-tertiary);
    font-size:13px;
}
.bbTrackItem{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 14px;
    border-bottom:1px solid var(--divider);
}
.bbTrackItem:last-child{border-bottom:none}
.bbTrackInfo{flex:1;min-width:0}
.bbTrackName{
    font-size:14px;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
}
.bbTrackMeta{
    font-size:11px;
    color:var(--text-tertiary);
    margin-top:2px;
}
.bbTrackMeta span{margin-right:10px}
.bbTrackActions{
    display:flex;
    gap:8px;
    margin-left:10px;
}
.bbTrackBtn{
    background:var(--surface);
    border:none;
    border-radius:6px;
    padding:6px 12px;
    font-size:12px;
    font-weight:600;
    color:var(--text);
    cursor:pointer;
    font-family:inherit;
}
.bbTrackBtn:active{opacity:0.7}
.bbTrackBtn.primary{
    background:var(--ok);
    color:#fff;
}
.bbTrackBtn.danger{
    color:var(--red);
}
.bbActiveTrack{
    background:var(--bg);
    border-radius:12px;
    padding:14px 16px;
    margin-bottom:16px;
}
.bbActiveTrackLabel{
    font-size:11px;
    color:var(--text-tertiary);
    text-transform:uppercase;
    letter-spacing:0.05em;
}
.bbActiveTrackName{
    font-size:15px;
    font-weight:600;
    margin-top:4px;
}
.bbActiveTrackMeta{
    font-size:12px;
    color:var(--text-tertiary);
    margin-top:2px;
}
</style></head>
<body>

<header class="bbTopbar">
    <button class="bbBrandToggle" id="brandToggle" aria-label="Toggle theme">
        <span class="bbBrand">Blackbox</span>
        <span class="bbModeLabel" id="modeLabel">Bright</span>
        <span class="bbModeIcon" aria-hidden="true">◐</span>
    </button>
    <div class="bbTopRight">
        <div class="bbStatusCluster">
            <span class="bbStatusItem" id="sourceLabel"><span class="bbHigh">SIM</span></span>
            <span class="bbStatusItem"><span class="bbDot"></span>GPS</span>
            <span class="bbStatusItem"><span class="bbDot"></span>IMU</span>
        </div>
        <button class="bbKebab" id="menu-btn" aria-label="Menu">⋮</button>
    </div>
</header>

<main class="bbApp">
    <!-- Lap Timer Section -->
    <section class="bbCard bbLapCard inactive" id="lap-section">
        <div class="bbLapSetup" id="lap-setup">
            <span class="bbLapSetupText" id="lap-setup-text">No track configured</span>
            <button class="bbLapSetupBtn" id="btn-open-tracks">Tracks</button>
        </div>
        <div class="bbLapActive" id="lap-active">
            <div class="bbLapMain">
                <div class="bbLapTime bbNum" id="lap-time">0:00.000</div>
                <div class="bbLapMeta">
                    <span class="bbLapCount" id="lap-count">Lap 0</span>
                    <span class="bbLapState" id="lap-state">Armed</span>
                </div>
            </div>
            <div class="bbLapHistory">
                <div class="bbLapHistItem">
                    <span class="bbLapHistLabel">Best</span>
                    <span class="bbLapHistValue bbNum" id="best-lap">—:——</span>
                </div>
                <div class="bbLapHistDivider"></div>
                <div class="bbLapHistItem">
                    <span class="bbLapHistLabel">Last</span>
                    <span class="bbLapHistValue bbNum" id="last-lap">—:——</span>
                </div>
                <div class="bbLapHistDivider"></div>
                <div class="bbLapHistItem">
                    <span class="bbLapHistLabel">Delta</span>
                    <span class="bbLapHistValue bbNum delta" id="lap-delta">—</span>
                </div>
            </div>
            <div class="bbStartLineIndicator" id="start-line-indicator">
                <span class="bbStartLineText" id="start-line-text">Calculating...</span>
            </div>
        </div>
    </section>

    <section class="bbCard bbGCard">
        <div class="bbGTop">
            <div class="bbGTopLeft">
                <div class="bbSpeedLine"><span class="bbSpeed bbNum" id="speed">0</span><span class="bbUnit">km/h</span></div>
                <div class="bbManeuver" id="maneuver">IDLE</div>
            </div>
            <div class="bbGTopRight"><span class="bbNum" id="session-time">0:00</span></div>
        </div>

        <div class="bbGPlotWrap">
            <div class="bbGPlotFrame">
                <div class="bbAxis bbAxis--top">Accel</div>
                <div class="bbAxis bbAxis--bottom">Brake</div>
                <div class="bbAxis bbAxis--left">Left</div>
                <div class="bbAxis bbAxis--right">Right</div>
                <div class="bbPlotMeta" id="range-val">Range ±0.5g</div>
                <canvas class="bbGPlot" id="gcanvas"></canvas>
            </div>
        </div>

        <div class="bbGReadoutRow">
            <div class="bbGReadoutCol">
                <div class="bbGReadoutLbl">Lat</div>
                <div class="bbGReadoutVal bbNum" id="lat-g"><span class="bbSign">+</span><span class="bbVal">0.00</span><span class="bbGUnit">g</span></div>
            </div>
            <div class="bbGDivider"></div>
            <div class="bbGReadoutCol">
                <div class="bbGReadoutLbl">Long</div>
                <div class="bbGReadoutVal bbNum" id="lon-g"><span class="bbSign">+</span><span class="bbVal">0.00</span><span class="bbGUnit">g</span></div>
            </div>
        </div>

        <div class="bbGMax">
            <div class="bbMini"><span class="bbMiniLbl">Max Lat L</span><span class="bbMiniVal bbNum" id="max-l">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Lat R</span><span class="bbMiniVal bbNum" id="max-r">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Acc</span><span class="bbMiniVal bbNum" id="max-a">0.00g</span></div>
            <div class="bbMini"><span class="bbMiniLbl">Max Brk</span><span class="bbMiniVal bbNum" id="max-b">0.00g</span></div>
        </div>

        <!-- CSV Progress Bar -->
        <div class="bbCsvRow" id="csv-row">
            <span class="bbCsvName" id="csv-name"></span>
            <div class="bbCsvProgress" id="csv-progress">
                <div class="bbCsvBar" id="csv-bar"></div>
            </div>
            <span class="bbCsvTime" id="csv-time">0:00 / 0:00</span>
        </div>
    </section>

    <div class="bbTelemetryStrip">
        <span class="bbTItem"><span class="bbNum bbNum--hz" id="hz">30</span> Hz</span>
        <span class="bbTItem">GPS <span class="bbNum bbNum--gps" id="gps-acc">2</span>m</span>
        <span class="bbTItem">Drops <span class="bbNum bbNum--drops" id="drops">0</span></span>
        <span class="bbTItem">Yaw <span class="bbNum bbNum--yaw" id="yaw">0</span>°</span>
    </div>
</main>

<div class="bbMenuOverlay" id="menu-overlay">
    <div class="bbMenuPanel">
        <button class="bbMenuItem" id="menu-tracks">Tracks</button>
        <button class="bbMenuItem" id="menu-lap">Simulate Track</button>
        <button class="bbMenuItem" id="menu-load">Load CSV</button>
        <button class="bbMenuItem" id="menu-sim">Back to Sim</button>
        <button class="bbMenuItem" id="menu-rec">Start Recording</button>
        <button class="bbMenuItem" id="menu-export">Export CSV</button>
        <button class="bbMenuItem destructive" id="menu-clear">Clear Session</button>
    </div>
</div>

<!-- Track Manager Modal -->
<div class="bbModal" id="track-modal">
    <div class="bbModalContent">
        <div class="bbModalHeader">
            <span class="bbModalTitle">Track Manager</span>
            <button class="bbModalClose" id="track-modal-close">&times;</button>
        </div>
        <div class="bbModalBody">
            <!-- Active Track (if any) -->
            <div id="active-track-section" class="bbActiveTrack" style="display:none">
                <div class="bbActiveTrackLabel">Active Track</div>
                <div class="bbActiveTrackName" id="active-track-name">—</div>
                <div class="bbActiveTrackMeta" id="active-track-meta">—</div>
            </div>

            <!-- Current Position -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Current Position</div>
                <div class="bbPosDisplay">
                    <div class="bbPosRow">
                        <span class="bbPosLabel">Local X, Y</span>
                        <span class="bbPosValue" id="pos-xy">0.0, 0.0 m</span>
                    </div>
                    <div class="bbPosRow">
                        <span class="bbPosLabel">Heading</span>
                        <span class="bbPosValue" id="pos-heading">0°</span>
                    </div>
                    <div class="bbPosRow">
                        <span class="bbPosLabel">Speed</span>
                        <span class="bbPosValue" id="pos-speed">0 km/h</span>
                    </div>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Quick Actions</div>
                <button class="bbActionBtn primary" id="btn-set-start" disabled>
                    Set Start Line Here
                </button>
                <button class="bbActionBtn secondary" id="btn-clear-track">
                    Clear Active Track
                </button>
            </div>

            <!-- Saved Tracks -->
            <div class="bbModalSection">
                <div class="bbSectionTitle">Saved Tracks</div>
                <div class="bbTrackList" id="track-list">
                    <div class="bbTrackEmpty">No saved tracks</div>
                </div>
            </div>
        </div>
    </div>
</div>

<input type="file" id="csv-input" accept=".csv" style="display:none">

<script>
const CANYON_KEYFRAMES = [
    [0,      55,    0.15,  0.05,  3],
    [1300,   70,    0.30,  0.02,  1],
    [2300,   75,    0.10,  0.05,  5],
    [3000,   68,   -0.35,  0.10,  8],
    [3700,   55,   -0.20,  0.35,  25],
    [4700,   52,    0.05,  0.45,  32],
    [5700,   58,    0.25,  0.30,  20],
    [6700,   70,    0.30,  0.10,  6],
    [7700,   78,    0.15,  0.02,  0],
    [8700,   72,   -0.40,  -0.05, -3],
    [9700,   55,   -0.25,  -0.40, -30],
    [11000,  45,    0.05,  -0.55, -40],
    [12300,  50,    0.30,  -0.40, -28],
    [13300,  62,    0.25,  -0.15, -10],
    [14300,  65,    0.10,  0.25,  18],
    [15000,  60,    0.05,  -0.20, -15],
    [15700,  62,    0.15,  0.20,  14],
    [16700,  72,    0.30,  0.05,  2],
    [17700,  78,   -0.25,  -0.10, -8],
    [18700,  65,    0.05,  -0.42, -32],
    [20000,  55,    0.15,  0.05,  3],
];
const LOOP_DURATION = 20000;

// ============================================================================
// SIMULATED TRACK PATH - A rectangular block loop for geometry-based lap timing
// Format: [cumulative_distance_m, x_m, y_m, heading_rad]
// Total length ~283m, completes in 20s at ~14 m/s (51 km/h) average
//
// Track layout (birds-eye view):
//
//        (10,60)-------- 60m --------(70,60)
//           |                           |
//   Corner1 |                           | Corner2
//           |                           |
//        (0,50)                      (80,50)
//           |                           |
//    50m    |                           | 50m
//           |                           |
//        (0,0) START                 (80,0)
//           |                           |
//   Corner4 |                           | Corner3
//           |                           |
//       (10,-10)------- 60m --------(70,-10)
//
// Direction: clockwise (right-hand turns)
// ============================================================================
const BLOCK_TRACK = (() => {
    const waypoints = [];
    let d = 0;  // Cumulative distance
    const r = 10;  // Corner radius
    const cornerSteps = 8;
    const arcLength = (Math.PI * r / 2);  // Quarter circle

    // Helper: add corner waypoints
    // startAngle/endAngle are angles FROM the center TO the position on the arc
    function addCorner(cx, cy, startAngle, endAngle) {
        for (let i = 1; i <= cornerSteps; i++) {
            const t = i / cornerSteps;
            const angle = startAngle + t * (endAngle - startAngle);
            const x = cx + r * Math.cos(angle);
            const y = cy + r * Math.sin(angle);
            // Heading is tangent to circle (perpendicular to radius, in direction of travel)
            // For clockwise travel, heading = angle - PI/2
            const heading = angle - Math.PI / 2;
            d += arcLength / cornerSteps;
            waypoints.push([d, x, y, heading]);
        }
    }

    // === Leg 1: Start at (0,0) heading north, go to (0,50) ===
    for (let i = 0; i <= 10; i++) {
        const y = i * 5;
        waypoints.push([d, 0, y, Math.PI / 2]);
        if (i < 10) d += 5;
    }

    // === Corner 1: Right turn at (0,50) → (10,60) ===
    // Center at (10, 50), turn from angle PI (west of center) to PI/2 (north of center)
    addCorner(10, 50, Math.PI, Math.PI / 2);

    // === Leg 2: East from (10,60) to (70,60) ===
    for (let i = 1; i <= 12; i++) {
        const x = 10 + i * 5;
        d += 5;
        waypoints.push([d, x, 60, 0]);  // Heading east
    }

    // === Corner 2: Right turn at (70,60) → (80,50) ===
    // Center at (70, 50), turn from angle PI/2 (north of center) to 0 (east of center)
    addCorner(70, 50, Math.PI / 2, 0);

    // === Leg 3: South from (80,50) to (80,0) ===
    for (let i = 1; i <= 10; i++) {
        const y = 50 - i * 5;
        d += 5;
        waypoints.push([d, 80, y, -Math.PI / 2]);  // Heading south
    }

    // === Corner 3: Right turn at (80,0) → (70,-10) ===
    // Center at (70, 0), turn from angle 0 (east of center) to -PI/2 (south of center)
    addCorner(70, 0, 0, -Math.PI / 2);

    // === Leg 4: West from (70,-10) to (10,-10) ===
    for (let i = 1; i <= 12; i++) {
        const x = 70 - i * 5;
        d += 5;
        waypoints.push([d, x, -10, Math.PI]);  // Heading west
    }

    // === Corner 4: Right turn at (10,-10) → (0,0) ===
    // Center at (10, 0), turn from angle -PI/2 (south of center) to PI (west of center)
    // Note: -PI/2 to PI goes through -PI, so we use -PI/2 to -PI then wrap
    addCorner(10, 0, -Math.PI / 2, -Math.PI);

    // Final point at exactly (0, 0) heading north
    const lastWp = waypoints[waypoints.length - 1];
    const distToStart = Math.sqrt(lastWp[1] * lastWp[1] + lastWp[2] * lastWp[2]);
    if (distToStart > 0.1) {
        d += distToStart;
        waypoints.push([d, 0, 0, Math.PI / 2]);
    }

    return {
        waypoints,
        totalLength: d
    };
})();

// ============================================================================
// GEOMETRY FUNCTIONS (ported from lap_timer.rs)
// ============================================================================

/**
 * Line segment intersection test using parametric form
 * Tests if segment (p1->p2) intersects segment (p3->p4)
 * @returns {number|null} Parameter t along first segment if intersection, null otherwise
 */
function lineSegmentIntersection(p1, p2, p3, p4) {
    const d1x = p2[0] - p1[0];
    const d1y = p2[1] - p1[1];
    const d2x = p4[0] - p3[0];
    const d2y = p4[1] - p3[1];

    // Cross product of direction vectors
    const cross = d1x * d2y - d1y * d2x;

    // Parallel or nearly parallel lines
    if (Math.abs(cross) < 1e-10) {
        return null;
    }

    // Vector from p1 to p3
    const dx = p3[0] - p1[0];
    const dy = p3[1] - p1[1];

    // Solve for t and u
    const t = (dx * d2y - dy * d2x) / cross;
    const u = (dx * d1y - dy * d1x) / cross;

    // Check if intersection is within both segments
    const EPSILON = 1e-6;
    if (t >= -EPSILON && t <= 1 + EPSILON && u >= -EPSILON && u <= 1 + EPSILON) {
        return Math.max(0, Math.min(1, t));
    }
    return null;
}

/**
 * Normalize angle to [-π, π]
 */
function wrapAngle(angle) {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
}

/**
 * Check if velocity direction is within tolerance of expected crossing direction
 * @param {Array} velocity - [vx, vy] in m/s
 * @param {number} expectedDir - Expected direction in radians
 * @param {number} tolerance - Maximum deviation in radians (default ±90°)
 * @returns {boolean}
 */
function directionValid(velocity, expectedDir, tolerance = Math.PI / 2) {
    const speedSq = velocity[0] * velocity[0] + velocity[1] * velocity[1];
    if (speedSq < 0.01) return false;  // Too slow to determine direction

    const velDir = Math.atan2(velocity[1], velocity[0]);
    const diff = wrapAngle(velDir - expectedDir);

    return Math.abs(diff) <= tolerance;
}

/**
 * Interpolate position along the block track based on elapsed time
 * @param {number} elapsedMs - Elapsed time since loop start
 * @returns {{x: number, y: number, vx: number, vy: number, heading: number, speed: number}}
 */
function getSimulatedPosition(elapsedMs) {
    const loopTime = elapsedMs % LOOP_DURATION;
    const progress = loopTime / LOOP_DURATION;  // 0 to 1

    // Distance traveled along track
    const totalDist = BLOCK_TRACK.totalLength;
    const targetDist = progress * totalDist;

    // Find the two waypoints we're between
    const wps = BLOCK_TRACK.waypoints;
    let i = 0;
    while (i < wps.length - 1 && wps[i + 1][0] < targetDist) {
        i++;
    }

    if (i >= wps.length - 1) {
        // At end, return last point
        const wp = wps[wps.length - 1];
        return { x: wp[1], y: wp[2], vx: 0, vy: 15, heading: wp[3], speed: 15 };
    }

    // Interpolate between waypoints
    const wp1 = wps[i];
    const wp2 = wps[i + 1];
    const segmentLength = wp2[0] - wp1[0];
    const t = segmentLength > 0 ? (targetDist - wp1[0]) / segmentLength : 0;

    const x = wp1[1] + t * (wp2[1] - wp1[1]);
    const y = wp1[2] + t * (wp2[2] - wp1[2]);

    // Calculate velocity from segment direction
    const dx = wp2[1] - wp1[1];
    const dy = wp2[2] - wp1[2];
    const segLen = Math.sqrt(dx * dx + dy * dy);

    // Speed varies with the canyon keyframes for realism
    const auto = getAutoValues(elapsedMs);
    const speed = auto.speed / 3.6;  // km/h to m/s

    // Velocity direction follows track
    const heading = segLen > 0 ? Math.atan2(dy, dx) : wp1[3];
    const vx = speed * Math.cos(heading);
    const vy = speed * Math.sin(heading);

    return { x, y, vx, vy, heading, speed };
}

// ============================================================================
// TIMING LINE STATE
// ============================================================================
let simTimingLine = null;  // {p1: [x,y], p2: [x,y], direction: radians}
let simPrevPos = null;     // Previous position for crossing detection

const $ = id => document.getElementById(id);
const MODES = {0:'IDLE', 1:'ACCEL', 2:'BRAKE', 4:'CORNER', 5:'ACCEL', 6:'BRAKE'};
const MODE_COLORS = {
    0: 'var(--mode-idle)',
    1: 'var(--mode-accel)',
    2: 'var(--mode-brake)',
    4: 'var(--mode-idle)',
    5: 'var(--mode-accel)',
    6: 'var(--mode-brake)'
};

function getModeColorsHex() {
    return {
        0: isDark ? '#636366' : '#8e8e93',
        1: isDark ? '#ffffff' : '#1c1c1e',
        2: '#ff3b30',
        4: isDark ? '#636366' : '#8e8e93',
        5: isDark ? '#ffffff' : '#1c1c1e',
        6: '#ff3b30'
    };
}

let currentModeColor = '#8e8e93';

function catmullRom(p0, p1, p2, p3, t) {
    const t2 = t * t, t3 = t2 * t;
    return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3);
}

function getKeyframeInterp(timeMs) {
    const loopTime = timeMs % LOOP_DURATION;
    let i1 = 0;
    for (let i = 0; i < CANYON_KEYFRAMES.length - 1; i++) {
        if (loopTime >= CANYON_KEYFRAMES[i][0] && loopTime < CANYON_KEYFRAMES[i + 1][0]) { i1 = i; break; }
    }
    const kf0 = CANYON_KEYFRAMES[(i1 - 1 + CANYON_KEYFRAMES.length) % CANYON_KEYFRAMES.length];
    const kf1 = CANYON_KEYFRAMES[i1];
    const kf2 = CANYON_KEYFRAMES[(i1 + 1) % CANYON_KEYFRAMES.length];
    const kf3 = CANYON_KEYFRAMES[(i1 + 2) % CANYON_KEYFRAMES.length];
    const segDur = (kf2[0] - kf1[0] + LOOP_DURATION) % LOOP_DURATION || LOOP_DURATION;
    const t = Math.max(0, Math.min(1, (loopTime - kf1[0]) / segDur));
    return { kf0, kf1, kf2, kf3, t };
}

function getAutoValues(timeMs) {
    const { kf0, kf1, kf2, kf3, t } = getKeyframeInterp(timeMs);
    return {
        speed: catmullRom(kf0[1], kf1[1], kf2[1], kf3[1], t),
        lonG: catmullRom(kf0[2], kf1[2], kf2[2], kf3[2], t),
        latG: catmullRom(kf0[3], kf1[3], kf2[3], kf3[3], t),
        yawDeg: catmullRom(kf0[4], kf1[4], kf2[4], kf3[4], t)
    };
}

function addNoise(val, amount) { return val + (Math.random() - 0.5) * amount * 0.15; }

// === CSV REPLAY ===
let dataSource = 'loop';
let csvData = null;
let csvFileName = '';
let csvPlaybackIndex = 0;
let csvStartTime = 0;
let csvDuration = 0;

function parseCSV(text) {
    const lines = text.trim().split('\n');
    const data = [];
    // Parse header to find column indices
    const header = lines[0].split(',').map(h => h.trim().toLowerCase());
    const posXIdx = header.indexOf('pos_x');
    const posYIdx = header.indexOf('pos_y');
    const hasPosition = posXIdx !== -1 && posYIdx !== -1;

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        if (values.length < 8) continue;
        const row = {
            t: parseFloat(values[0]),
            speed: parseFloat(values[1]),
            latG: parseFloat(values[6]),
            lonG: parseFloat(values[7]),
            yawRad: parseFloat(values[4]),
            mode: parseInt(values[5]) || 0,
            px: hasPosition ? parseFloat(values[posXIdx]) || 0 : 0,
            py: hasPosition ? parseFloat(values[posYIdx]) || 0 : 0,
            hasPosition: hasPosition
        };
        data.push(row);
    }
    if (data.length > 0) {
        const startT = data[0].t;
        data.forEach(d => d.relativeT = d.t - startT);
    }
    return data;
}

function loadCSVData(text, filename) {
    csvData = parseCSV(text);
    if (csvData.length === 0) { alert('No valid data in CSV'); return; }
    csvFileName = filename;
    csvDuration = csvData[csvData.length - 1].relativeT;
    csvPlaybackIndex = 0;
    csvStartTime = Date.now();
    dataSource = 'csv';

    // Check if CSV has position data
    const hasPosition = csvData.length > 0 && csvData[0].hasPosition;
    if (lapTimerActive && !hasPosition) {
        // Deactivate lap timer when loading CSV without position data
        deactivateLapTimer();
        console.log('Lap timer deactivated: CSV has no position data');
    } else if (hasPosition) {
        // Clear previous position for fresh crossing detection
        simPrevPos = null;
        console.log('CSV has position data - lap timing available');
    }

    resetState();
    updateSourceUI();
}

function switchToLoop() {
    dataSource = 'loop';
    loopStartTime = Date.now();
    resetState();
    updateSourceUI();
}

function updateSourceUI() {
    const csvRow = $('csv-row');
    const sourceLabel = $('sourceLabel');
    if (dataSource === 'csv') {
        csvRow.classList.add('visible');
        $('csv-name').textContent = csvFileName.length > 12 ? csvFileName.substring(0, 9) + '...' : csvFileName;
        sourceLabel.innerHTML = '<span class="bbHigh">CSV</span>';
    } else {
        csvRow.classList.remove('visible');
        sourceLabel.innerHTML = '<span class="bbHigh">SIM</span>';
    }
}

function formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function getCSVValues() {
    if (!csvData || csvData.length === 0) return null;
    const elapsed = Date.now() - csvStartTime;
    while (csvPlaybackIndex < csvData.length - 1 && csvData[csvPlaybackIndex + 1].relativeT <= elapsed) {
        csvPlaybackIndex++;
    }
    if (csvPlaybackIndex >= csvData.length - 1 && elapsed > csvDuration) {
        csvPlaybackIndex = 0;
        csvStartTime = Date.now();
    }
    const frame = csvData[csvPlaybackIndex];
    const progress = Math.min(1, elapsed / csvDuration);
    $('csv-bar').style.width = (progress * 100) + '%';
    $('csv-time').textContent = formatDuration(elapsed) + ' / ' + formatDuration(csvDuration);
    return {
        speed: frame.speed,
        lonG: frame.lonG,
        latG: frame.latG,
        yawDeg: frame.yawRad * 180 / Math.PI,
        mode: frame.mode,
        px: frame.px,
        py: frame.py,
        hasPosition: frame.hasPosition
    };
}

function seekCSV(pct) {
    if (!csvData || csvDuration === 0) return;
    const seekTime = pct * csvDuration;
    csvPlaybackIndex = 0;
    for (let i = 0; i < csvData.length; i++) {
        if (csvData[i].relativeT <= seekTime) csvPlaybackIndex = i;
        else break;
    }
    csvStartTime = Date.now() - seekTime;
}

// IndexedDB Recording (matches production)
const DB_NAME = 'blackbox-rec', DB_VERSION = 1, CHUNK_INTERVAL = 60000;
let db = null, sessionId = null, chunkBuffer = [], chunkIndex = 0, lastSaveTime = 0, recSessionStart = 0;

function openDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains('chunks')) {
                d.createObjectStore('chunks', { keyPath: ['sessionId', 'chunkIndex'] });
            }
            if (!d.objectStoreNames.contains('sessions')) {
                d.createObjectStore('sessions', { keyPath: 'sessionId' });
            }
        };
    });
}

async function saveChunk() {
    if (!db || chunkBuffer.length === 0) return;
    const data = [...chunkBuffer];
    try {
        const tx = db.transaction('chunks', 'readwrite');
        await new Promise((resolve, reject) => {
            const req = tx.objectStore('chunks').put({ sessionId, chunkIndex, data, timestamp: Date.now() });
            req.onsuccess = resolve; req.onerror = () => reject(req.error);
        });
        chunkIndex++; chunkBuffer = []; lastSaveTime = Date.now();
    } catch (e) { console.error('Chunk save failed:', e); }
}

async function startRecording() {
    if (!db) await openDB();
    sessionId = Date.now(); recSessionStart = sessionId; chunkBuffer = []; chunkIndex = 0; lastSaveTime = Date.now(); rec = true;
    const tx = db.transaction('sessions', 'readwrite');
    tx.objectStore('sessions').put({ sessionId, startTime: sessionId, status: 'active' });
    $('menu-rec').textContent = 'Stop Recording';
}

async function stopRecording() {
    if (chunkBuffer.length > 0) await saveChunk();
    if (db && sessionId) {
        const tx = db.transaction('sessions', 'readwrite');
        tx.objectStore('sessions').put({ sessionId, startTime: recSessionStart, status: 'complete', chunks: chunkIndex });
    }
    rec = false;
    $('menu-rec').textContent = 'Start Recording';
}

async function exportCSV() {
    if (!db) { alert('No data'); return; }
    if (rec && chunkBuffer.length > 0) await saveChunk();
    const tx = db.transaction(['sessions', 'chunks'], 'readonly');
    const sessions = await new Promise(r => { const req = tx.objectStore('sessions').getAll(); req.onsuccess = () => r(req.result); });
    if (!sessions.length) { alert('No recordings found'); return; }
    const latest = sessions.sort((a, b) => b.sessionId - a.sessionId)[0];
    const chunks = await new Promise(r => { const req = tx.objectStore('chunks').getAll(); req.onsuccess = () => r(req.result); });
    const sessionChunks = chunks.filter(c => c.sessionId === latest.sessionId).sort((a, b) => a.chunkIndex - b.chunkIndex);
    if (!sessionChunks.length) { alert('No data in recording'); return; }
    let allData = [];
    sessionChunks.forEach(c => allData = allData.concat(c.data));
    let csv = 'time,speed,ax,ay,wz,mode,lat_g,lon_g,gps_lat,gps_lon,gps_valid,pos_x,pos_y\n';
    allData.forEach(r => { csv += [r.t, r.sp, r.ax, r.ay, r.wz, r.mo, r.latg, r.lng, r.lat || 0, r.lon || 0, r.gpsOk || 0, r.px || 0, r.py || 0].join(',') + '\n'; });
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = 'blackbox_' + new Date(latest.sessionId).toISOString().slice(0, 19).replace(/[T:]/g, '-') + '.csv'; a.click();
}

// ========== TRACK DATABASE (IndexedDB) ==========
const TRACK_DB_NAME = 'blackbox-tracks', TRACK_DB_VERSION = 1;
let trackDb = null;

function openTrackDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(TRACK_DB_NAME, TRACK_DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => { trackDb = req.result; resolve(trackDb); };
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains('tracks')) {
                const store = d.createObjectStore('tracks', { keyPath: 'id' });
                store.createIndex('modified', 'modified', { unique: false });
            }
        };
    });
}

async function saveTrack(track) {
    if (!trackDb) await openTrackDB();
    track.modified = Date.now();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readwrite');
        const req = tx.objectStore('tracks').put(track);
        req.onsuccess = () => resolve(track);
        req.onerror = () => reject(req.error);
    });
}

async function getTrack(id) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readonly');
        const req = tx.objectStore('tracks').get(id);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function getAllTracks() {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readonly');
        const req = tx.objectStore('tracks').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

async function deleteTrack(id) {
    if (!trackDb) await openTrackDB();
    return new Promise((resolve, reject) => {
        const tx = trackDb.transaction('tracks', 'readwrite');
        const req = tx.objectStore('tracks').delete(id);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
    });
}

// ========== TRACK MANAGER STATE ==========
let activeTrack = null;
let currentSimPos = null;  // Updated by simulation loop

function generateTrackId() {
    return 'track_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// ========== TRACK MANAGER UI ==========
function openTrackModal() {
    $('track-modal').classList.add('open');
    renderTrackList();
    updateActiveTrackDisplay();
}

function closeTrackModal() {
    $('track-modal').classList.remove('open');
}

function updateActiveTrackDisplay() {
    const section = $('active-track-section');
    if (activeTrack) {
        section.style.display = 'block';
        $('active-track-name').textContent = activeTrack.name;
        const bestStr = activeTrack.bestLapMs ? formatLapTime(activeTrack.bestLapMs) : '—';
        $('active-track-meta').textContent = 'Best: ' + bestStr + ' · ' + (activeTrack.lapCount || 0) + ' laps';
    } else {
        section.style.display = 'none';
    }
}

function updateTrackModalPosition() {
    // Update position display in modal from current simulation state
    if (currentSimPos) {
        $('pos-xy').textContent = currentSimPos.x.toFixed(1) + ', ' + currentSimPos.y.toFixed(1) + ' m';
        $('pos-heading').textContent = (currentSimPos.heading * 180 / Math.PI).toFixed(0) + '°';
        $('pos-speed').textContent = (currentSimPos.speed * 3.6).toFixed(0) + ' km/h';
        $('btn-set-start').disabled = false;
    } else {
        $('pos-xy').textContent = 'Waiting...';
        $('pos-heading').textContent = '—';
        $('pos-speed').textContent = '—';
        $('btn-set-start').disabled = true;
    }
}

async function renderTrackList() {
    const listEl = $('track-list');
    try {
        const tracks = await getAllTracks();

        if (tracks.length === 0) {
            listEl.innerHTML = '<div class="bbTrackEmpty">No saved tracks</div>';
            return;
        }

        // Sort by most recently modified
        tracks.sort((a, b) => b.modified - a.modified);

        listEl.innerHTML = tracks.map(track => {
            const bestStr = track.bestLapMs ? formatLapTime(track.bestLapMs) : '—';
            const isActive = activeTrack && activeTrack.id === track.id;
            return '<div class="bbTrackItem" data-track-id="' + track.id + '">' +
                '<div class="bbTrackInfo">' +
                    '<div class="bbTrackName">' + escapeHtml(track.name) + (isActive ? ' ✓' : '') + '</div>' +
                    '<div class="bbTrackMeta">' +
                        '<span>Best: ' + bestStr + '</span>' +
                        '<span>' + (track.lapCount || 0) + ' laps</span>' +
                    '</div>' +
                '</div>' +
                '<div class="bbTrackActions">' +
                    '<button class="bbTrackBtn primary" data-action="use">Use</button>' +
                    '<button class="bbTrackBtn danger" data-action="delete">×</button>' +
                '</div>' +
            '</div>';
        }).join('');

        // Add event listeners
        listEl.querySelectorAll('.bbTrackBtn').forEach(btn => {
            btn.onclick = () => handleTrackAction(btn.dataset.action, btn.closest('.bbTrackItem').dataset.trackId);
        });
    } catch (e) {
        console.error('Failed to load tracks:', e);
        listEl.innerHTML = '<div class="bbTrackEmpty">Error loading tracks</div>';
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function handleTrackAction(action, trackId) {
    if (action === 'use') {
        const track = await getTrack(trackId);
        if (track) {
            activateTrack(track);
            closeTrackModal();
        }
    } else if (action === 'delete') {
        if (confirm('Delete this track?')) {
            await deleteTrack(trackId);
            if (activeTrack && activeTrack.id === trackId) {
                deactivateTrack();
            }
            renderTrackList();
        }
    }
}

function activateTrack(track) {
    activeTrack = track;

    // Set up the timing line from the track
    simTimingLine = {
        p1: track.startLine.p1,
        p2: track.startLine.p2,
        direction: track.startLine.direction
    };
    simPrevPos = null;

    // Activate lap timer
    lapTimerActive = true;
    lapTimerState = 'armed';
    lapStartTime = 0;
    currentLapMs = 0;
    lapCount = 0;
    bestLapMs = track.bestLapMs || null;
    lastLapMs = null;

    // Update UI
    const section = $('lap-section');
    section.classList.remove('inactive');
    section.classList.add('active');
    $('lap-time').textContent = '0:00.000';
    $('lap-count').textContent = 'Lap 0';
    $('lap-state').textContent = 'Armed';
    $('lap-state').classList.remove('timing');
    $('best-lap').textContent = bestLapMs ? formatLapTime(bestLapMs) : '—:——';
    $('best-lap').classList.toggle('best', !!bestLapMs);
    $('last-lap').textContent = '—:——';
    $('lap-delta').textContent = '—';
    $('lap-delta').className = 'bbLapHistValue bbNum delta';

    // Update setup text
    $('lap-setup-text').textContent = track.name;

    console.log('Track activated:', track.name, 'Timing line:', simTimingLine);
}

function deactivateTrack() {
    activeTrack = null;
    deactivateLapTimer();
    $('lap-setup-text').textContent = 'No track configured';
}

async function setStartLineHere() {
    if (!currentSimPos) {
        alert('Position not available. Start the simulation first.');
        return;
    }

    const x = currentSimPos.x;
    const y = currentSimPos.y;
    const heading = currentSimPos.heading;

    // Create perpendicular timing line (20m wide, 10m each side)
    const width = 10;
    const perpAngle = heading + Math.PI / 2;  // Perpendicular to heading

    const timingLine = {
        p1: [x + Math.cos(perpAngle) * width, y + Math.sin(perpAngle) * width],
        p2: [x - Math.cos(perpAngle) * width, y - Math.sin(perpAngle) * width],
        direction: heading  // Valid crossing direction = current heading
    };

    // Create track object
    const trackName = prompt('Enter track name:', 'Track ' + new Date().toLocaleDateString());
    if (!trackName) return;  // User cancelled

    const track = {
        id: generateTrackId(),
        name: trackName,
        type: 'loop',
        created: Date.now(),
        modified: Date.now(),
        startLine: timingLine,
        origin: { x, y },
        bestLapMs: null,
        lapCount: 0
    };

    // Save to IndexedDB
    await saveTrack(track);

    // Activate the track
    activateTrack(track);

    // Suppress start line indicator for newly created tracks (user is already at the line)
    suppressStartLineIndicator = true;

    // Close modal
    closeTrackModal();

    console.log('Track created:', track);
}

async function clearActiveTrack() {
    if (!activeTrack) return;
    deactivateTrack();
    updateActiveTrackDisplay();
    renderTrackList();
}

// Update track's best lap when a new best is set
async function updateTrackBestLap(lapTimeMs) {
    if (!activeTrack) return;

    if (!activeTrack.bestLapMs || lapTimeMs < activeTrack.bestLapMs) {
        activeTrack.bestLapMs = lapTimeMs;
    }
    activeTrack.lapCount = (activeTrack.lapCount || 0) + 1;
    await saveTrack(activeTrack);
}

// State
let loopStartTime = Date.now();
let sessionStart = Date.now();
let rec = false, cnt = 0, drops = 0;

// === LAP TIMER STATE ===
let lapTimerActive = false;
let lapTimerState = 'idle'; // 'idle', 'armed', 'timing'
let suppressStartLineIndicator = false; // True after creating new track, cleared on first crossing
let lapStartTime = 0;
let currentLapMs = 0;
let lapCount = 0;
let bestLapMs = null;
let lastLapMs = null;
let lapCrossingDebounce = 0;
const LAP_DEBOUNCE_MS = 1000; // Prevent double-crossings
const MIN_LAP_TIME_MS = 5000; // 5 second minimum lap

function formatLapTime(ms) {
    if (ms === null || ms === undefined) return '—:——';
    const totalSec = ms / 1000;
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    return min + ':' + sec.toFixed(3).padStart(6, '0');
}

function activateLapTimer() {
    lapTimerActive = true;
    lapTimerState = 'armed';
    lapStartTime = 0;
    currentLapMs = 0;
    lapCount = 0;
    bestLapMs = null;
    lastLapMs = null;
    lapCrossingDebounce = 0;

    // Configure timing line at the track start
    // The track starts at (0, 0) heading north (+Y)
    // Create a 20m wide timing line perpendicular to the start direction
    const lineWidth = 10;  // 10m each side
    simTimingLine = {
        p1: [-lineWidth, 0],  // Left side of timing line
        p2: [lineWidth, 0],   // Right side of timing line
        direction: Math.PI / 2  // Valid crossing direction: north (+Y)
    };
    simPrevPos = null;  // Clear previous position

    // Reset loop timing so we start at the beginning of the track
    loopStartTime = Date.now();

    const section = $('lap-section');
    section.classList.remove('inactive');
    section.classList.add('active');

    $('lap-state').textContent = 'Armed';
    $('lap-state').classList.remove('timing');
    $('lap-delta').textContent = '—';
    $('lap-delta').className = 'bbLapHistValue bbNum delta';
    $('menu-lap').textContent = 'Stop Lap Timer';

    updateLapDisplay();
    console.log('Lap timer activated with timing line:', simTimingLine);
}

function deactivateLapTimer() {
    lapTimerActive = false;
    lapTimerState = 'idle';

    // Clear timing line and position tracking
    simTimingLine = null;
    simPrevPos = null;

    const section = $('lap-section');
    section.classList.remove('active', 'timing');
    section.classList.add('inactive');
    $('menu-lap').textContent = 'Simulate Track';
}

function updateLapDisplay() {
    $('lap-time').textContent = formatLapTime(currentLapMs);
    $('lap-count').textContent = 'Lap ' + lapCount;

    if (bestLapMs !== null) {
        $('best-lap').textContent = formatLapTime(bestLapMs);
        $('best-lap').classList.add('best');
    } else {
        $('best-lap').textContent = '—:——';
        $('best-lap').classList.remove('best');
    }

    if (lastLapMs !== null) {
        $('last-lap').textContent = formatLapTime(lastLapMs);
    } else {
        $('last-lap').textContent = '—:——';
    }
}

// Calculate distance and bearing from current position to timing line center
function getDistanceToStartLine() {
    if (!simTimingLine || !currentSimPos) return null;

    // Center of timing line
    const cx = (simTimingLine.p1[0] + simTimingLine.p2[0]) / 2;
    const cy = (simTimingLine.p1[1] + simTimingLine.p2[1]) / 2;

    // Vector from current position to timing line center
    const dx = cx - currentSimPos.x;
    const dy = cy - currentSimPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Bearing in radians (0 = east, π/2 = north)
    const bearing = Math.atan2(dy, dx);

    return { distance, bearing, cx, cy };
}

// Convert bearing to arrow character (cardinal direction relative to current heading)
function bearingToArrow(bearing, currentHeading) {
    // Relative bearing (how far to turn from current heading)
    let relBearing = bearing - currentHeading;

    // Normalize to [-π, π]
    while (relBearing > Math.PI) relBearing -= 2 * Math.PI;
    while (relBearing < -Math.PI) relBearing += 2 * Math.PI;

    // Convert to 8-direction arrow
    const deg = relBearing * 180 / Math.PI;
    if (deg > -22.5 && deg <= 22.5) return '↑';      // Ahead
    if (deg > 22.5 && deg <= 67.5) return '↗';      // Ahead-right
    if (deg > 67.5 && deg <= 112.5) return '→';     // Right
    if (deg > 112.5 && deg <= 157.5) return '↘';    // Behind-right
    if (deg > 157.5 || deg <= -157.5) return '↓';   // Behind
    if (deg > -157.5 && deg <= -112.5) return '↙';  // Behind-left
    if (deg > -112.5 && deg <= -67.5) return '←';   // Left
    if (deg > -67.5 && deg <= -22.5) return '↖';    // Ahead-left
    return '•';
}

// Update the start line indicator UI
function updateStartLineIndicator() {
    const indicator = $('start-line-indicator');
    const textEl = $('start-line-text');

    if (!indicator || !textEl) return;

    // Only show when armed (not timing or idle)
    if (lapTimerState !== 'armed' || !simTimingLine || !currentSimPos) {
        indicator.style.display = 'none';
        return;
    }

    indicator.style.display = 'block';

    // For newly created tracks, show instruction instead of distance
    if (suppressStartLineIndicator) {
        textEl.textContent = 'Drive track, cross start to begin';
        textEl.className = 'bbStartLineText';
        return;
    }

    const result = getDistanceToStartLine();
    if (!result) {
        textEl.textContent = 'Position unavailable';
        textEl.className = 'bbStartLineText';
        return;
    }

    const { distance, bearing } = result;
    const arrow = bearingToArrow(bearing, currentSimPos.heading);

    // Distance-based messaging for loaded tracks
    if (distance > 100) {
        textEl.textContent = 'Start: ' + Math.round(distance) + 'm ' + arrow;
        textEl.className = 'bbStartLineText';
    } else if (distance > 50) {
        textEl.textContent = 'Approaching: ' + Math.round(distance) + 'm ' + arrow;
        textEl.className = 'bbStartLineText approaching';
    } else if (distance > 15) {
        textEl.textContent = 'Getting close: ' + Math.round(distance) + 'm ' + arrow;
        textEl.className = 'bbStartLineText close';
    } else {
        textEl.textContent = 'Cross to begin! ' + arrow;
        textEl.className = 'bbStartLineText at-line';
    }
}

function onLineCrossing(timestamp) {
    if (!lapTimerActive) return;

    // Debounce check
    if (timestamp - lapCrossingDebounce < LAP_DEBOUNCE_MS) return;
    lapCrossingDebounce = timestamp;

    if (lapTimerState === 'armed') {
        // First crossing - start timing
        lapTimerState = 'timing';
        lapStartTime = timestamp;
        currentLapMs = 0;
        suppressStartLineIndicator = false; // Clear suppression on first crossing
        $('lap-state').textContent = 'Timing';
        $('lap-state').classList.add('timing');

        // Add timing class to card (hides start line indicator via CSS)
        const section = $('lap-section');
        section.classList.add('timing');

        // Flash to indicate crossing
        section.classList.add('bbLapFlash');
        setTimeout(() => section.classList.remove('bbLapFlash'), 600);

    } else if (lapTimerState === 'timing') {
        // Complete lap
        const lapTimeMs = timestamp - lapStartTime;

        // Validate lap time
        if (lapTimeMs < MIN_LAP_TIME_MS) {
            // Invalid lap - too short
            return;
        }

        lastLapMs = lapTimeMs;
        lapCount++;

        const isNewBest = bestLapMs === null || lapTimeMs < bestLapMs;
        if (isNewBest) {
            bestLapMs = lapTimeMs;
        }

        // Update delta display
        const deltaEl = $('lap-delta');
        if (isNewBest && lapCount > 1) {
            // Just set a new best (and had a previous best to compare)
            deltaEl.textContent = 'BEST';
            deltaEl.className = 'bbLapHistValue bbNum delta faster';
        } else if (!isNewBest) {
            const deltaMs = lapTimeMs - bestLapMs;
            const sign = deltaMs > 0 ? '+' : '';
            deltaEl.textContent = sign + (deltaMs / 1000).toFixed(3);
            deltaEl.className = 'bbLapHistValue bbNum delta slower';
        } else {
            // First lap, no comparison
            deltaEl.textContent = '—';
            deltaEl.className = 'bbLapHistValue bbNum delta';
        }

        // Flash animations
        const section = $('lap-section');
        section.classList.add('bbLapFlash');
        setTimeout(() => section.classList.remove('bbLapFlash'), 600);

        if (isNewBest) {
            const bestEl = $('best-lap');
            bestEl.classList.add('bbLapBestFlash');
            setTimeout(() => bestEl.classList.remove('bbLapBestFlash'), 800);
        }

        // Update track's best lap in IndexedDB
        updateTrackBestLap(lapTimeMs);

        // Start new lap
        lapStartTime = timestamp;
        currentLapMs = 0;

        updateLapDisplay();
    }
}

/**
 * Update lap timer state and check for line crossings
 * @param {number} now - Current timestamp (ms)
 * @param {Object|null} posData - Position data: {x, y, vx, vy, speed} or null
 */
function simulateLapTimerUpdate(now, posData) {
    if (!lapTimerActive) return;

    // Update current lap time if timing
    if (lapTimerState === 'timing') {
        currentLapMs = now - lapStartTime;
        $('lap-time').textContent = formatLapTime(currentLapMs);
    }

    // Geometry-based crossing detection (requires position data and timing line)
    if (posData && simTimingLine) {
        // Need previous position for crossing detection
        if (simPrevPos) {
            // Skip if nearly stationary (< 0.5 m/s)
            if (posData.speed >= 0.5) {
                // Check for line crossing
                const intersection = lineSegmentIntersection(
                    [simPrevPos.x, simPrevPos.y],
                    [posData.x, posData.y],
                    simTimingLine.p1,
                    simTimingLine.p2
                );

                if (intersection !== null) {
                    // Validate crossing direction
                    if (directionValid([posData.vx, posData.vy], simTimingLine.direction)) {
                        onLineCrossing(now);
                    }
                }
            }
        }

        // Store current position for next frame
        simPrevPos = { x: posData.x, y: posData.y };
    }
}
let trail = [], maxL = 0, maxR = 0, maxA = 0, maxB = 0, peak = 0;
let emaGx = 0, emaGy = 0, lastT = 0, speed_ema = 0;
const EMA_TAU = 0.10;
const TRAIL_DURATION_MS = 2500;
const TRAIL_MAX_POINTS = 60;
const TRAIL_JITTER_THRESHOLD = 0.008;

const SCALE_STEPS = [0.3, 0.5, 0.8, 1.0, 1.5, 2.0];
let currentScale = 0.5;

let config = { acc_thr: 0.22, acc_exit: 0.11, brake_thr: 0.35, brake_exit: 0.17, lat_thr: 0.28, lat_exit: 0.14, yaw_thr: 0.10, min_speed: 3.0, alpha: 0.35 };
let emaLat = 0, emaYaw = 0, inAccel = false, inBrake = false, inCorner = false;

function classifyMode(lonG, latG, yawRad, speedMs) {
    emaLat = config.alpha * Math.abs(latG) + (1 - config.alpha) * emaLat;
    emaYaw = config.alpha * Math.abs(yawRad) + (1 - config.alpha) * emaYaw;
    if (speedMs < config.min_speed) { inAccel = inBrake = inCorner = false; return 0; }
    if (lonG > config.acc_thr) inAccel = true; else if (lonG < config.acc_exit) inAccel = false;
    if (lonG < -config.brake_thr) inBrake = true; else if (lonG > -config.brake_exit) inBrake = false;
    const signConsistent = (latG * yawRad) > 0;
    if (emaLat > config.lat_thr && emaYaw > config.yaw_thr && signConsistent) inCorner = true;
    else if (emaLat < config.lat_exit || emaYaw < config.yaw_thr * 0.5) inCorner = false;
    let mode = 0;
    if (inAccel) mode |= 1; if (inBrake) mode |= 2; if (inCorner) mode |= 4;
    if ((mode & 3) === 3) mode &= ~2;
    return mode;
}

let isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
function applyTheme() {
    document.body.classList.toggle('dark', isDark);
    $('modeLabel').textContent = isDark ? 'Dark' : 'Bright';
}
applyTheme();

$('brandToggle').onclick = () => { isDark = !isDark; applyTheme(); };

const cv = $('gcanvas');
const ctx = cv.getContext('2d');

function resize() {
    const frame = cv.parentElement;
    const rect = frame.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    cv.width = size * devicePixelRatio;
    cv.height = size * devicePixelRatio;
    cv.style.width = size + 'px';
    cv.style.height = size + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
}
resize();
window.addEventListener('resize', resize);

let magHist = [];
function updateScale(gx, gy) {
    const now = Date.now();
    const mag = Math.sqrt(gx * gx + gy * gy);
    magHist.push({ t: now, m: mag });
    magHist = magHist.filter(h => now - h.t < 1000);
    const peakMag = Math.max(...magHist.map(h => h.m), 0.1);
    const needed = peakMag * 1.4;
    let targetScale = SCALE_STEPS[0];
    for (const step of SCALE_STEPS) {
        if (step >= needed) { targetScale = step; break; }
        targetScale = step;
    }
    if (targetScale > currentScale) currentScale += (targetScale - currentScale) * 0.15;
    else if (targetScale < currentScale) currentScale += (targetScale - currentScale) * 0.03;
    for (const step of SCALE_STEPS) {
        if (Math.abs(currentScale - step) < 0.02) { currentScale = step; break; }
    }
    $('range-val').textContent = 'Range ±' + currentScale.toFixed(1) + 'g';
}

function hexToRgba(hex, a) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${a})`;
}

function downsampleTrail(points, maxPoints) {
    if (points.length <= maxPoints) return points;
    const recentCount = Math.min(25, Math.floor(maxPoints * 0.4));
    const recent = points.slice(-recentCount);
    const older = points.slice(0, -recentCount);
    const olderTarget = maxPoints - recentCount;
    const step = Math.ceil(older.length / olderTarget);
    const sampled = older.filter((_, i) => i % step === 0);
    return [...sampled, ...recent];
}

function drawG() {
    const size = cv.width / devicePixelRatio;
    const cx = size / 2, cy = size / 2;
    const r = size * 0.38;

    ctx.clearRect(0, 0, size, size);

    const ringColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
    const axisColor = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.18)';

    ctx.lineWidth = 1;
    ctx.strokeStyle = ringColor;
    [0.2, 0.4, 0.6, 0.8].forEach((f) => {
        ctx.beginPath();
        ctx.arc(cx, cy, r * f, 0, Math.PI * 2);
        ctx.stroke();
    });

    ctx.strokeStyle = axisColor;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
    ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
    ctx.stroke();

    ctx.fillStyle = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fill();

    const now = Date.now();
    const recentTrail = trail.filter(p => now - p.t < TRAIL_DURATION_MS);
    const displayTrail = downsampleTrail(recentTrail, TRAIL_MAX_POINTS);

    if (displayTrail.length > 1) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        for (let i = 1; i < displayTrail.length; i++) {
            const p0 = displayTrail[i - 1];
            const p1 = displayTrail[i];
            const age = (now - p1.t) / TRAIL_DURATION_MS;
            const alpha = Math.max(0.05, 0.35 * (1 - age * 0.85));
            ctx.strokeStyle = hexToRgba(currentModeColor, alpha);
            ctx.lineWidth = 1.5 - age * 0.6;
            ctx.beginPath();
            const x0 = cx + (p0.x / currentScale) * r;
            const y0 = cy - (p0.y / currentScale) * r;
            const x1 = cx + (p1.x / currentScale) * r;
            const y1 = cy - (p1.y / currentScale) * r;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }
    }

    if (trail.length > 0) {
        const cur = trail[trail.length - 1];
        const x = cx + (cur.x / currentScale) * r;
        const y = cy - (cur.y / currentScale) * r;
        const crossSize = 8;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x - crossSize, y);
        ctx.lineTo(x + crossSize, y);
        ctx.moveTo(x, y - crossSize);
        ctx.lineTo(x, y + crossSize);
        ctx.stroke();
    }
}

function fmtGSigned(v) {
    const sign = v >= 0 ? '+' : '−';
    return { sign, num: Math.abs(v).toFixed(2) };
}

function fmtTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return m + ':' + String(s % 60).padStart(2, '0');
}

function updateModeDisplay(mo) {
    const name = MODES[mo] || 'IDLE';
    const color = MODE_COLORS[mo] || MODE_COLORS[0];
    const hexColors = getModeColorsHex();
    currentModeColor = hexColors[mo] || hexColors[0];
    const el = $('maneuver');
    el.textContent = name;
    el.style.color = color;
}

function updateReadouts(lat, lon) {
    const latFmt = fmtGSigned(lat);
    const lonFmt = fmtGSigned(lon);
    $('lat-g').innerHTML = `<span class="bbSign">${latFmt.sign}</span><span class="bbVal">${latFmt.num}</span><span class="bbGUnit">g</span>`;
    $('lon-g').innerHTML = `<span class="bbSign">${lonFmt.sign}</span><span class="bbVal">${lonFmt.num}</span><span class="bbGUnit">g</span>`;
}

function resetState() {
    maxL = maxR = maxA = maxB = peak = drops = 0;
    $('max-l').textContent = $('max-r').textContent = $('max-a').textContent = $('max-b').textContent = '0.00g';
    $('speed').classList.remove('peak');
    trail = []; magHist = []; currentScale = SCALE_STEPS[0];
    $('range-val').textContent = 'Range ±' + currentScale.toFixed(1) + 'g';
    emaGx = emaGy = 0; sessionStart = Date.now();
}

let peakHighlightTimeout = null;

function simulate() {
    let sp, longRaw, latRaw, yawDeg, yawRad, speedMs, mo;
    let posData = null;  // Position data for lap timer: {x, y, vx, vy, speed}

    if (dataSource === 'csv' && csvData) {
        const values = getCSVValues();
        if (!values) return;
        sp = values.speed;
        longRaw = values.lonG;
        latRaw = values.latG;
        yawDeg = Math.abs(values.yawDeg);
        yawRad = values.yawDeg * Math.PI / 180;
        speedMs = sp / 3.6;
        mo = values.mode;

        // If CSV has position data, use it for lap timing
        if (values.hasPosition && (values.px !== 0 || values.py !== 0)) {
            // Estimate velocity from speed and heading (using yaw as rough approximation)
            // For more accurate velocity, we'd need to track position changes
            const heading = yawRad;  // Use yaw as heading approximation
            posData = {
                x: values.px,
                y: values.py,
                vx: speedMs * Math.cos(heading),
                vy: speedMs * Math.sin(heading),
                speed: speedMs
            };
        }
    } else {
        const elapsed = Date.now() - loopStartTime;
        const auto = getAutoValues(elapsed);
        sp = addNoise(auto.speed, 2);
        longRaw = addNoise(auto.lonG, 0.02);
        latRaw = addNoise(auto.latG, 0.02);
        yawDeg = Math.abs(addNoise(auto.yawDeg, 1));
        yawRad = auto.yawDeg * Math.PI / 180;
        speedMs = sp / 3.6;
        mo = classifyMode(longRaw, latRaw, yawRad, speedMs);

        // Get position data for lap timer from track simulation
        const pos = getSimulatedPosition(elapsed);
        posData = {
            x: pos.x,
            y: pos.y,
            vx: pos.vx,
            vy: pos.vy,
            speed: pos.speed
        };

        // Update current position for track manager
        currentSimPos = {
            x: pos.x,
            y: pos.y,
            heading: pos.heading,
            speed: pos.speed
        };

        // Update track modal position display if open
        if ($('track-modal').classList.contains('open')) {
            updateTrackModalPosition();
        }

        // Update start line indicator
        updateStartLineIndicator();
    }

    speed_ema = 0.7 * sp + 0.3 * speed_ema;
    const dspd = speed_ema < 1 ? 0 : Math.round(speed_ema);

    const now = Date.now();
    const dt = lastT ? Math.min((now - lastT) / 1000, 0.2) : 0.033;
    lastT = now;
    const alpha = 1 - Math.exp(-dt / EMA_TAU);

    emaGx = alpha * latRaw + (1 - alpha) * emaGx;
    emaGy = alpha * longRaw + (1 - alpha) * emaGy;

    const mag = Math.sqrt(emaGx * emaGx + emaGy * emaGy);
    const noise = speed_ema < 5 ? 0.04 : 0.015;
    const lat = mag < noise ? 0 : emaGx;
    const lon = mag < noise ? 0 : emaGy;

    const speedEl = $('speed');
    if (dspd > peak) {
        peak = dspd;
        speedEl.classList.add('peak');
        if (peakHighlightTimeout) clearTimeout(peakHighlightTimeout);
        peakHighlightTimeout = setTimeout(() => speedEl.classList.remove('peak'), 900);
    }
    speedEl.textContent = dspd;

    updateModeDisplay(mo);
    updateReadouts(lat, lon);
    $('yaw').textContent = Math.round(yawDeg);

    if (latRaw < 0 && Math.abs(latRaw) > maxL) { maxL = Math.abs(latRaw); $('max-l').textContent = maxL.toFixed(2) + 'g'; }
    if (latRaw > 0 && latRaw > maxR) { maxR = latRaw; $('max-r').textContent = maxR.toFixed(2) + 'g'; }
    if (longRaw > 0 && longRaw > maxA) { maxA = longRaw; $('max-a').textContent = maxA.toFixed(2) + 'g'; }
    if (longRaw < 0 && Math.abs(longRaw) > maxB) { maxB = Math.abs(longRaw); $('max-b').textContent = maxB.toFixed(2) + 'g'; }

    if (speed_ema >= 2) {
        updateScale(lat, lon);
    } else {
        magHist = [];
        currentScale = SCALE_STEPS[0];
        $('range-val').textContent = 'Range ±' + currentScale.toFixed(1) + 'g';
    }

    const lastPt = trail.length > 0 ? trail[trail.length - 1] : null;
    const dx = lastPt ? Math.abs(lat - lastPt.x) : 1;
    const dy = lastPt ? Math.abs(lon - lastPt.y) : 1;
    if (!lastPt || dx > TRAIL_JITTER_THRESHOLD || dy > TRAIL_JITTER_THRESHOLD) {
        trail.push({ x: lat, y: lon, t: now });
    }
    trail = trail.filter(p => now - p.t < TRAIL_DURATION_MS + 200);
    drawG();

    cnt++;
    if (rec) {
        // Get position data from already-computed posData (if available)
        const px = posData ? posData.x : 0;
        const py = posData ? posData.y : 0;
        chunkBuffer.push({ t: now, sp, ax: -longRaw * 9.81, ay: latRaw * 9.81, wz: yawRad, mo, latg: latRaw, lng: longRaw, lat: 37.82, lon: -122.48, gpsOk: 1, px, py });
        if (now - lastSaveTime >= CHUNK_INTERVAL) saveChunk();
    }

    // Update lap timer with position data for crossing detection
    simulateLapTimerUpdate(now, posData);
}

setInterval(simulate, 33);

setInterval(() => {
    $('hz').textContent = cnt;
    cnt = 0;
    $('session-time').textContent = fmtTime(Date.now() - sessionStart);
    $('gps-acc').textContent = '2';
    $('drops').textContent = drops;
}, 1000);

$('menu-btn').onclick = () => $('menu-overlay').classList.add('open');
$('menu-overlay').onclick = e => { if (e.target === $('menu-overlay')) $('menu-overlay').classList.remove('open'); };

$('menu-load').onclick = () => {
    $('menu-overlay').classList.remove('open');
    $('csv-input').click();
};

$('csv-input').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => loadCSVData(evt.target.result, file.name);
    reader.readAsText(file);
};

$('menu-sim').onclick = () => {
    $('menu-overlay').classList.remove('open');
    switchToLoop();
};

$('csv-progress').onclick = (e) => {
    const rect = e.target.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    seekCSV(pct);
};

$('menu-rec').onclick = async () => {
    $('menu-overlay').classList.remove('open');
    if (rec) await stopRecording();
    else { sessionStart = Date.now(); await startRecording(); }
};

$('menu-export').onclick = () => {
    $('menu-overlay').classList.remove('open');
    exportCSV();
};

$('menu-clear').onclick = () => {
    $('menu-overlay').classList.remove('open');
    loopStartTime = Date.now();
    resetState();
};

// Lap timer controls
// Open track manager from lap card button
$('btn-open-tracks').onclick = () => {
    openTrackModal();
};

// Open track manager from menu
$('menu-tracks').onclick = () => {
    $('menu-overlay').classList.remove('open');
    openTrackModal();
};

// Legacy: "Simulate Track" in menu - quick activate with simulated block track
$('menu-lap').onclick = () => {
    $('menu-overlay').classList.remove('open');
    if (lapTimerActive) {
        deactivateLapTimer();
        activeTrack = null;
        $('lap-setup-text').textContent = 'No track configured';
    } else {
        // Quick simulate with default block track timing line
        activateLapTimer();
    }
};

// Track modal close button
$('track-modal-close').onclick = closeTrackModal;

// Close modal when clicking outside
$('track-modal').onclick = (e) => {
    if (e.target === $('track-modal')) closeTrackModal();
};

// Set start line button
$('btn-set-start').onclick = setStartLineHere;

// Clear active track button
$('btn-clear-track').onclick = clearActiveTrack;

// Initialize
setTimeout(() => { resize(); drawG(); }, 50);
openDB().catch(e => console.log('IndexedDB error:', e));
openTrackDB().catch(e => console.log('Track DB error:', e));
</script>
</body></html>
